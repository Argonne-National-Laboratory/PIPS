<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ConicBundle: ConicBundle::FunctionOracle Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceConicBundle.html">ConicBundle</a>::<a class="el" href="classConicBundle_1_1FunctionOracle.html">FunctionOracle</a>
  </div>
</div>
<div class="contents">
<h1>ConicBundle::FunctionOracle Class Reference<br>
<small>
[<a class="el" href="group__cxxinterface.html">Interface to ConicBundle for the Language C++</a>]</small>
</h1><!-- doxytag: class="ConicBundle::FunctionOracle" --><!-- doxytag: inherits="ConicBundle::FunctionObject" -->oracle interface (abstract class). For each of your functions, provide a derived class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="CBSolver_8hxx-source.html">CBSolver.hxx</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for ConicBundle::FunctionOracle:</div>
<div class="dynsection">

<p><center><img src="classConicBundle_1_1FunctionOracle.png" usemap="#ConicBundle::FunctionOracle_map" border="0" alt=""></center>
<map name="ConicBundle::FunctionOracle_map">
<area href="classConicBundle_1_1FunctionObject.html" alt="ConicBundle::FunctionObject" shape="rect" coords="0,0,178,24">
</map>
</div>

<p>
<a href="classConicBundle_1_1FunctionOracle-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1FunctionOracle.html#62bbdbf390aa0a1c4a9cc983c74c9bf8">evaluate</a> (const <a class="el" href="group__cxxinterface.html#gda58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;current_point, double relprec, double &amp;objective_value, <a class="el" href="group__cxxinterface.html#gda58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;cut_values, std::vector&lt; <a class="el" href="group__cxxinterface.html#gda58ad89c25718a894f1399f7c061f0b">DVector</a> &gt; &amp;eps_subgradients, std::vector&lt; <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> * &gt; &amp;primal_data, <a class="el" href="classConicBundle_1_1PrimalExtender.html">PrimalExtender</a> *&amp;primal_extender)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by the solver. Has to Return function value and at least one (epsilon) subgradient and, possibly for Lagrangean relaxation, some primal data.  <a href="#62bbdbf390aa0a1c4a9cc983c74c9bf8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1FunctionOracle.html#872c680d1d9247262b6fb65a91695210">subgradient_extension</a> (const <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *, const <a class="el" href="group__cxxinterface.html#g2ba782d3f05e6d9a1964638a6b97a390">IVector</a> &amp;, <a class="el" href="group__cxxinterface.html#gda58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine is need not be implemented unless variables (constraints in Lagrangean relaxation) are added on the fly.  <a href="#872c680d1d9247262b6fb65a91695210"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
oracle interface (abstract class). For each of your functions, provide a derived class. 
<p>
The oracle interface is used to describe and pass convex objective functions to the <a class="el" href="classConicBundle_1_1CBSolver.html" title="Bundle method solver.">ConicBundle::CBSolver</a>. The dimension of the argument vector of the function must be set in <a class="el" href="classConicBundle_1_1CBSolver.html#aaca3b1092a1305a8ddf4f181e1bf256" title="Initializes the problem by setting up the design space (the dimension and possible...">ConicBundle::CBSolver::init_problem()</a> and the functions are then added to the solver by <a class="el" href="classConicBundle_1_1CBSolver.html#76de315bec233bec71b1cf9d2ed3df69" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions...">ConicBundle::CBSolver::add_function()</a>.<p>
If the sum of several such functions is to be minimized it is the task of the user to guarantee, that all dimensions match.<p>
If the function corresponds to Lagrangean relaxation of a primal maximization problem one may want to generate a primal approximate solution. In this case, return in the function ConicBundle::CBSolver::evaluate() the generating primal objects for each subgradient. If no primal objects are returned, there will be no primal aggregation.<p>
If primal aggregation is used then it is possible to implement a primal cutting plane framework. This requires the introduction of new (dual) variables in the design space of the function. In this case the function ConicBundle::CBSolver::subgradient_extension() serves the purpose of filling in the missing coordinates in existing subgradients. If this feature is not needed, the function may be used as is and need not be reimplemented. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="62bbdbf390aa0a1c4a9cc983c74c9bf8"></a><!-- doxytag: member="ConicBundle::FunctionOracle::evaluate" ref="62bbdbf390aa0a1c4a9cc983c74c9bf8" args="(const DVector &amp;current_point, double relprec, double &amp;objective_value, DVector &amp;cut_values, std::vector&lt; DVector &gt; &amp;eps_subgradients, std::vector&lt; PrimalData * &gt; &amp;primal_data, PrimalExtender *&amp;primal_extender)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::FunctionOracle::evaluate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__cxxinterface.html#gda58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>current_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>relprec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>objective_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxxinterface.html#gda58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__cxxinterface.html#gda58ad89c25718a894f1399f7c061f0b">DVector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>eps_subgradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>primal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1PrimalExtender.html">PrimalExtender</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>primal_extender</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by the solver. Has to Return function value and at least one (epsilon) subgradient and, possibly for Lagrangean relaxation, some primal data. 
<p>
The evaluation method is the main interface to the bundle solver. The solver calls this method to obtain for the <em>current_point</em> (its dimension is set in <a class="el" href="classConicBundle_1_1CBSolver.html#aaca3b1092a1305a8ddf4f181e1bf256" title="Initializes the problem by setting up the design space (the dimension and possible...">ConicBundle::CBSolver::init_problem()</a>) the  and (epsilon) subgradient information. In any call several epsilon subgradients may be returned in <em>cut_values</em> and <em>eps_subgradients</em>, but at least one has to be returend. Each subgradient describes a linear minorant to the convex function and is used by the bundle method to form a cutting model of the convex function.<p>
The i-th linear minorant consits of <em>cut_values</em>[i] (the value of the cutting plane in <em>current_point</em>) and epssubgradients[i] (a <a class="el" href="group__cxxinterface.html#gda58ad89c25718a894f1399f7c061f0b" title="A dense vector of double, arguments and subgradients are specified like this.">ConicBundle::DVector</a> that describes the linear behavior)<p>
In many applications, computing the function value is an iterative process that approaches the true function value from below. On input the code offers a bound in <em>objective_value</em> for the function value, above which it is certain that the code will reject the current point. If in the iterative process a lower bound on the function value exceeds this bound, then it is sufficient to return, instead of the true function value and a subgradient, the current lower bound and a vector so that together they describe a supporting hyperplane (i.e. a linear minorant) to the function at this point.<p>
If the function corresponds to Lagrangean relaxation of a primal maximization problem one may want to generate a primal approximate solution. The parameter <em>primal_data</em> serves this purpose. If at each call and for each epsilon subgradient the corresponding generating primal object (must be derived from <a class="el" href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying...">ConicBundle::PrimalData</a>, e.g., a <a class="el" href="classConicBundle_1_1PrimalDVector.html" title="If in Lagrangean relaxation primal solutions are in the form of a ConicBundle::DVector...">ConicBundle::PrimalDVector</a>) is stored in <em>primal_data</em>, then the code automatically performs the aggregation corresponding to the aggregation of the subgradients on the primal data objects. The primal approximate solution is finally delivered by the methods <a class="el" href="classConicBundle_1_1CBSolver.html#80d49e1d0c6d26b5ca896b584502f355" title="returns the current approximate primal solution corresponding to the aggregate subgradient...">ConicBundle::CBSolver::get_approximate_primal()</a> or <a class="el" href="classConicBundle_1_1CBSolver.html#5682f90a5ed3d6cd8c40b6e24ef35de6" title="Returns the primal solution corresponding to the best epsilon subgradient returned...">ConicBundle::CBSolver::get_center_primal()</a>. All primal objects passed to the solver via <em>primal_data</em> must be objects allocated on the heap. The ownership of tese objects is transferred to the solver and the solver will destroy them eventually, so DO NOT delete them yourself!<p>
If no primal aggregation is desired, simply do not touch <em>primal_data</em> or clear it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>current_point</em>&nbsp;</td><td>(const DVector&amp;) argument of the function (e.g. the Lagrange multipliers)</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>relprec</em>&nbsp;</td><td>(double) relative precision requirement for objective values that may lead to descent steps (this precision is not required if it is already certain that the function value will be too poor)</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>objective_value</em>&nbsp;</td><td>(double&amp;)<ul>
<li>on input: value gives the threshold for a null step; you may stop, if a cutting plane yields at least this;</li><li>on output: return an upper bound on the true function value within <em>relprec</em> *(abs(objval)+1.), if there is no linear minorant cutting above the threshold specified in objective_value on input. Otherwise the return value should be the max of cut_values.</li></ul>
</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>cut_values</em>&nbsp;</td><td>(Dvector&amp;) store for each linear minorant (epsilon subgradient) the value at the argument (must correspond to sequence in subgradients)</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>eps_subgradients</em>&nbsp;</td><td>(std::vector&lt;DVector&gt;&amp;) store for each linear minorant the epsilon subgradient vector (each of the same length as the argument, must correspond in sequence to cut_values.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>primal_data</em>&nbsp;</td><td>(std::vector&lt;PrimalData*&gt;&amp;) If the function arises from Lagrangean relaxation and a primal approximation is desired then return the primal data objects corresponding to the eps_subgradients. The control over all <a class="el" href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying...">PrimalData</a> objects pointed to by primal_data is passed to the calling routine. The calling routine will delete these objectes eventually.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>primal_extender</em>&nbsp;</td><td>(PrimalExtender*&amp;) if primal_data of previous calls has now to be updated due to changes in the primal problem -- e.g., this may happen in column generation -- one may return a pointer to <a class="el" href="classConicBundle_1_1PrimalExtender.html" title="Interface for extending PrimalData, e.g., in column generation approaches.">PrimalExtender</a> object on the heap. This object will be used by <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual...">ConicBundle</a> to update all its internally stored primal_data objects by calling <a class="el" href="classConicBundle_1_1PrimalExtender.html#13fc586276e23d575b935dbfe12495c0" title="called by ConicBundle to update internal PrimalData objects, has to return 0 on success...">PrimalExtender::extend</a> on each of these, afterwards <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual...">ConicBundle</a> deletes primal_extender If this is not needed, the variable holds 0.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0, all correct</li><li>!=0, failure. This does not necessarily terminate the bundle method. Termination is forced only if no new subgradient is returned. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="872c680d1d9247262b6fb65a91695210"></a><!-- doxytag: member="ConicBundle::FunctionOracle::subgradient_extension" ref="872c680d1d9247262b6fb65a91695210" args="(const PrimalData *, const IVector &amp;, DVector &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ConicBundle::FunctionOracle::subgradient_extension           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__cxxinterface.html#g2ba782d3f05e6d9a1964638a6b97a390">IVector</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cxxinterface.html#gda58ad89c25718a894f1399f7c061f0b">DVector</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine is need not be implemented unless variables (constraints in Lagrangean relaxation) are added on the fly. 
<p>
The solver calls this routine whenever new variables have been added on the fly in order to extend old subgradients to the new coordinates. If primal data was supplied for the subgradients then <em>generating_primal</em> holds a pointer to this (possibly aggregated) data, otherwise it is NULL.<p>
In the presence of primal data, the new coordinates correspond to the violation of the new primal constraints. These have to be returned in <em>new_subgradient_values</em>; more precisely, for i=0 to <em>varialb_indices.size()-1</em> the element <em>new_subgradient_values</em>[i] has to hold the subgradient information of constraint <em>variable_indices</em>[i];<p>
If generating_primal is NULL, then the routine can only successfully extend the subgradients, if the new coordinates have no influence on the function; then the new subgradient coordinates are all zero and the components of <em>new_subgradient_values</em> have to be initialized to zero.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>generating_primal</em>&nbsp;</td><td>(const PrimalData*, may be NULL) If not Null it holds the (possibly aggregated) primal solution that generated the subgradient that needs to be extendend</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>variable_indices</em>&nbsp;</td><td>(const IVector&amp;) for the variables with indices in <em>variable_indices</em>[i], the subgradient coefficient has to be computed</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>new_subgradient_values</em>&nbsp;</td><td>(DVector &amp;) store the the subgradient coefficient of the variable with index <em>variable_indices</em>[i] at <em>new_subgradient_values</em>[i] for all i.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success,</li><li>1 if extension is impossible </li></ul>
</dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="CBSolver_8hxx-source.html">CBSolver.hxx</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue May 3 16:52:54 2011 for ConicBundle by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
