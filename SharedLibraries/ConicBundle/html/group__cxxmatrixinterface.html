<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ConicBundle: Interface to ConicBundle for the Language C++ using Matrix Classes</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Interface to ConicBundle for the Language C++ using Matrix Classes</h1>Solve <img class="formulaInl" alt="$min_{y\in\mathbf{R}^m} f_0(y) + f_1(y) + ... + f_k(y)$" src="form_5.png"> for convex functions f_i, the y-variables may be bounded or box constrained. The most important steps are explained here.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1PrimalMatrix.html">ConicBundle::PrimalMatrix</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If in Lagrangean relaxation primal solutions are in the form of a real vector or, more generally a matrix, then an approximate primal solution can be generated by supplying primal information of this form for each epsilon subgradient within <a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html#82f162cf954f1a4be6a70ffc9a807cf0" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient...">ConicBundle::MatrixFunctionOracle::evaluate()</a>.  <a href="classConicBundle_1_1PrimalMatrix.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html">ConicBundle::MatrixFunctionOracle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Oracle interface (abstract class). For each of your functions, provide an instance of a derived class.  <a href="classConicBundle_1_1MatrixFunctionOracle.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html">ConicBundle::MatrixCBSolver</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bundle method solver.  <a href="classConicBundle_1_1MatrixCBSolver.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixBSolver.html">ConicBundle::MatrixBSolver</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the common abstract Matrix Class interface to the two real solvers <a class="el" href="classConicBundle_1_1MatrixFCBSolver.html" title="The Full Conic Bundle method solver invoked by ConicBundle::MatrixCBSolver(), it...">ConicBundle::MatrixFCBSolver</a> and <a class="el" href="classConicBundle_1_1MatrixNBSolver.html" title="The minimal bundle method solver invoked by ConicBundle::MatrixCBSolver(true), it...">ConicBundle::MatrixNBSolver</a>.  <a href="classConicBundle_1_1MatrixBSolver.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixFCBSolver.html">ConicBundle::MatrixFCBSolver</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Full Conic Bundle method solver invoked by ConicBundle::MatrixCBSolver(), it uses a separate cutting model for each function.  <a href="classConicBundle_1_1MatrixFCBSolver.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixNBSolver.html">ConicBundle::MatrixNBSolver</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The minimal bundle method solver invoked by ConicBundle::MatrixCBSolver(true), it uses no bundle but only one aggregate and one new subgradient.  <a href="classConicBundle_1_1MatrixNBSolver.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Solve <img class="formulaInl" alt="$min_{y\in\mathbf{R}^m} f_0(y) + f_1(y) + ... + f_k(y)$" src="form_5.png"> for convex functions f_i, the y-variables may be bounded or box constrained. The most important steps are explained here. 
<p>
Before starting, note that this interface relies on several classes defined in <a class="el" href="namespaceCH__Matrix__Classes.html" title="Matrix Classes and Linear Algebra. See Matrix Classes (namespace CH_Matrix_Classes)...">CH_Matrix_Classes</a>, in particular on <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real">CH_Matrix_Classes::Matrix</a> and <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html" title="Matrix class for integral values of type Integer">CH_Matrix_Classes::Indexmatrix</a>. The full functionality of <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual...">ConicBundle</a> is only available with these classes. If you prefer an interface without having to use these, please use the <a class="el" href="group__cxxinterface.html">Interface to ConicBundle for the Language C++</a>. We now give a short overview of the most important steps in using the <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual...">ConicBundle</a> solver.<p>
<b>Setting up the Problem, the Functions, and the Main Loop</b><p>
First create a new problem/solver <a class="el" href="classConicBundle_1_1MatrixCBSolver.html" title="Bundle method solver.">ConicBundle::MatrixCBSolver</a>, let us call it solver for brevity. In invoking the constructor a boolean flag may be set to enforce the use of a minimal bundle model that employs only one common aggregate and one common subgradient for all functions, so basically "no bundle", which may be favorable if fast iterations and/or little memory consumption are essential.<p>
Next, set the dimension of the design variables/argument as well as possible box constraints on these by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d595a3623c88f175aae7ce215df9712e" title="Initializes the problem by setting up the design space (the dimension and possible...">ConicBundle::MatrixCBSolver::init_problem()</a>.<p>
Now set up each of your functions f_i as a <a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html" title="Oracle interface (abstract class). For each of your functions, provide an instance...">ConicBundle::MatrixFunctionOracle</a>. Via the routine <a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html#82f162cf954f1a4be6a70ffc9a807cf0" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient...">ConicBundle::MatrixFunctionOracle::evaluate()</a> you will supply, for a given argument, the function value and a subgradient (=the gradient if the function is differentiable) to the solver. The function evaluate() is the only function that you definitely have to provide, see the miniature example below.<p>
The function oracles have to be added to the solver using the routine <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#53b7500a47bd2f864092a73890c4db2c" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions...">ConicBundle::MatrixCBSolver::add_function()</a>.<p>
Once all functions are added, the optimization process can be started. If you know a good starting point then set it with <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#c7f0864cfbc01e3f9c057234069423ba" title="Set the starting point/center that will be used in the next call to do_descent_step()...">ConicBundle::MatrixCBSolver::set_new_center_point()</a> now, otherwise the method will pick the zero vector or, in the case of box constraints, the point closest to zero as starting point.<p>
Finally, set up a loop that calls <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d2505f56a41772470feac50f99524fd2" title="Does a descent step for the current center point.">ConicBundle::MatrixCBSolver::do_descent_step()</a> until <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#7d7589913e95675f4bee916eb3531270" title="Returns the termination code of the bundle algorithm for the latest descent step...">ConicBundle::MatrixCBSolver::termination_code()</a> is nonzero.<p>
<b>Retrieving Some Solution Information</b><p>
After the first call to <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d2505f56a41772470feac50f99524fd2" title="Does a descent step for the current center point.">ConicBundle::MatrixCBSolver::do_descent_step()</a> you can retrieve, at any time, the current objective value by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ff2f74dee0784d36bca81c75026cca59" title="Returns the objective value resulting from last descent step (initially undefined)...">ConicBundle::MatrixCBSolver::get_objval()</a> and the argument leading to this value by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#db2eb21b8701e5d27e59c1500e3db198" title="Returns the next center point that was produced by the latest call to do_descent_step...">ConicBundle::MatrixCBSolver::get_center()</a>. For some screen output, use <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#370c6ee0dd593962cbb39927a56d6bce" title="Specifies the output level (out==NULL: no output at all, out!=NULL and level=0: errors...">ConicBundle::MatrixCBSolver::set_out()</a>.<p>
<b>Lagrangean Relaxation, Primal Approximations, and Cutting Planes</b><p>
If you are optimizing the Lagrange multipliers of a Lagrangean relaxation, you might be interested in getting an approximation to your primal optimal solution. This can be done by specifying in each function for each (epsilon) subgradient the corresponding primal vectors that generate it, see the parameter primal_solutions in <a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html#82f162cf954f1a4be6a70ffc9a807cf0" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient...">ConicBundle::MatrixFunctionOracle::evaluate()</a> as a start. Then for each of your functions, you can retrieve the current primal approximation using <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#c34013129a601d786d0001c0b30dfa12" title="returns the current approximate primal solution corresponding to the aggregate subgradient...">ConicBundle::MatrixCBSolver::get_approximate_primal()</a>.<p>
If, in addition, you plan to improve your primal relaxation via cutting planes, that are strongly violated by the current primal approximation, you should have a look at <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#97b26d313821ba567be9f4aa14c289fb" title="Append new variables (always in last postions in this order).">ConicBundle::MatrixCBSolver::append_variables()</a>, <a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html#4aad0a0a4cf52c0cce522ff0eb6bf28b" title="This routine is need not be implemented unless variables (constraints in Lagrangean...">ConicBundle::MatrixFunctionOracle::subgradient_extension()</a> and <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#2aec82a3e11a2789caa085c6d99c1a4d" title="Clears cutting model, subgradients and stored function values for the specified function...">ConicBundle::MatrixCBSolver::reinit_function_model()</a>. If you want to get rid of primal constraints/dual variables, use <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#75386771ea08d4026d06640d79446dec" title="Returns the multipliers for the box constraints on the design variables; in Lagrangean...">ConicBundle::MatrixCBSolver::get_approximate_slacks()</a> and <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#c1cdd25a701c8832e0ab7adabf482435" title="Deletes variables corresponding to the specified indices.">ConicBundle::MatrixCBSolver::delete_variables()</a>.<p>
<div class="fragment"><pre class="fragment"><span class="comment">//******************************************************************************</span>
<span class="comment">//*       Miniature Example in C++ for Convex Quadratic in Two Variables       * </span>
<span class="comment">//******************************************************************************</span>
<span class="preprocessor">#include "<a class="code" href="MatCBSolver_8hxx.html" title="Header declaring the classes ConicBundle::MatrixCBSolver, ConicBundle::MatrixFunctionOracle...">MatCBSolver.hxx</a>"</span>

<span class="keyword">using namespace </span>std;
<span class="keyword">using namespace </span>ConicBundle;
<span class="keyword">using namespace </span>CH_Matrix_Classes;

<span class="comment">// f(x)=x^TAx+b^Tx+c with A=[5 1;1 4], b=[-12;-10], c=3 </span>
<span class="keyword">class </span>QFunction: <span class="keyword">public</span> MatrixFunctionOracle
{
  Matrix A,b;
  <span class="keywordtype">double</span> c;

<span class="keyword">public</span>:
  QFunction()
  {
    A.init(2,2,0.);  A(0,0) = 5;  A(1,1) = 4;  A(0,1) = A(1,0) = 1.;
    b.init(2,1,0.);  b(0) = -12;  b(1) = -10;
    c=3;
  }

  <span class="keywordtype">int</span> evaluate(<span class="keyword">const</span> Matrix&amp; x, <span class="keywordtype">double</span> relprec, 
               <span class="keywordtype">double</span>&amp; objective_value,
               Matrix&amp;  cut_vals,Matrix&amp;  subgradients,
               vector&lt;PrimalData*&gt;&amp;  primal_solutions,
               PrimalExtender*&amp;)
  {
    <span class="comment">/* compute objective as inner product of x with A*x+b plus c */</span>
    objective_value= ip(x,A*x+b)+c;
    <span class="comment">/* compute and store one subgradient(=gradient) with two coordinates */</span>
    cut_vals.init(1,1,objective_value);
    subgradients=2.*A*x+b;
    <span class="keywordflow">return</span> 0;
  }
};

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
  QFunction fun;

  MatrixCBSolver solver; 
  solver.init_problem(2);        <span class="comment">// 2 variables, no bounds</span>
  solver.add_function(fun);      
  solver.set_out(&amp;cout,1);
 
  <span class="keywordflow">do</span> {
    solver.do_descent_step();
  } <span class="keywordflow">while</span> (!solver.termination_code());

  solver.print_termination_code(cout);

  cout&lt;&lt;<span class="stringliteral">" objval="</span>&lt;&lt;solver.get_objval()&lt;&lt;<span class="stringliteral">"\n optimizer: "</span>;
  Matrix x;
  solver.get_center(x);
  x.display(cout);

  <span class="keywordflow">return</span> 0;
}
</pre></div> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue May 3 16:52:54 2011 for ConicBundle by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
