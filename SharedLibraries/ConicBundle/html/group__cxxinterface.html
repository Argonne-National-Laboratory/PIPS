<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ConicBundle: Interface to ConicBundle for the Language C++</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Interface to ConicBundle for the Language C++</h1>Solve <img class="formulaInl" alt="$min_{y\in\mathbf{R}^m} f_0(y) + f_1(y) + ... + f_k(y)$" src="form_5.png"> for convex functions f_i, the y-variables may be bounded or box constrained. The most important steps are explained here.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1PrimalData.html">ConicBundle::PrimalData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In Lagrangean relaxation an approximate primal solution can be generated by supplying primal information derived from this abstract class for each epsilon subgradient within <a class="el" href="classConicBundle_1_1FunctionOracle.html#62bbdbf390aa0a1c4a9cc983c74c9bf8" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient...">ConicBundle::FunctionOracle::evaluate()</a>.  <a href="classConicBundle_1_1PrimalData.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1PrimalExtender.html">ConicBundle::PrimalExtender</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface for extending <a class="el" href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying...">PrimalData</a>, e.g., in column generation approaches.  <a href="classConicBundle_1_1PrimalExtender.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1PrimalDVector.html">ConicBundle::PrimalDVector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If in Lagrangean relaxation primal solutions are in the form of a <a class="el" href="group__cxxinterface.html#gda58ad89c25718a894f1399f7c061f0b" title="A dense vector of double, arguments and subgradients are specified like this.">ConicBundle::DVector</a>, then an approximate primal solution can be generated by supplying primal information of this form for each epsilon subgradient within <a class="el" href="classConicBundle_1_1FunctionOracle.html#62bbdbf390aa0a1c4a9cc983c74c9bf8" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient...">ConicBundle::FunctionOracle::evaluate()</a>.  <a href="classConicBundle_1_1PrimalDVector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1FunctionObject.html">ConicBundle::FunctionObject</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">basic function object (abstract class). It serves for using the same interface on distinct oracle types, but is not yet needed in the standard C++ interface.  <a href="classConicBundle_1_1FunctionObject.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1FunctionOracle.html">ConicBundle::FunctionOracle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">oracle interface (abstract class). For each of your functions, provide a derived class.  <a href="classConicBundle_1_1FunctionOracle.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1BundleParameters.html">ConicBundle::BundleParameters</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serves for specifying parameters regarding the construction of the cutting model.  <a href="classConicBundle_1_1BundleParameters.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1CBSolver.html">ConicBundle::CBSolver</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bundle method solver.  <a href="classConicBundle_1_1CBSolver.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gda58ad89c25718a894f1399f7c061f0b"></a><!-- doxytag: member="cxxinterface::DVector" ref="gda58ad89c25718a894f1399f7c061f0b" args="" -->
typedef std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxxinterface.html#gda58ad89c25718a894f1399f7c061f0b">ConicBundle::DVector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A dense vector of double, arguments and subgradients are specified like this. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g2ba782d3f05e6d9a1964638a6b97a390"></a><!-- doxytag: member="cxxinterface::IVector" ref="g2ba782d3f05e6d9a1964638a6b97a390" args="" -->
typedef std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxxinterface.html#g2ba782d3f05e6d9a1964638a6b97a390">ConicBundle::IVector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A dense vector of int, index vectors for deleting/reorganizing variables are specified like this. <br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g15948e7611155f822fc0331bcbb4a111"></a><!-- doxytag: member="cxxinterface::CB_plus_infinity" ref="g15948e7611155f822fc0331bcbb4a111" args="" -->
const double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxxinterface.html#g15948e7611155f822fc0331bcbb4a111">ConicBundle::CB_plus_infinity</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">serves as the value "minus infinity", i.e., all bounds &lt;= this value are set to this value and are regarded as minus infinity <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge58492af3631a196b0edb8a8ebcda567"></a><!-- doxytag: member="cxxinterface::CB_minus_infinity" ref="ge58492af3631a196b0edb8a8ebcda567" args="" -->
const double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cxxinterface.html#ge58492af3631a196b0edb8a8ebcda567">ConicBundle::CB_minus_infinity</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">serves as the value "plus infinity", i.e., all bounds &gt;= this value are set to this value and are regarded as plus infinity <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Solve <img class="formulaInl" alt="$min_{y\in\mathbf{R}^m} f_0(y) + f_1(y) + ... + f_k(y)$" src="form_5.png"> for convex functions f_i, the y-variables may be bounded or box constrained. The most important steps are explained here. 
<p>
<b>Setting up the Problem, the Functions, and the Main Loop</b><p>
First create a new problem/solver <a class="el" href="classConicBundle_1_1CBSolver.html" title="Bundle method solver.">ConicBundle::CBSolver</a>, let us call it solver for brevity. In invoking the constructor a boolean flag may be set to enforce the use of a minimal bundle model that employs only one common aggregate and one common subgradient for all functions, so basically "no bundle", which may be favorable if fast iterations and/or little memory consumption are essential.<p>
Next, set the dimension of the design variables/argument as well as possible box constraints on these by <a class="el" href="classConicBundle_1_1CBSolver.html#aaca3b1092a1305a8ddf4f181e1bf256" title="Initializes the problem by setting up the design space (the dimension and possible...">ConicBundle::CBSolver::init_problem()</a>.<p>
Now set up each of your functions f_i as a <a class="el" href="classConicBundle_1_1FunctionOracle.html" title="oracle interface (abstract class). For each of your functions, provide a derived...">ConicBundle::FunctionOracle</a>. Via the routine <a class="el" href="classConicBundle_1_1FunctionOracle.html#62bbdbf390aa0a1c4a9cc983c74c9bf8" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient...">ConicBundle::FunctionOracle::evaluate()</a> you will supply, for a given argument, the function value and a subgradient (=the gradient if the function is differentiable) to the solver. The function evaluate() is the only function that you definitely have to provide, see the miniature example below.<p>
The function oracles have to be added to the solver using the routine <a class="el" href="classConicBundle_1_1CBSolver.html#76de315bec233bec71b1cf9d2ed3df69" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions...">ConicBundle::CBSolver::add_function()</a>.<p>
Once all functions are added, the optimization process can be started. If you know a good starting point then set it with <a class="el" href="classConicBundle_1_1CBSolver.html#8cf0a95dcbfdf10293a79f47af80b407" title="Set the starting point/center that will be used in the next call to do_descent_step()...">ConicBundle::CBSolver::set_new_center_point()</a> now, otherwise the method will pick the zero vector or, in the case of box constraints, the point closest to zero as starting point.<p>
Finally, set up a loop that calls <a class="el" href="classConicBundle_1_1CBSolver.html#caeab93175dea9a595c5348f5b6ab368" title="Does a descent step for the current center point.">ConicBundle::CBSolver::do_descent_step()</a> until <a class="el" href="classConicBundle_1_1CBSolver.html#3840a120cec8ae9db703c872b3d04c05" title="Returns the termination code of the bundle algorithm for the latest descent step...">ConicBundle::CBSolver::termination_code()</a> is nonzero.<p>
<b>Setting up the Problem, the Functions, and the Main Loop</b><p>
After the first call to <a class="el" href="classConicBundle_1_1CBSolver.html#caeab93175dea9a595c5348f5b6ab368" title="Does a descent step for the current center point.">ConicBundle::CBSolver::do_descent_step()</a> you can retrieve, at any time, the current objective value by <a class="el" href="classConicBundle_1_1CBSolver.html#9b868e6e5bb861b6ba5c2e59724088b5" title="Returns the objective value resulting from last descent step (initially undefined)...">ConicBundle::CBSolver::get_objval()</a> and the argument leading to this value by <a class="el" href="classConicBundle_1_1CBSolver.html#9495518a6f0021ab561dc5305935ef36" title="Returns the next center point that was produced by the latest call to do_descent_step...">ConicBundle::CBSolver::get_center()</a>. For some screen output, use <a class="el" href="classConicBundle_1_1CBSolver.html#51a582190b7e9d8863ae1e5ff8a0779e" title="Specifies the output level (out==NULL: no output at all, out!=NULL and level=0: errors...">ConicBundle::CBSolver::set_out()</a>.<p>
<b>Lagrangean Relaxation, Primal Approximations, and Cutting Planes</b><p>
If you are optimizing the Lagrange multipliers of a Lagrangean relaxation, you might be interested in getting an approximation to your primal optimal solution. This can be done by specifying in each function for each (epsilon) subgradient the corresponding primal vectors that generate it, see the parameter primal_solutions in <a class="el" href="classConicBundle_1_1FunctionOracle.html#62bbdbf390aa0a1c4a9cc983c74c9bf8" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient...">ConicBundle::FunctionOracle::evaluate()</a> as a start. Then for each of your functions, you can retrieve the current primal approximation using <a class="el" href="classConicBundle_1_1CBSolver.html#80d49e1d0c6d26b5ca896b584502f355" title="returns the current approximate primal solution corresponding to the aggregate subgradient...">ConicBundle::CBSolver::get_approximate_primal()</a>.<p>
If, in addition, you plan to improve your primal relaxation via cutting planes, that are strongly violated by the current primal approximation, you should have a look at <a class="el" href="classConicBundle_1_1CBSolver.html#967e2643744ed0cedd2629e289032d7d" title="Append new variables (always in last postions in this order).">ConicBundle::CBSolver::append_variables()</a>, <a class="el" href="classConicBundle_1_1FunctionOracle.html#872c680d1d9247262b6fb65a91695210" title="This routine is need not be implemented unless variables (constraints in Lagrangean...">ConicBundle::FunctionOracle::subgradient_extension()</a> and <a class="el" href="classConicBundle_1_1CBSolver.html#6375a055ccfa09179068674683c9f25c" title="Clears cutting model, subgradients and stored function values for the specified function...">ConicBundle::CBSolver::reinit_function_model()</a>. If you want to get rid of primal constraints/dual variables, use <a class="el" href="classConicBundle_1_1CBSolver.html#274fc7a5e2272dae918f626a9db8006f" title="Returns the multipliers for the box constraints on the design variables; in Lagrangean...">ConicBundle::CBSolver::get_approximate_slacks()</a> and <a class="el" href="classConicBundle_1_1CBSolver.html#e4162fe243fd3550c18f73730dc6ca80" title="Deletes variables corresponding to the specified indices.">ConicBundle::CBSolver::delete_variables()</a>.<p>
<div class="fragment"><pre class="fragment"><span class="comment">//******************************************************************************</span>
<span class="comment">//*       Miniature Example in C++ for Convex Quadratic in Two Variables       * </span>
<span class="comment">//******************************************************************************</span>
<span class="preprocessor">#include "<a class="code" href="CBSolver_8hxx.html" title="Header declaring the classes ConicBundle::CBSolver, ConicBundle::FunctionOracle and...">CBSolver.hxx</a>"</span>

<span class="keyword">using namespace </span>std;
<span class="keyword">using namespace </span>ConicBundle;

<span class="comment">// f(x)=x^TAx+b^Tx+c with A=[5 1;1 4], b=[-12;-10], c=3 </span>
<span class="keyword">class </span>QFunction: <span class="keyword">public</span> FunctionOracle
{
<span class="keyword">public</span>:
  QFunction(){}

  <span class="keywordtype">int</span> evaluate(<span class="keyword">const</span> <a class="code" href="group__cxxinterface.html#gda58ad89c25718a894f1399f7c061f0b" title="A dense vector of double, arguments and subgradients are specified like this.">DVector</a>&amp; x, <span class="keywordtype">double</span> relprec, 
               <span class="keywordtype">double</span>&amp; objective_value,
               <a class="code" href="group__cxxinterface.html#gda58ad89c25718a894f1399f7c061f0b" title="A dense vector of double, arguments and subgradients are specified like this.">DVector</a>&amp;  cut_vals,vector&lt;DVector&gt;&amp;  subgradients,
               vector&lt;PrimalData*&gt;&amp;  primal_solutions,
               PrimalExtender*&amp;)
  {
    <span class="comment">/* compute objective */</span>
    objective_value= 5*x[0]*x[0]+2*x[0]*x[1]+4*x[1]*x[1]-12*x[0]-10*x[1]+3;
    <span class="comment">/* compute and store one subgradient(=gradient) with two coordinates */</span>
    cut_vals.push_back(objective_value);
    <a class="code" href="group__cxxinterface.html#gda58ad89c25718a894f1399f7c061f0b" title="A dense vector of double, arguments and subgradients are specified like this.">DVector</a> subg(2,0.);
    subg[0]=2*(5*x[0]+x[1])-12;
    subg[1]=2*(x[0]+4*x[1])-10;
    subgradients.push_back(subg);
    <span class="keywordflow">return</span> 0;
  }
};

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
  QFunction fun;

  CBSolver solver;         
  solver.init_problem(2);      <span class="comment">// 2 variables, no bounds</span>
  solver.add_function(fun);      
  solver.set_out(&amp;cout,1);
 
  <span class="keywordflow">do</span> {
    solver.do_descent_step();
  } <span class="keywordflow">while</span> (!solver.termination_code());

  solver.print_termination_code(cout);

  <a class="code" href="group__cxxinterface.html#gda58ad89c25718a894f1399f7c061f0b" title="A dense vector of double, arguments and subgradients are specified like this.">DVector</a> x;
  solver.get_center(x);
  cout&lt;&lt;<span class="stringliteral">" x[0]="</span>&lt;&lt;x[0]&lt;&lt;<span class="stringliteral">" x[1]="</span>&lt;&lt;x[1]&lt;&lt;<span class="stringliteral">" objval="</span>&lt;&lt;solver.get_objval()&lt;&lt;endl;

  <span class="keywordflow">return</span> 0;
}
</pre></div> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue May 3 16:52:54 2011 for ConicBundle by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
