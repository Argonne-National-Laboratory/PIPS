<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ConicBundle: CH_Matrix_Classes::Symmatrix Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceCH__Matrix__Classes.html">CH_Matrix_Classes</a>::<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>
  </div>
</div>
<div class="contents">
<h1>CH_Matrix_Classes::Symmatrix Class Reference<br>
<small>
[<a class="el" href="group__Symmatrixgroup.html">Symmatrix (dense, real, symmetric, n by n)</a>]</small>
</h1><!-- doxytag: class="CH_Matrix_Classes::Symmatrix" --><!-- doxytag: inherits="CH_Matrix_Classes::Memarrayuser" -->Matrix class of symmetric matrices with real values of type <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type">Real</a>  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="symmat_8hxx-source.html">symmat.hxx</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for CH_Matrix_Classes::Symmatrix:</div>
<div class="dynsection">

<p><center><img src="classCH__Matrix__Classes_1_1Symmatrix.png" usemap="#CH_Matrix_Classes::Symmatrix_map" border="0" alt=""></center>
<map name="CH_Matrix_Classes::Symmatrix_map">
<area href="classCH__Matrix__Classes_1_1Memarrayuser.html" alt="CH_Matrix_Classes::Memarrayuser" shape="rect" coords="0,0,212,24">
</map>
</div>

<p>
<a href="classCH__Matrix__Classes_1_1Symmatrix-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, Destructor, and Initialization (Members)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="77b76cc41cb98ad78dc90cfdd17e6f1c"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Symmatrix" ref="77b76cc41cb98ad78dc90cfdd17e6f1c" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#77b76cc41cb98ad78dc90cfdd17e6f1c">Symmatrix</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">empty matrix <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="95d71af384160bec3cad86aa479b838f"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Symmatrix" ref="95d71af384160bec3cad86aa479b838f" args="(const Symmatrix &amp;A, double d=1.)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#95d71af384160bec3cad86aa479b838f">Symmatrix</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, double d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy constructor, *this=d*A <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#eea95b6f59c5c5012a08088f4208601e">Symmatrix</a> (<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#081b04bbf1938d34a8bbb7031cdb6be6">nr</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate a matrix of size nr x nr but WITHOUT initializing the memory  <a href="#eea95b6f59c5c5012a08088f4208601e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="824fd11cc74b9c3b7b897b42b60ed861"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Symmatrix" ref="824fd11cc74b9c3b7b897b42b60ed861" args="(Integer nr, Real d)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#824fd11cc74b9c3b7b897b42b60ed861">Symmatrix</a> (<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#081b04bbf1938d34a8bbb7031cdb6be6">nr</a>, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate a matrix of size nr x nr initializing all elements to the value d <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3d65cd028e4fe22c50b0069599e69c4a"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Symmatrix" ref="3d65cd028e4fe22c50b0069599e69c4a" args="(Integer nr, Real *dp)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#3d65cd028e4fe22c50b0069599e69c4a">Symmatrix</a> (<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#081b04bbf1938d34a8bbb7031cdb6be6">nr</a>, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> *dp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate a matrix of size nr x nr initializing the elements from the (one dimensional) array dp, which must have the elements arranged consecutively in internal order <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="56c3e4f1dce24e7c8ed21934cf217748"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::~Symmatrix" ref="56c3e4f1dce24e7c8ed21934cf217748" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>~Symmatrix</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2ea14efca04115bfb34febd3084108ab"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::set_init" ref="2ea14efca04115bfb34febd3084108ab" args="(bool)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#2ea14efca04115bfb34febd3084108ab">set_init</a> (bool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">after external initialization, call matrix.set_init(true) (not needed if CONICBUNDLE_DEBUG is undefined) <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d9c004118fc14b5bfd8a4f74b3b74544"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::get_init" ref="d9c004118fc14b5bfd8a4f74b3b74544" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#d9c004118fc14b5bfd8a4f74b3b74544">get_init</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns true if the matrix has been declared initialized (not needed if CONICBUNDLE_DEBUG is undefined) <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="83c19c09c02b0b048a04e5831bf6e3b2"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::init" ref="83c19c09c02b0b048a04e5831bf6e3b2" args="(const Symmatrix &amp;A, double d=1.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#83c19c09c02b0b048a04e5831bf6e3b2">init</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, double d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initialize to *this=A*d <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7690f7cce71d3747e1d1958f55a379cf"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::init" ref="7690f7cce71d3747e1d1958f55a379cf" args="(const Matrix &amp;A, double d=1.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#7690f7cce71d3747e1d1958f55a379cf">init</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, double d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initialize to *this=d*(A+transpose(A))/2. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="456eabc2aa1a16b66f654ba779d9e2de"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::init" ref="456eabc2aa1a16b66f654ba779d9e2de" args="(const Indexmatrix &amp;A, double d=1.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#456eabc2aa1a16b66f654ba779d9e2de">init</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, double d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initialize to *this=d*(A+transpose(A))/2. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d303de883c26020ed2591e2f8a69a35b"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::init" ref="d303de883c26020ed2591e2f8a69a35b" args="(const Sparsesym &amp;A, Real d=1.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#d303de883c26020ed2591e2f8a69a35b">init</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initialize to *this=A*d <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3f002e510774193b59aa326625341993"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::init" ref="3f002e510774193b59aa326625341993" args="(Integer nr, Real d)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#3f002e510774193b59aa326625341993">init</a> (<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#081b04bbf1938d34a8bbb7031cdb6be6">nr</a>, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">intialize *this to a matrix of size nr x nr initializing all elements to the value d <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="626c7fbe12a611271b59122ecff09063"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::init" ref="626c7fbe12a611271b59122ecff09063" args="(Integer nr, Real *dp)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#626c7fbe12a611271b59122ecff09063">init</a> (<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#081b04bbf1938d34a8bbb7031cdb6be6">nr</a>, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> *dp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate a matrix of size nr x nc initializing the elements from the (one dimensional) array dp which must have the elements arranged consecutively in internal order <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#43e3cc5de2659fb4eb213eaca2276626">newsize</a> (<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">resize the matrix to nr x nr elements but WITHOUT initializing the memory  <a href="#43e3cc5de2659fb4eb213eaca2276626"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversions from other Matrix Classes (Members)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0cb203055486e3fed534b70fe8804349"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Symmatrix" ref="0cb203055486e3fed534b70fe8804349" args="(const Matrix &amp;, double d=1.)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#0cb203055486e3fed534b70fe8804349">Symmatrix</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;, double d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(*this)=d*(A+transpose(A))/2. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="21a67f53b1a29a1e92d5837f6acb8447"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Symmatrix" ref="21a67f53b1a29a1e92d5837f6acb8447" args="(const Indexmatrix &amp;, double d=1.)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#21a67f53b1a29a1e92d5837f6acb8447">Symmatrix</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;, double d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(*this)=d*(A+transpose(A))/2. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dd96fd2333a8d24327dca0895dc1c942"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Symmatrix" ref="dd96fd2333a8d24327dca0895dc1c942" args="(const Sparsesym &amp;A, Real d=1.)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#dd96fd2333a8d24327dca0895dc1c942">Symmatrix</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(*this)=d*A <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Size and Type Information (Members)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f2db8ebe47914639c566149233fa79c7"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::dim" ref="f2db8ebe47914639c566149233fa79c7" args="(Integer &amp;_nr, Integer &amp;_nc) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#f2db8ebe47914639c566149233fa79c7">dim</a> (<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> &amp;_nr, <a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> &amp;_nc) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the number of rows in _nr and _nc <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f10baa898e629fd9a7d3786a943d7239"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::dim" ref="f10baa898e629fd9a7d3786a943d7239" args="() const " -->
<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#f10baa898e629fd9a7d3786a943d7239">dim</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the dimension rows * columns when the matrix is regarded as a vector <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="25f9f5f6cd4d1aaad1b37b72e284044d"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::rowdim" ref="25f9f5f6cd4d1aaad1b37b72e284044d" args="() const " -->
<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#25f9f5f6cd4d1aaad1b37b72e284044d">rowdim</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the row dimension <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a47ffecb9bcd72ec0ed270408f305695"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::coldim" ref="a47ffecb9bcd72ec0ed270408f305695" args="() const " -->
<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a47ffecb9bcd72ec0ed270408f305695">coldim</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the column dimension <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ba79b87f03aed9ed58a8740fcce53afc"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::get_mtype" ref="ba79b87f03aed9ed58a8740fcce53afc" args="() const " -->
<a class="el" href="group__matop__matrixerror.html#g204f53041409b9f5efb2f8b41964b6b8">Mtype</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ba79b87f03aed9ed58a8740fcce53afc">get_mtype</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the type of the matrix, MTsymmetric <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Indexing and Submatrices (Members)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="56cd70cbe8966417a95cb24db5c037bf"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator()" ref="56cd70cbe8966417a95cb24db5c037bf" args="(Integer i, Integer j)" -->
<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#56cd70cbe8966417a95cb24db5c037bf">operator()</a> (<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> i, <a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> j)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns reference to element (i,j) of the matrix (rowindex i, columnindex j) <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fde9b4fc98a928c2bff72988512d0c41"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator()" ref="fde9b4fc98a928c2bff72988512d0c41" args="(Integer i)" -->
<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#fde9b4fc98a928c2bff72988512d0c41">operator()</a> (<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns reference to element (i) of the matrix if regarded as vector of stacked columns [element (irowdim, i/rowdim)] <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5bfffd9ee9450f593b62051aff07e65e"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator()" ref="5bfffd9ee9450f593b62051aff07e65e" args="(Integer i, Integer j) const " -->
<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#5bfffd9ee9450f593b62051aff07e65e">operator()</a> (<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> i, <a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> j) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns value of element (i,j) of the matrix (rowindex i, columnindex j) <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4ced8eec682efb7c360e24282274dd05"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator()" ref="4ced8eec682efb7c360e24282274dd05" args="(Integer i) const " -->
<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#4ced8eec682efb7c360e24282274dd05">operator()</a> (<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns value of element (i) of the matrix if regarded as vector of stacked columns [element (irowdim, i/rowdim)] <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9b7c71e90bf10819f3c288498af5af57"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::col" ref="9b7c71e90bf10819f3c288498af5af57" args="(Integer i) const " -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#9b7c71e90bf10819f3c288498af5af57">col</a> (<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns column i copied to a new <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html" title="Matrix class for real values of type Real">Matrix</a> <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="647abe63e1994aad81a6e42a3975bcbe"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::row" ref="647abe63e1994aad81a6e42a3975bcbe" args="(Integer i) const " -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#647abe63e1994aad81a6e42a3975bcbe">row</a> (<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns row i copied to a new ;atrix <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c7f4f625633b10abab2212a70a4e9380"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::get_store" ref="c7f4f625633b10abab2212a70a4e9380" args="()" -->
<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#c7f4f625633b10abab2212a70a4e9380">get_store</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the current address of the internal value array; use cautiously, do not use delete! <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e9bdbdc6bea65af19d0feae76bdc619"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::get_store" ref="1e9bdbdc6bea65af19d0feae76bdc619" args="() const " -->
const <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#1e9bdbdc6bea65af19d0feae76bdc619">get_store</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the current address of the internal value array; use cautiously! <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">BLAS-like Routines (Members)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9165e0218fd158ce056bc70415701fbc"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::xeya" ref="9165e0218fd158ce056bc70415701fbc" args="(const Symmatrix &amp;A, Real d=1.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#9165e0218fd158ce056bc70415701fbc">xeya</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets *this=d*A and returns *this <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0043ad0e3d5fee1827aa27783509c3f9"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::xpeya" ref="0043ad0e3d5fee1827aa27783509c3f9" args="(const Symmatrix &amp;A, Real d=1.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#0043ad0e3d5fee1827aa27783509c3f9">xpeya</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets *this+=d*A and returns *this <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Usual Arithmetic Operators (Members)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8a902c276d40121c0c9fc0d391ecacc3"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator=" ref="8a902c276d40121c0c9fc0d391ecacc3" args="(const Symmatrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="890f8623bf0c18dc1871d00a20d18dbe"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator+=" ref="890f8623bf0c18dc1871d00a20d18dbe" args="(const Symmatrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9810ccd2abfc469cd87edeb10e2f59df"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator-=" ref="9810ccd2abfc469cd87edeb10e2f59df" args="(const Symmatrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5a0a0248a4bb0eda3a0b004c28527a4"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator%=" ref="a5a0a0248a4bb0eda3a0b004c28527a4" args="(const Symmatrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a5a0a0248a4bb0eda3a0b004c28527a4">operator%=</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ATTENTION: this is redefined as the Hadamard product, (*this)(i,j)=(*this)(i,j)*A(i,j) for all i&lt;=j. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bc5ba3b6c199b0d7f60480875551ca5d"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator-" ref="bc5ba3b6c199b0d7f60480875551ca5d" args="() const " -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e13d0c45c18ffe8a9711a428a4b6099e"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator*=" ref="e13d0c45c18ffe8a9711a428a4b6099e" args="(Real d)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0550a9d8b0e225a1cf4152444249fd73"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator/=" ref="0550a9d8b0e225a1cf4152444249fd73" args="(Real d)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#0550a9d8b0e225a1cf4152444249fd73">operator/=</a> (<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ATTENTION: d is NOT checked for 0. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="16cc2f7b715f643ae94f2a59ddd8b757"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator+=" ref="16cc2f7b715f643ae94f2a59ddd8b757" args="(Real d)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#16cc2f7b715f643ae94f2a59ddd8b757">operator+=</a> (<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets (*this)(i,j)+=d for all i&lt;=j <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f2a7b26374103749f4578e4aab7ae94d"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator-=" ref="f2a7b26374103749f4578e4aab7ae94d" args="(Real d)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#f2a7b26374103749f4578e4aab7ae94d">operator-=</a> (<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets (*this)(i,j)-=d for all i&lt;=j <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b4c30091f07177dd6d52986e46759d2e"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::transpose" ref="b4c30091f07177dd6d52986e46759d2e" args="()" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#b4c30091f07177dd6d52986e46759d2e">transpose</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">transposes itself (at almost no cost) <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Connections to other Classes (Members)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5f3a0411121fac1e93e58680abc6ff83"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::xeya" ref="5f3a0411121fac1e93e58680abc6ff83" args="(const Matrix &amp;A, Real d=1.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#5f3a0411121fac1e93e58680abc6ff83">xeya</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets *this=d*(A+transpose(A))/2. and returns *this <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="452068cbd3239e4f2bb18574e3a648bd"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::xpeya" ref="452068cbd3239e4f2bb18574e3a648bd" args="(const Matrix &amp;A, Real d=1.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#452068cbd3239e4f2bb18574e3a648bd">xpeya</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets *this+=d*(A+transpose(A))/2. and returns *this <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e1be980387ba376eeab4af296392961a"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::xeya" ref="e1be980387ba376eeab4af296392961a" args="(const Indexmatrix &amp;A, Real d=1.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#e1be980387ba376eeab4af296392961a">xeya</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets *this=d*(A+transpose(A))/2. and returns *this <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a404990d1a84004057d84e89496d824d"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::xpeya" ref="a404990d1a84004057d84e89496d824d" args="(const Indexmatrix &amp;A, Real d=1.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a404990d1a84004057d84e89496d824d">xpeya</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets *this+=d*(A+transpose(A))/2. and returns *this <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6565a29bfce684469c0e6246645bffaa"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::xeya" ref="6565a29bfce684469c0e6246645bffaa" args="(const Sparsesym &amp;A, Real d=1.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#6565a29bfce684469c0e6246645bffaa">xeya</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets *this=d*A and returns *this <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="640bf84db5afdd40720721c4de56c6a3"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::xpeya" ref="640bf84db5afdd40720721c4de56c6a3" args="(const Sparsesym &amp;A, Real d=1.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#640bf84db5afdd40720721c4de56c6a3">xpeya</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets *this+=d*A and returns *this <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e73886a1f2878f24478a4c5e0c7c80a1"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::xetriu_yza" ref="e73886a1f2878f24478a4c5e0c7c80a1" args="(const Matrix &amp;A, const Matrix &amp;B, Real d=1.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#e73886a1f2878f24478a4c5e0c7c80a1">xetriu_yza</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets *this(i,j), i&lt;=j to the upper triangle of the matrix product d*transpose(A)*B <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e8d8b58a0a5e3afb2bee72d6d1ea58ca"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::xpetriu_yza" ref="e8d8b58a0a5e3afb2bee72d6d1ea58ca" args="(const Matrix &amp;A, const Matrix &amp;B, Real d=1.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#e8d8b58a0a5e3afb2bee72d6d1ea58ca">xpetriu_yza</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">adds to *this(i,j), i&lt;=j the upper triangle of the matrix product d*transpose(A)*B <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="29d413776c154f0c74f628f2f962f8f1"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::xetriu_yza" ref="29d413776c154f0c74f628f2f962f8f1" args="(const Sparsemat &amp;A, const Matrix &amp;B, Real d=1.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#29d413776c154f0c74f628f2f962f8f1">xetriu_yza</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets *this(i,j), i&lt;=j to the upper triangle of the matrix product d*transpose(A)*B <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fd0798001c62a2c3721d106e8788c14d"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::xpetriu_yza" ref="fd0798001c62a2c3721d106e8788c14d" args="(const Sparsemat &amp;A, const Matrix &amp;B, Real d=1.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#fd0798001c62a2c3721d106e8788c14d">xpetriu_yza</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">adds to *this(i,j), i&lt;=j the upper triangle of the matrix product d*transpose(A)*B <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="285510a5d10138bba716f5bd26ebcf69"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator=" ref="285510a5d10138bba716f5bd26ebcf69" args="(const Sparsesym &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d8c9518db11e830e6de0acaa930bd88b"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator+=" ref="d8c9518db11e830e6de0acaa930bd88b" args="(const Sparsesym &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="06cf72d53c1975f4f1d4328cbf8d48b4"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator-=" ref="06cf72d53c1975f4f1d4328cbf8d48b4" args="(const Sparsesym &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsesym.html">Sparsesym</a> &amp;A)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Numerical Methods (Members)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="def3ef237566222b10a915ec9844b4be"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::shift_diag" ref="def3ef237566222b10a915ec9844b4be" args="(Real s)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#def3ef237566222b10a915ec9844b4be">shift_diag</a> (<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">shifts the diagonal by s, i.e., (*this)(i,i)+=s for all i <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3a593f9d762471bb12e35fa45c861a0e"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::LDLfactor" ref="3a593f9d762471bb12e35fa45c861a0e" args="(Real tol=1e-10)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#3a593f9d762471bb12e35fa45c861a0e">LDLfactor</a> (<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> tol=1e-10)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes LDLfactorization (implemented only for positive definite matrices so far, no pivoting), (*this) is overwritten by the factorization; returns 1 if diagonal elements go below tol <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="352826057e4813ee5c06cb9fad1e176a"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::LDLsolve" ref="352826057e4813ee5c06cb9fad1e176a" args="(Matrix &amp;x) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#352826057e4813ee5c06cb9fad1e176a">LDLsolve</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes, after LDLfactor was executed succesfully, the solution to (*old_this)x=rhs; rhs is overwritten by the solution; always returns 0; NOTE: there is NO check against division by zero <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="01ba474995296d6300db176ad3fd0eb8"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::LDLinverse" ref="01ba474995296d6300db176ad3fd0eb8" args="(Symmatrix &amp;S) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#01ba474995296d6300db176ad3fd0eb8">LDLinverse</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;S) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes, after LDLfactor was executed succesfully, the inverse to (*old_this) and stores it in S (numerically not too wise); always returns 0; NOTE: there is NO check against division by zero <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b92dd5fe3e0e7555b770c44a527360cf"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Chol_factor" ref="b92dd5fe3e0e7555b770c44a527360cf" args="(Real tol=1e-10)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#b92dd5fe3e0e7555b770c44a527360cf">Chol_factor</a> (<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> tol=1e-10)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes the Cholesky factorization, for positive definite matrices only, (*this) is overwritten by the factorization; there is no pivoting; returns 1 if diagonal elements go below tol <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cd9aa3269c6319008d609d76410abcd2"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Chol_solve" ref="cd9aa3269c6319008d609d76410abcd2" args="(Matrix &amp;x) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#cd9aa3269c6319008d609d76410abcd2">Chol_solve</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes, after Chol_factor was executed succesfully, the solution to (*old_this)x=rhs; rhs is overwritten by the solution; always returns 0; NOTE: there is NO check against division by zero <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="37794e5fc083633afdfcf7985b3bb0be"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Chol_inverse" ref="37794e5fc083633afdfcf7985b3bb0be" args="(Symmatrix &amp;S) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#37794e5fc083633afdfcf7985b3bb0be">Chol_inverse</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;S) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes, after Chol_factor was executed succesfully, the inverse to (*old_this) and stores it in S (numerically not too wise); always returns 0; NOTE: there is NO check against division by zero <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b06f192f410fb371bb3b304508abe4ed"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Chol_Lsolve" ref="b06f192f410fb371bb3b304508abe4ed" args="(Matrix &amp;rhs) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#b06f192f410fb371bb3b304508abe4ed">Chol_Lsolve</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes, after Chol_factor into LL^T was executed succesfully, the solution to Lx=rhs; rhs is overwritten by the solution; always returns 0; NOTE: there is NO check against division by zero <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="46907da6a0fc0e4ab20967cc16e6c954"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Chol_scaleLi" ref="46907da6a0fc0e4ab20967cc16e6c954" args="(Symmatrix &amp;S) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#46907da6a0fc0e4ab20967cc16e6c954">Chol_scaleLi</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;S) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes, after Chol_factor into LL^T was executed succesfully, L^{-1}SL^{-T} overwriting S <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="90c7aa10f5cc0bfa6542461c7c8e2a93"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Chol_Ltmult" ref="90c7aa10f5cc0bfa6542461c7c8e2a93" args="(Matrix &amp;rhs) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#90c7aa10f5cc0bfa6542461c7c8e2a93">Chol_Ltmult</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes, after Chol_factor into LL^T was executed succesfully, the solution to L^Trhs, overwriting rhs by the solution; always returns 0; <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="816869a81b60664ccdbad8553e4f3239"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Chol_factor" ref="816869a81b60664ccdbad8553e4f3239" args="(Indexmatrix &amp;piv, Real tol=1e-10)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#816869a81b60664ccdbad8553e4f3239">Chol_factor</a> (<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;piv, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> tol=1e-10)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes the Cholesky factorization with pivoting, for positive semidefinite matrices only, (*this) is overwritten by the factorization; on termination piv.dim() is the number of positive pivots&gt;=tol; returns 1 if negative diagonal element is encountered during computations, 0 otherwise. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ed95dead1a74b4598d69809f72dd1685"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Chol_solve" ref="ed95dead1a74b4598d69809f72dd1685" args="(Matrix &amp;x, const Indexmatrix &amp;piv) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ed95dead1a74b4598d69809f72dd1685">Chol_solve</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;x, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;piv) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes, after <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#816869a81b60664ccdbad8553e4f3239" title="computes the Cholesky factorization with pivoting, for positive semidefinite matrices...">Chol_factor(Indexmatrix&amp;,Real)</a> with pivoting was executed succesfully, the solution to (*old_this)*x=rhs(piv); rhs is overwritten by the solution arranged in original unpermuted order; always returns 0; NOTE: there is NO check against division by zero <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3ae65fb970a16a426bd34f912b517d09"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Chol_inverse" ref="3ae65fb970a16a426bd34f912b517d09" args="(Symmatrix &amp;S, const Indexmatrix &amp;piv) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#3ae65fb970a16a426bd34f912b517d09">Chol_inverse</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;S, const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">Indexmatrix</a> &amp;piv) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes, after <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#816869a81b60664ccdbad8553e4f3239" title="computes the Cholesky factorization with pivoting, for positive semidefinite matrices...">Chol_factor(Indexmatrix&amp;,Real)</a> with pivoting was executed succesfully, the inverse to (*old_this) and stores it in S (the pivoting permutation is undone in S); NOTE: there is NO check against division by zero <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c5d1b6128d1d3887c1b8aa894baedc97"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::eig" ref="c5d1b6128d1d3887c1b8aa894baedc97" args="(Matrix &amp;P, Matrix &amp;d, bool sort_non_decreasingly=true) const " -->
<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#c5d1b6128d1d3887c1b8aa894baedc97">eig</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;P, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;d, bool sort_non_decreasingly=true) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">computes an eigenvalue decomposition P*Diag(d)*tranpose(P)=(*this) by symmetric QR; returns 0 on success, <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Input, Output (Members)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#11eaf9dbdcb722cf1bd9a94de2fcf0dc">display</a> (std::ostream &amp;out, int precision=0, int width=0, int screenwidth=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">displays a matrix in a pretty way for bounded screen widths; for variables of value zero default values are used.  <a href="#11eaf9dbdcb722cf1bd9a94de2fcf0dc"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5ceaaffaa26c44edc08e5277d6359abf"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::init_to_zero" ref="5ceaaffaa26c44edc08e5277d6359abf" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#5ceaaffaa26c44edc08e5277d6359abf">init_to_zero</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initialize the matrix to a 0x0 matrix without storage <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b00e9c0084385aed46acd26033888a0"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::tred2" ref="5b00e9c0084385aed46acd26033888a0" args="(Integer nm, Integer n, Real *a, Real *d, Real *e, Real *z) const " -->
<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#5b00e9c0084385aed46acd26033888a0">tred2</a> (<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> nm, <a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> n, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> *a, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> *d, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> *e, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> *z) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a subroutine needed internally for eigenvalue computations (eigval.cxx) <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="84fec70434f8d4ffce05b4117706aebe"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::imtql2" ref="84fec70434f8d4ffce05b4117706aebe" args="(Integer nm, Integer n, Real *d, Real *e, Real *z) const " -->
<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#84fec70434f8d4ffce05b4117706aebe">imtql2</a> (<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> nm, <a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a> n, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> *d, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> *e, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> *z) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a subroutine needed internally for eigenvalue computations (eigval.cxx) <br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="600d00a9c6e6e4486300944551d438e4"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::mem_dim" ref="600d00a9c6e6e4486300944551d438e4" args="" -->
<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#600d00a9c6e6e4486300944551d438e4">mem_dim</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">amount of memory currently allocated <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="081b04bbf1938d34a8bbb7031cdb6be6"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::nr" ref="081b04bbf1938d34a8bbb7031cdb6be6" args="" -->
<a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#081b04bbf1938d34a8bbb7031cdb6be6">nr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">number of rows = number of columns <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="af1429349326c49e60a47cfa2070c085"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::m" ref="af1429349326c49e60a47cfa2070c085" args="" -->
<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#af1429349326c49e60a47cfa2070c085">m</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">lower triangle stored columnwise (a11,a21,...,anr1,a22,.....) <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dafc192f6e4048c941ff9e1cb3d081d2"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::is_init" ref="dafc192f6e4048c941ff9e1cb3d081d2" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#dafc192f6e4048c941ff9e1cb3d081d2">is_init</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">flag whether memory is initialized, it is only used if CONICBUNDLE_DEBUG is defined <br></td></tr>
<tr><td colspan="2"><br><h2>Static Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1f17224f65d28e864c99e408223d93ab"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::mtype" ref="1f17224f65d28e864c99e408223d93ab" args="" -->
static const <a class="el" href="group__matop__matrixerror.html#g204f53041409b9f5efb2f8b41964b6b8">Mtype</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#1f17224f65d28e864c99e408223d93ab">mtype</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">used for <a class="el" href="classCH__Matrix__Classes_1_1MatrixError.html" title="Such an object is generated and passed to MEmessage(), whenever an error occurs....">MatrixError</a> templates (runtime type information was not yet existing) <br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="34913a9261681f734171a6da06bd56fe"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Matrix" ref="34913a9261681f734171a6da06bd56fe" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>Matrix</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9878c2d3402557fd5b3be83caa175b7d"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Sparsesym" ref="9878c2d3402557fd5b3be83caa175b7d" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>Sparsesym</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="49f868ef6a0082bb276b5683b8b21529"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Sparsemat" ref="49f868ef6a0082bb276b5683b8b21529" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>Sparsemat</b></td></tr>

<tr><td colspan="2"><div class="groupHeader">Indexing and Submatrices (Friends)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="08631d1ff2282cc4276e7bf4523cbd0c"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::diag" ref="08631d1ff2282cc4276e7bf4523cbd0c" args="(const Symmatrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#08631d1ff2282cc4276e7bf4523cbd0c">diag</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a column vector v consisting of the elements v(i)=(*this)(i,i), 0&lt;=i&lt;row dimension <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d630bb4d7adf30301456b754300a810"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Diag" ref="1d630bb4d7adf30301456b754300a810" args="(const Matrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#1d630bb4d7adf30301456b754300a810">Diag</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a symmetric diagonal matrix S of order A.dim() with vec(A) on the diagonal, i.e., S(i,i)=A(i) for all i and S(i,j)=0 for i!=j <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4273fb88315e1c5b863f36ddcde9c452"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::swap" ref="4273fb88315e1c5b863f36ddcde9c452" args="(Symmatrix &amp;A, Symmatrix &amp;B)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#4273fb88315e1c5b863f36ddcde9c452">swap</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">swap the content of the two matrices A and B (involves no copying) <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">BLAS-like Routines (Friends)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="222be37abe7779fd9abbf6f1a29a648c"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::rankadd" ref="222be37abe7779fd9abbf6f1a29a648c" args="(const Matrix &amp;A, Symmatrix &amp;C, Real alpha=1., Real beta=0., int trans=0)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#222be37abe7779fd9abbf6f1a29a648c">rankadd</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;C, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int trans=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns C=beta*C+alpha* A*A^T, where A may be transposed. If beta==0. then C is initiliazed to the correct size. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e9350f21b9d036df17bd04fc549108d"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::rank2add" ref="1e9350f21b9d036df17bd04fc549108d" args="(const Matrix &amp;A, const Matrix &amp;B, Symmatrix &amp;C, Real alpha=1., Real beta=0., int trans=0)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#1e9350f21b9d036df17bd04fc549108d">rank2add</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;C, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int trans=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns C=beta*C+alpha*(A*B^T+B*A^T)/2 [or for transposed (A^T*B+B^T*A)/2]. If beta==0. then C is initiliazed to the correct size. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cb5b2ce8d731769be88a0cf20c2eb414"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::xbpeya" ref="cb5b2ce8d731769be88a0cf20c2eb414" args="(Symmatrix &amp;x, const Symmatrix &amp;y, Real alpha=1., Real beta=0.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#cb5b2ce8d731769be88a0cf20c2eb414">xbpeya</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;x, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;y, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns x= alpha*y+beta*x; if beta==0. then x is initialized to the correct size <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="50be161ef22dcb01fe2c23a09c0ac927"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::xeyapzb" ref="50be161ef22dcb01fe2c23a09c0ac927" args="(Symmatrix &amp;x, const Symmatrix &amp;y, const Symmatrix &amp;z, Real alpha=1., Real beta=1.)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#50be161ef22dcb01fe2c23a09c0ac927">xeyapzb</a> (<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;x, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;y, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;z, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> beta=1.)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns x= alpha*y+beta*z; x is initialized to the correct size <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="55ebb47ea6bb8f262cd92b1c85491813"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::genmult" ref="55ebb47ea6bb8f262cd92b1c85491813" args="(const Symmatrix &amp;A, const Matrix &amp;B, Matrix &amp;C, Real alpha=1., Real beta=0., int btrans=0)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#55ebb47ea6bb8f262cd92b1c85491813">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int btrans=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where B may be transposed; C must not be equal to B; if beta==0. then C is initialized to the correct size <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3c68022535bf3bf5f438df265108946e"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::genmult" ref="3c68022535bf3bf5f438df265108946e" args="(const Matrix &amp;A, const Symmatrix &amp;B, Matrix &amp;C, Real alpha=1., Real beta=0., int atrans=0)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#3c68022535bf3bf5f438df265108946e">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int atrans=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A may be transposed; C must not be equal to A; if beta==0. then C is initialized to the correct size <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Usual Arithmetic Operators (Friends)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9c37cc81136194be67d4adf7a6de7e26"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator*" ref="9c37cc81136194be67d4adf7a6de7e26" args="(const Symmatrix &amp;A, const Symmatrix &amp;B)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="68a576744decb911ce5c872416316882"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator%" ref="68a576744decb911ce5c872416316882" args="(const Symmatrix &amp;A, const Symmatrix &amp;B)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#68a576744decb911ce5c872416316882">operator%</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ATTENTION: this is redefined as the Hadamard product and sets (i,j)=A(i,j)*B(i,j) for all i&lt;=j. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="370ea444b856b3a90dafc12e76245794"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator+" ref="370ea444b856b3a90dafc12e76245794" args="(const Symmatrix &amp;A, const Symmatrix &amp;B)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d435f8472eeb894dd3459a2678cf5184"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator-" ref="d435f8472eeb894dd3459a2678cf5184" args="(const Symmatrix &amp;A, const Symmatrix &amp;B)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="657f28e27afb57e0dee0abd249a60989"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator*" ref="657f28e27afb57e0dee0abd249a60989" args="(const Symmatrix &amp;A, const Matrix &amp;B)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="95bd05e45383a3bc969e392775bd66d4"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator*" ref="95bd05e45383a3bc969e392775bd66d4" args="(const Matrix &amp;A, const Symmatrix &amp;B)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d2c9d5ee5e6f5c7eac83355c446574d0"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator+" ref="d2c9d5ee5e6f5c7eac83355c446574d0" args="(const Symmatrix &amp;A, const Matrix &amp;B)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8beec55f783526027275429847c514e9"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator+" ref="8beec55f783526027275429847c514e9" args="(const Matrix &amp;A, const Symmatrix &amp;B)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1a1702c7a379d804c2b23b1ccf90b878"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator-" ref="1a1702c7a379d804c2b23b1ccf90b878" args="(const Symmatrix &amp;A, const Matrix &amp;B)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7ac641660c567e4398205b4d5b31089b"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator-" ref="7ac641660c567e4398205b4d5b31089b" args="(const Matrix &amp;A, const Symmatrix &amp;B)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d48f4e8e2a0a85428c9eff8367526811"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator*" ref="d48f4e8e2a0a85428c9eff8367526811" args="(const Symmatrix &amp;A, Real d)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="daa5090c10545913a01403f204c0de09"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator*" ref="daa5090c10545913a01403f204c0de09" args="(Real d, const Symmatrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5d69c2993966b64bc3cf19d85f073e28"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator/" ref="5d69c2993966b64bc3cf19d85f073e28" args="(const Symmatrix &amp;A, Real d)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="43a32387a962736098b3a442d7e5f65a"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator+" ref="43a32387a962736098b3a442d7e5f65a" args="(const Symmatrix &amp;A, Real d)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#43a32387a962736098b3a442d7e5f65a">operator+</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns (i,j)=A(i,j)+d for all i&lt;=j <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="46d570b64196b8d57dc8fcdffd9d6e4c"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator+" ref="46d570b64196b8d57dc8fcdffd9d6e4c" args="(Real d, const Symmatrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#46d570b64196b8d57dc8fcdffd9d6e4c">operator+</a> (<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns (i,j)=A(i,j)+d for all i&lt;=j <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0188f39a48eb15ea09b389572ed91141"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator-" ref="0188f39a48eb15ea09b389572ed91141" args="(const Symmatrix &amp;A, Real d)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#0188f39a48eb15ea09b389572ed91141">operator-</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns (i,j)=A(i,j)-d for all i&lt;=j <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5c91ea2552a4a769cdd73d9d05ee6d6e"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator-" ref="5c91ea2552a4a769cdd73d9d05ee6d6e" args="(Real d, const Symmatrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#5c91ea2552a4a769cdd73d9d05ee6d6e">operator-</a> (<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> d, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns (i,j)=d-A(i,j) for all i&lt;=j <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="45f980b595982f10fd0857023a5f77fb"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::transpose" ref="45f980b595982f10fd0857023a5f77fb" args="(const Symmatrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#45f980b595982f10fd0857023a5f77fb">transpose</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(drop it or use a constructor instead) <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Connections to other Classes (Friends)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="732a9fda7688d3ece8b9be1ce3224b83"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::genmult" ref="732a9fda7688d3ece8b9be1ce3224b83" args="(const Symmatrix &amp;A, const Sparsemat &amp;B, Matrix &amp;C, Real alpha=1., Real beta=0., int btrans=0)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#732a9fda7688d3ece8b9be1ce3224b83">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int btrans=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where B may be transposed; if beta==0. then C is initialized to the correct size <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="307b7cd11ad37b73551423ced670c365"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::genmult" ref="307b7cd11ad37b73551423ced670c365" args="(const Sparsemat &amp;A, const Symmatrix &amp;B, Matrix &amp;C, Real alpha=1., Real beta=0., int atrans=0)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#307b7cd11ad37b73551423ced670c365">genmult</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;C, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int atrans=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns C=beta*C+alpha*A*B, where A may be transposed; if beta==0. then C is initialized to the correct size <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d1be71533ed44a60da366bbe079a8a24"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::rankadd" ref="d1be71533ed44a60da366bbe079a8a24" args="(const Sparsemat &amp;A, Symmatrix &amp;C, Real alpha=1., Real beta=0., int trans=0)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#d1be71533ed44a60da366bbe079a8a24">rankadd</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;C, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int trans=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns C=beta*C+alpha* A*A^T, where A may be transposed; if beta==0. then C is initialized to the correct size <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4f9aa8bb1d58a24802a6a62c565b26a2"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::rank2add" ref="4f9aa8bb1d58a24802a6a62c565b26a2" args="(const Sparsemat &amp;A, const Matrix &amp;B, Symmatrix &amp;C, Real alpha=1., Real beta=0., int trans=0)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#4f9aa8bb1d58a24802a6a62c565b26a2">rank2add</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Sparsemat.html">Sparsemat</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;C, <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> alpha=1., <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a> beta=0., int trans=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns C=beta*C+alpha*(A*B^T+B*A^T)/2 [or for transposed (A^T*B+B^T*A)/2]. If beta==0. then C is initiliazed to the correct size. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Elementwise Operations (Friends)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dd07bc055dbc2e1e5034218370512881"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::abs" ref="dd07bc055dbc2e1e5034218370512881" args="(const Symmatrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Numerical Methods (Friends)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a79b38c111b29d22811c6cfa805b81e5"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::trace" ref="a79b38c111b29d22811c6cfa805b81e5" args="(const Symmatrix &amp;A)" -->
<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a79b38c111b29d22811c6cfa805b81e5">trace</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the sum of the diagonal elements A(i,i) over all i <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e2f9ab5cf82f474ceb7a945f5ce104da"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::ip" ref="e2f9ab5cf82f474ceb7a945f5ce104da" args="(const Symmatrix &amp;A, const Symmatrix &amp;B)" -->
<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#e2f9ab5cf82f474ceb7a945f5ce104da">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d94a253ae83cb857da974e63802512ca"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::ip" ref="d94a253ae83cb857da974e63802512ca" args="(const Matrix &amp;A, const Symmatrix &amp;B)" -->
<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#d94a253ae83cb857da974e63802512ca">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ac3347e9e818cb647222904bd64332b3"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::ip" ref="ac3347e9e818cb647222904bd64332b3" args="(const Symmatrix &amp;A, const Matrix &amp;B)" -->
<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ac3347e9e818cb647222904bd64332b3">ip</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ad57c5351a4bb87122495dfa7051b1c8"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::norm2" ref="ad57c5351a4bb87122495dfa7051b1c8" args="(const Symmatrix &amp;A)" -->
<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ad57c5351a4bb87122495dfa7051b1c8">norm2</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the Frobenius norm of A, i.e., the square root of the sum of A(i,j)*A(i,j) over all i,j <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e59fa8f9c3755d268074239665811ef3"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::sumrows" ref="e59fa8f9c3755d268074239665811ef3" args="(const Symmatrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#e59fa8f9c3755d268074239665811ef3">sumrows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a row vector holding the sum over all rows, i.e., (1 1 ... 1)*A <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ee7a0b88dcb2fb86e9cca7fd97fd946e"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::sumcols" ref="ee7a0b88dcb2fb86e9cca7fd97fd946e" args="(const Symmatrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#ee7a0b88dcb2fb86e9cca7fd97fd946e">sumcols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a column vector holding the sum over all columns, i.e., A*(1 1 ... 1)^T <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7fe9d3feb6915a3967d27cb2ff654c86"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::sum" ref="7fe9d3feb6915a3967d27cb2ff654c86" args="(const Symmatrix &amp;A)" -->
<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#7fe9d3feb6915a3967d27cb2ff654c86">sum</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the sum over all elements of A, i.e., (1 1 ... 1)*A*(1 1 ... 1)^T <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d69c77c7ce5cefdfdb5902f27cead1f1"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::svec" ref="d69c77c7ce5cefdfdb5902f27cead1f1" args="(const Symmatrix &amp;A, Matrix &amp;v)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#d69c77c7ce5cefdfdb5902f27cead1f1">svec</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the symmetric vec operator, stacks the lower triangle of A to a n*(n+1)/2 vector with the same norm2 as A; i.e., it sets v=svec(A)=[a11,sqrt(2)a12,...,sqrt(2)a1n,a22,...,sqrt(2)a(n-1,n),ann]' <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3bb3c073c9d4a628b2a0144ee9285ee6"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::svec" ref="3bb3c073c9d4a628b2a0144ee9285ee6" args="(const Symmatrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#3bb3c073c9d4a628b2a0144ee9285ee6">svec</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the symmetric vec operator, stacks the lower triangle of A to a n*(n+1)/2 vector with the same norm2 as A; i.e., it returns svec(A)=[a11,sqrt(2)a12,...,sqrt(2)a1n,a22,...,sqrt(2)a(n-1,n),ann]' <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="48c44b8b70126c2fab508642837f896f"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::sveci" ref="48c44b8b70126c2fab508642837f896f" args="(const Matrix &amp;v, Symmatrix &amp;A)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#48c44b8b70126c2fab508642837f896f">sveci</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a> &amp;v, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the inverse operator to svec, reconstructs the symmetric matrix A form the vector v <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="db487c0e97370adb12a5f92b8d117a5f"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::skron" ref="db487c0e97370adb12a5f92b8d117a5f" args="(const Symmatrix &amp;A, const Symmatrix &amp;B)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#db487c0e97370adb12a5f92b8d117a5f">skron</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the symmetric Kronecker product, defined via (A skron B)svec(C)=(BCA'+ACB')/2; returns the symmetric matrix (A skron B) <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e2e7a46fa3dfb3557e0fdf990822e87"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::skron" ref="1e2e7a46fa3dfb3557e0fdf990822e87" args="(const Symmatrix &amp;A, const Symmatrix &amp;B, Symmatrix &amp;S)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#1e2e7a46fa3dfb3557e0fdf990822e87">skron</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;B, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;S)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the symmetric Kronecker product, defined via (A skron B)svec(C)=(BCA'+ACB')/2; sets S=(A skron B) <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparisons, Max, Min, Sort, Find (Friends)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6a61be50f9dda7c6e29fe7317b9c49a0"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::minrows" ref="6a61be50f9dda7c6e29fe7317b9c49a0" args="(const Symmatrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#6a61be50f9dda7c6e29fe7317b9c49a0">minrows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a row vector holding in each column the minimum over all rows in this column <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3b459f99d09e50b7b8e59fbcd60cc8c"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::mincols" ref="a3b459f99d09e50b7b8e59fbcd60cc8c" args="(const Symmatrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#a3b459f99d09e50b7b8e59fbcd60cc8c">mincols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a column vector holding in each row the minimum over all columns in this row <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="539bccf2eb3d3dbd603668e4230c0224"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::min" ref="539bccf2eb3d3dbd603668e4230c0224" args="(const Symmatrix &amp;A)" -->
<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#539bccf2eb3d3dbd603668e4230c0224">min</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the minimum value over all elements of the matrix <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="60952a4f89bade715bf5df4836fb5d1d"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::maxrows" ref="60952a4f89bade715bf5df4836fb5d1d" args="(const Symmatrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#60952a4f89bade715bf5df4836fb5d1d">maxrows</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a row vector holding in each column the maximum over all rows in this column <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b30f3d9f5957dc380c8c28763f61ea39"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::maxcols" ref="b30f3d9f5957dc380c8c28763f61ea39" args="(const Symmatrix &amp;A)" -->
<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">Matrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#b30f3d9f5957dc380c8c28763f61ea39">maxcols</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a column vector holding in each row the maximum over all columns in this row <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="02e63e3515c052846682e1f460454c6c"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::max" ref="02e63e3515c052846682e1f460454c6c" args="(const Symmatrix &amp;A)" -->
<a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#02e63e3515c052846682e1f460454c6c">max</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the maximum value over all elements of the matrix <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Input, Output (Friends)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d97c2e957cf41b29eb0aa835d7b909a"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator&lt;&lt;" ref="1d97c2e957cf41b29eb0aa835d7b909a" args="(std::ostream &amp;o, const Symmatrix &amp;A)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#1d97c2e957cf41b29eb0aa835d7b909a">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">output format (nr and nc are <a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd" title="all integer numbers in calculations and indexing are of this type">Integer</a> values, all others <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type">Real</a> values): <br>
 nr nc \n A(1,1) A(1,2) ... A(1,nc) \n A(2,1) ... A(nr,nc) \n <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d01d338d4c1259d47a5fa6bcd13a4ea0"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::operator&gt;&gt;" ref="d01d338d4c1259d47a5fa6bcd13a4ea0" args="(std::istream &amp;i, Symmatrix &amp;A)" -->
std::istream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#d01d338d4c1259d47a5fa6bcd13a4ea0">operator&gt;&gt;</a> (std::istream &amp;i, <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html">Symmatrix</a> &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">input format (nr and nc are <a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd" title="all integer numbers in calculations and indexing are of this type">Integer</a> values, all others <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type">Real</a> values): <br>
 nr nc \n A(1,1) A(1,2) ... A(1,nc) \n A(2,1) ... A(nr,nc) \n <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Matrix class of symmetric matrices with real values of type <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type">Real</a> 
<p>
Internally a symmetric matrix of size nr x nr is stored in a one dimensional array of <a class="el" href="group__matop__types.html#g531d7da3afa69ae831131bfe00f57f03" title="all real numbers in calculations are of this type">Real</a> variables, the elements of the lower triangle are arranged in columnwise order (a11,a21,...,anr1,a22,a32,...).<p>
Any matrix element can be indexed by (i,j) or directly by the one dimensional index (i+j*nr). The latter view directly corresponds to the vec() operator often used in the linear algebra literature, i.e., the matrix is transformed to a vector by stacking the columns on top of each other.<p>
NOTE: Any change of A(i,j) also changes A(j,i) as both variables are identical! <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="eea95b6f59c5c5012a08088f4208601e"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::Symmatrix" ref="eea95b6f59c5c5012a08088f4208601e" args="(Integer nr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CH_Matrix_Classes::Symmatrix::Symmatrix           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a>&nbsp;</td>
          <td class="paramname"> <em>nr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
generate a matrix of size nr x nr but WITHOUT initializing the memory 
<p>
If initializing the memory externally and CONICBUNDLE_DEBUG is defined, please use <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#2ea14efca04115bfb34febd3084108ab" title="after external initialization, call matrix.set_init(true) (not needed if CONICBUNDLE_DEBUG...">set_init()</a> via matrix.set_init(true) in order to avoid warnings concerning improper initialization 
<p>References <a class="el" href="symmat_8hxx-source.html#l00606">init_to_zero()</a>, and <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#43e3cc5de2659fb4eb213eaca2276626">newsize()</a>.</p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="43e3cc5de2659fb4eb213eaca2276626"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::newsize" ref="43e3cc5de2659fb4eb213eaca2276626" args="(Integer n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CH_Matrix_Classes::Symmatrix::newsize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__matop__types.html#g325dd69690071a98f09a8d74c50edccd">Integer</a>&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
resize the matrix to nr x nr elements but WITHOUT initializing the memory 
<p>
If initializing the memory externally and CONICBUNDLE_DEBUG is defined, please use <a class="el" href="classCH__Matrix__Classes_1_1Symmatrix.html#2ea14efca04115bfb34febd3084108ab" title="after external initialization, call matrix.set_init(true) (not needed if CONICBUNDLE_DEBUG...">set_init()</a> via matrix.set_init(true) in order to avoid warnings concerning improper initialization 
<p>Referenced by <a class="el" href="symmat_8hxx-source.html#l00623">init()</a>, and <a class="el" href="symmat_8hxx-source.html#l00651">Symmatrix()</a>.</p>

</div>
</div><p>
<a class="anchor" name="11eaf9dbdcb722cf1bd9a94de2fcf0dc"></a><!-- doxytag: member="CH_Matrix_Classes::Symmatrix::display" ref="11eaf9dbdcb722cf1bd9a94de2fcf0dc" args="(std::ostream &amp;out, int precision=0, int width=0, int screenwidth=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CH_Matrix_Classes::Symmatrix::display           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>precision</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>screenwidth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
displays a matrix in a pretty way for bounded screen widths; for variables of value zero default values are used. 
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>out</em>&nbsp;</td><td>
output stream </td></tr>
<tr><td valign="top"><em>precision</em>&nbsp;</td><td>
number of most significant digits, default=4 </td></tr>
<tr><td valign="top"><em>width</em>&nbsp;</td><td>
field width, default = precision+6 </td></tr>
<tr><td valign="top"><em>screenwidth</em>&nbsp;</td><td>
maximum number of characters in one output line, default = 80 </td></tr>
</table>
</dl>
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="symmat_8hxx-source.html">symmat.hxx</a><li><a class="el" href="sparssym_8hxx-source.html">sparssym.hxx</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue May 3 16:52:54 2011 for ConicBundle by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
