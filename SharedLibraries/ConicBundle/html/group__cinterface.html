<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ConicBundle: Interface to ConicBundle for the Language C</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Interface to ConicBundle for the Language C</h1>Solve <img class="formulaInl" alt="$min_{y\in\mathbf{R}^m} f_0(y) + f_1(y) + ... + f_k(y)$" src="form_5.png"> for convex functions f_i, the y-variables may be bounded or box constrained. The most important steps are explained here.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g3db3fcd0373ad6168ac6a75f9f2f4291"></a><!-- doxytag: member="cinterface::cb_problemp" ref="g3db3fcd0373ad6168ac6a75f9f2f4291" args="" -->
typedef struct CB_CSolver *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pointer to a <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual...">ConicBundle</a> problem <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g18f2ccf1c7f9b7ffa48807da08ee7f84">cb_functionp</a> )(void *function_key, double *arg, double relprec, int max_subg, double *objective_value, int *n_subgrads, double *subg_values, double *subgradients, double *primal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">function oracle; describe your function as a function of this type to pass it to the solver  <a href="#g18f2ccf1c7f9b7ffa48807da08ee7f84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g5359ea8b2c26c3111a763cac6813c29d">cb_subgextp</a> )(void *function_key, double *generating_primal, int n_indices, int *variable_indices, double *new_subgradient_values)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine is not needed unless variabls (constraints in Lagrangean relaxation) are added on the fly.  <a href="#g5359ea8b2c26c3111a763cac6813c29d"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g807cf763dcc577a01ac76814b9c8a2bc">cb_construct_problem</a> (int no_bundle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a a new problem object and returns a pointer to it.  <a href="#g807cf763dcc577a01ac76814b9c8a2bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g70f97962511ee09f1456e032061d2e30">cb_destruct_problem</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructs and frees the problem object.  <a href="#g70f97962511ee09f1456e032061d2e30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g8b839895c52febec613647f425ebb9fd">cb_clear</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears all data structures and problem information but keeps ouptut settings and algorithmic parameter settings.  <a href="#g8b839895c52febec613647f425ebb9fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gd6c1f335e1b8ab61bb854665a03a45f0">cb_set_defaults</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets default values for algorithmic parameters that are not function specific (e.g., relative precision, weight and weight bounds for the augmentedproblem, etc.).  <a href="#gd6c1f335e1b8ab61bb854665a03a45f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g2b579e5fc1a75e5bc3b61ec02c45a527">cb_init_problem</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int m, double *lowerb, double *upperb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the problem by setting the design space (the dimension and possible box constraints of the variables).  <a href="#g2b579e5fc1a75e5bc3b61ec02c45a527"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc">cb_add_function</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key, <a class="el" href="group__cinterface.html#g18f2ccf1c7f9b7ffa48807da08ee7f84">cb_functionp</a> f, <a class="el" href="group__cinterface.html#g5359ea8b2c26c3111a763cac6813c29d">cb_subgextp</a> se, int primaldim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the function, the sum of which should be minimized, to the problem description.  <a href="#g96316b3769d671690ffddf3c0d98e7cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gfc6ea382c7f9352615238d8913f8fbee">cb_set_lower_bound</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int i, double lower_bound)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set lower bound for variable i, use <a class="el" href="group__cinterface.html#g7969bf339ee57ce667278104ad9adcf7" title="Returns the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are...">cb_get_minus_infinity()</a> for unbounded from below.  <a href="#gfc6ea382c7f9352615238d8913f8fbee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g490345cc46c2a3cdd32741fe27234ee5">cb_set_upper_bound</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int i, double upper_bound)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set upper bound for variable i, use <a class="el" href="group__cinterface.html#g7889cf44af8cc62fbffa30f0143e1fb9" title="Returns the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are...">cb_get_plus_infinity()</a> for unbounded above.  <a href="#g490345cc46c2a3cdd32741fe27234ee5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gfdba8de5a1ebd0c2dc678997f2845e8f">cb_append_variables</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int n_append, double *lowerb, double *upperb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append new variables (always in last postions in this order).  <a href="#gfdba8de5a1ebd0c2dc678997f2845e8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6f318b3a93b7109393194cb9e2fa86d">cb_delete_variables</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int n_del, int *delete_indices, int *map_to_old)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes variables corresponding to the specified indices.  <a href="#ga6f318b3a93b7109393194cb9e2fa86d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g175ef1a2e40596de40cb8e62d451d20e">cb_reassign_variables</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int n_assign, int *assign_new_from_old)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reassigns variables to new index positions by mapping to position <em>i</em> the variable that previously had index <em>assign_new_from_old</em>[i].  <a href="#g175ef1a2e40596de40cb8e62d451d20e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g390943acb8988f251704a2ec0c6c5a70">cb_do_descent_step</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does a descent step for the current center point.  <a href="#g390943acb8988f251704a2ec0c6c5a70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g09541e032eac1a90fbbcceb25bd4c0da">cb_do_maxsteps</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int maxsteps)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does a descent step for the current center point but also returns after at most maxstep null steps.  <a href="#g09541e032eac1a90fbbcceb25bd4c0da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3b07ae3eeadb1e39f92cf054f41abd1">cb_termination_code</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the termination code of the bundle algorithm for the latest descent step.  <a href="#ga3b07ae3eeadb1e39f92cf054f41abd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gcb69b4a3769e26ce8e72fadb68cf0b6b">cb_print_termination_code</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Outputs a text version of termination code, see <a class="el" href="group__cinterface.html#ga3b07ae3eeadb1e39f92cf054f41abd1" title="Returns the termination code of the bundle algorithm for the latest descent step...">cb_termination_code()</a>.  <a href="#gcb69b4a3769e26ce8e72fadb68cf0b6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g6c2bc6d66d23d5a335d5694727797a31">cb_get_objval</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the objective value resulting from last descent step (initially undefined).  <a href="#g6c2bc6d66d23d5a335d5694727797a31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g14ae01f65c97695217a9144638970eb6">cb_get_center</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double *center)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the next center point that was produced by the last call to cb_do_descent_step (in some problem modification routines the center point may be updated immediately, in others the center point will be corrected automatically directly before starting the next descent step and its values may be infeasible till then).  <a href="#g14ae01f65c97695217a9144638970eb6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g6726b5f928d838ad359cbb69fdc5e0b0">cb_get_sgnorm</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns Euclidean norm of the latest aggregate subgradient.  <a href="#g6726b5f928d838ad359cbb69fdc5e0b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g896e34b83c271271169057668f1c44c7">cb_get_subgradient</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double *subgradient)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the latest aggregate subgradient.  <a href="#g896e34b83c271271169057668f1c44c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g95296a6cd39a49c689bc6179653805a0">cb_get_candidate_value</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the objective value computed in the last step of do_descent_step(), independent of whether this was a descent step or a null step (initially undefined).  <a href="#g95296a6cd39a49c689bc6179653805a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g61d22658a33503ff35b5972e10cf6651">cb_get_candidate</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double *candidate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the last point, the "candidate", at which the function was evaluated in <a class="el" href="group__cinterface.html#g390943acb8988f251704a2ec0c6c5a70" title="Does a descent step for the current center point.">cb_do_descent_step()</a>.  <a href="#g61d22658a33503ff35b5972e10cf6651"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g65b10cf79c9523c122369a37ad4eee67">cb_set_term_relprec</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double term_relprec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the relative precision requirements for successful termination (default 1e-5).  <a href="#g65b10cf79c9523c122369a37ad4eee67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g45bdcc8c58aa94a1b8231bf38f1d8097">cb_set_new_center_point</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double *center)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the starting point/center that will be used in the next call to <a class="el" href="group__cinterface.html#g390943acb8988f251704a2ec0c6c5a70" title="Does a descent step for the current center point.">cb_do_descent_step()</a>. Each call to this routine causes an immediate evaluation of all oracles.  <a href="#g45bdcc8c58aa94a1b8231bf38f1d8097"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ge5043cc3bcf11c4e5df41563da73d524">cb_get_function_status</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the return value of the latest evaluation call to the function with this <em>function_key</em>.  <a href="#ge5043cc3bcf11c4e5df41563da73d524"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g3ef418836d555c0b55bd9f198109e61d">cb_get_approximate_slacks</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double *slacks)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the multipliers for the bound constraints on the design variables; in Lagrangean relaxation they may be interpreted as primal slacks for inequality constraints.  <a href="#g3ef418836d555c0b55bd9f198109e61d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g32cd4b02ba0eac656f5970f64daf68c3">cb_get_approximate_primal</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key, double *primal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current approximate primal solution for the function having this <em>function_key</em>.  <a href="#g32cd4b02ba0eac656f5970f64daf68c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g499088981d7a12f5f86c8cac6e8000c7">cb_get_center_primal</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key, double *primal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the best primal solution obtained in the current center point in evaluating the function having this <em>function_key</em>.  <a href="#g499088981d7a12f5f86c8cac6e8000c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g20b777b524d15f9e4efd6cc931766eee">cb_get_candidate_primal</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key, double *primal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the best primal solution returned by the last evaluation of the function having this <em>function_key</em> in the point <a class="el" href="group__cinterface.html#g61d22658a33503ff35b5972e10cf6651" title="Returns the last point, the &quot;candidate&quot;, at which the function was evaluated...">cb_get_candidate()</a>.  <a href="#g20b777b524d15f9e4efd6cc931766eee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gb9e6845864cff4362f0401658062461c">cb_set_max_bundlesize</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key, int bundlesize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum number of subgradients used in forming the cutting model of the function having this <em>function_key</em>.  <a href="#gb9e6845864cff4362f0401658062461c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf987af753c04154797c76bdae54e595">cb_set_max_new_subgradients</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key, int max_new_subg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum number of epsilon subgradients that can be returned in one call to the function having this <em>function_key</em>.  <a href="#gaf987af753c04154797c76bdae54e595"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g23d072bda788a0cd827cc506175bd740">cb_get_bundle_parameters</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key, int *max_bundlesize, int *max_new_subgradients)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the two bundle parameters specified in the routines <a class="el" href="group__cinterface.html#gb9e6845864cff4362f0401658062461c" title="Sets the maximum number of subgradients used in forming the cutting model of the...">cb_set_max_bundlesize()</a> and <a class="el" href="group__cinterface.html#gaf987af753c04154797c76bdae54e595" title="Sets the maximum number of epsilon subgradients that can be returned in one call...">cb_set_max_new_subgradients()</a>. for the function having this <em>function_key</em>.  <a href="#g23d072bda788a0cd827cc506175bd740"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g8f2f4da68fe1e00801754ed2b14de20e">cb_get_bundle_values</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key, int *bundlesize, int *new_subgradients)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns, for the function having this <em>function_key</em>, the current number of subgradients in use in the cutting model and the number of epsilon subgradients returned in the latest evaluation call to the function.  <a href="#g8f2f4da68fe1e00801754ed2b14de20e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g987d2a140fe4660ae228b20bee8320d8">cb_reinit_function_model</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, void *function_key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears cutting model, subgradients and stored function values for the function with this <em>function_key</em>.  <a href="#g987d2a140fe4660ae228b20bee8320d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g42edf299547b8b9c232ea26ee3b3a923">cb_get_last_weight</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current weight for the quadratic term in the augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius).  <a href="#g42edf299547b8b9c232ea26ee3b3a923"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g412e288c208f049f49024e51198d3e4b">cb_set_next_weight</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double weight)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the weight (&gt;0) to be used in the quadratic term of the next augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius).  <a href="#g412e288c208f049f49024e51198d3e4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g2a68aaafcf76054d085266b009f4cd4c">cb_set_min_weight</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double min_weight)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a lower bound on the weight for the quadratic term of the augmented subproblem.  <a href="#g2a68aaafcf76054d085266b009f4cd4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gb7940fa588317bdd3837bb448871a66e">cb_set_max_weight</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, double max_weight)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an upper bound on the weight for the quadratic term of the augmented subproblem.  <a href="#gb7940fa588317bdd3837bb448871a66e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gcf08ea1cf2327669c3f4dcf455800238"></a><!-- doxytag: member="cinterface::cb_get_dim" ref="gcf08ea1cf2327669c3f4dcf455800238" args="(cb_problemp p)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gcf08ea1cf2327669c3f4dcf455800238">cb_get_dim</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current dimension of the design space/argument or -1 if no dimension is set. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g48db88979f8c94b0feca1d62ab4a41b4"></a><!-- doxytag: member="cinterface::cb_get_n_functions" ref="g48db88979f8c94b0feca1d62ab4a41b4" args="(cb_problemp p)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g48db88979f8c94b0feca1d62ab4a41b4">cb_get_n_functions</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current number of functions in the problem. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7969bf339ee57ce667278104ad9adcf7"></a><!-- doxytag: member="cinterface::cb_get_minus_infinity" ref="g7969bf339ee57ce667278104ad9adcf7" args="(void)" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g7969bf339ee57ce667278104ad9adcf7">cb_get_minus_infinity</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value "minus infinity", i.e., all bounds &lt;= this value are set to this value and are regarded as minus infinity. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7889cf44af8cc62fbffa30f0143e1fb9"></a><!-- doxytag: member="cinterface::cb_get_plus_infinity" ref="g7889cf44af8cc62fbffa30f0143e1fb9" args="(void)" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g7889cf44af8cc62fbffa30f0143e1fb9">cb_get_plus_infinity</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value "plus infinity", i.e., all bounds &gt;= this value are set to this value and are regarded as plus infinity. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g6374cbb172eac48e21c1838a74f4da0b">cb_clear_fail_counts</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">clears all fail counts on numerical function oder model failures, may be useful if this caused premature termination.  <a href="#g6374cbb172eac48e21c1838a74f4da0b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g78da3da3e172d97d3ce16f151c91da8d">cb_set_eval_limit</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int eval_limit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an upper bound on the number of calls to the oracle (use negative numbers for no limit).  <a href="#g78da3da3e172d97d3ce16f151c91da8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g875c9bcc1eb3028c633c0b31415dc01c">cb_set_inner_update_limit</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int update_limit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an upper bound on the number of inner updates for the cutting model with primal slacks within one null step (use negative numbers for no limit).  <a href="#g875c9bcc1eb3028c633c0b31415dc01c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#g4a51b181c4a0488a950edb196e8984f8">cb_set_active_bounds_fixing</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int allow_fixing)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If set to true (the default is false), some variables will be fixed automatically to the center value if their bounds are strongly active (i.e., the corresponding multipliers are big).  <a href="#g4a51b181c4a0488a950edb196e8984f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga90b115b43f88c12036f0a2852fc2204">cb_get_active_bounds_indicator</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int *indicator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the indicator vector of variables temporarily fixed to the center value due to significantly positive multipliers for the box constraints, see <a class="el" href="group__cinterface.html#g4a51b181c4a0488a950edb196e8984f8" title="If set to true (the default is false), some variables will be fixed automatically...">cb_set_active_bounds_fixing()</a>.  <a href="#ga90b115b43f88c12036f0a2852fc2204"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gfb3888ddf0640bef9fc5e460fc81a32e">cb_set_print_level</a> (<a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> p, int pril)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies the output level (&lt;0 no output at all, =0 errors and warnings, &gt;0 increasingly detailed information).  <a href="#gfb3888ddf0640bef9fc5e460fc81a32e"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Solve <img class="formulaInl" alt="$min_{y\in\mathbf{R}^m} f_0(y) + f_1(y) + ... + f_k(y)$" src="form_5.png"> for convex functions f_i, the y-variables may be bounded or box constrained. The most important steps are explained here. 
<p>
<b>Setting up the Problem, the Functions, and the Main Loop</b><p>
First open a new problem by calling cb_construct_problem(0) [use cb_construct_prolbem(1) in order to employ a minimal bundle solver with just one aggregate and one new subgradient in each iteration; this is an attractive choice, if fast iterations and/or little memory consumption are of special importance]. The returned pointer of type <a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291" title="pointer to a ConicBundle problem">cb_problemp</a> will be needed for every manipulation of this problem. Once you are done with the problem, however, do not forget to destroy this pointer with <a class="el" href="group__cinterface.html#g70f97962511ee09f1456e032061d2e30" title="Destructs and frees the problem object.">cb_destruct_problem()</a>.<p>
Next, set the dimension of the design variables/argument as well as possible box constraints on these by the function <a class="el" href="group__cinterface.html#g2b579e5fc1a75e5bc3b61ec02c45a527" title="Initializes the problem by setting the design space (the dimension and possible box...">cb_init_problem()</a>.<p>
Now set up your functions f_i as functions of type <a class="el" href="group__cinterface.html#g18f2ccf1c7f9b7ffa48807da08ee7f84" title="function oracle; describe your function as a function of this type to pass it to...">cb_functionp</a>. Via these functions you will supply, for a given argument, the function value and a subgradient (=the gradient if the function is differentiable) to the solver.<p>
The <a class="el" href="group__cinterface.html#g18f2ccf1c7f9b7ffa48807da08ee7f84" title="function oracle; describe your function as a function of this type to pass it to...">cb_functionp</a> representations have to be added to the solver using the routine <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a>.<p>
Once all functions are added, the optimization process can be started. If you know a good starting point then set it with <a class="el" href="group__cinterface.html#g45bdcc8c58aa94a1b8231bf38f1d8097" title="Set the starting point/center that will be used in the next call to cb_do_descent_step()...">cb_set_new_center_point()</a> now, otherwise the method will pick the zero vector or, in the case of box constraints, the point closest to zero as starting point.<p>
Finally, set up a loop that calls <a class="el" href="group__cinterface.html#g390943acb8988f251704a2ec0c6c5a70" title="Does a descent step for the current center point.">cb_do_descent_step()</a> until <a class="el" href="group__cinterface.html#ga3b07ae3eeadb1e39f92cf054f41abd1" title="Returns the termination code of the bundle algorithm for the latest descent step...">cb_termination_code()</a> is nonzero.<p>
<b>Setting up the Problem, the Functions, and the Main Loop</b><p>
After the first call to <a class="el" href="group__cinterface.html#g390943acb8988f251704a2ec0c6c5a70" title="Does a descent step for the current center point.">cb_do_descent_step()</a> you can retrieve, at any time, the current objective value by <a class="el" href="group__cinterface.html#g6c2bc6d66d23d5a335d5694727797a31" title="Returns the objective value resulting from last descent step (initially undefined)...">cb_get_objval()</a> and the argument leading to this value by <a class="el" href="group__cinterface.html#g14ae01f65c97695217a9144638970eb6" title="Returns the next center point that was produced by the last call to cb_do_descent_step...">cb_get_center()</a>. For some screen output, use <a class="el" href="group__cinterface.html#gfb3888ddf0640bef9fc5e460fc81a32e" title="Specifies the output level (&lt;0 no output at all, =0 errors and warnings, &gt;0...">cb_set_print_level()</a>.<p>
<b>Lagrangean Relaxation, Primal Approximations, and Cutting Planes</b><p>
If you are optimizing a Lagrangean relaxation, you might be interested in getting an approximation to your primal optimal solution. This can be done by specifying in each function for each (epsilon) subgradient the corresponding primal vectors that generate it, see <a class="el" href="group__cinterface.html#g18f2ccf1c7f9b7ffa48807da08ee7f84" title="function oracle; describe your function as a function of this type to pass it to...">cb_functionp</a> and <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a> as a start. Then for each of your functions, you can retrieve the current primal approximation using <a class="el" href="group__cinterface.html#g32cd4b02ba0eac656f5970f64daf68c3" title="Returns the current approximate primal solution for the function having this function_key...">cb_get_approximate_primal()</a>.<p>
If, in addition, you plan to improve your primal relaxation via cutting planes, that are strongly violated by the current primal approximation, you should have a look at <a class="el" href="group__cinterface.html#gfdba8de5a1ebd0c2dc678997f2845e8f" title="Append new variables (always in last postions in this order).">cb_append_variables()</a>, <a class="el" href="group__cinterface.html#g5359ea8b2c26c3111a763cac6813c29d" title="This routine is not needed unless variabls (constraints in Lagrangean relaxation)...">cb_subgextp</a>, <a class="el" href="group__cinterface.html#g987d2a140fe4660ae228b20bee8320d8" title="Clears cutting model, subgradients and stored function values for the function with...">cb_reinit_function_model()</a>, <a class="el" href="group__cinterface.html#g3ef418836d555c0b55bd9f198109e61d" title="Returns the multipliers for the bound constraints on the design variables; in Lagrangean...">cb_get_approximate_slacks()</a>, and <a class="el" href="group__cinterface.html#ga6f318b3a93b7109393194cb9e2fa86d" title="Deletes variables corresponding to the specified indices.">cb_delete_variables()</a>.<p>
<div class="fragment"><pre class="fragment"><span class="comment">/******************************************************************************/</span>
<span class="comment">/*        Miniature Example in C for Convex Quadratic in Two Variables        */</span> 
<span class="comment">/******************************************************************************/</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "<a class="code" href="cb__cinterface_8h.html" title="Header declaring Interface to ConicBundle for language C.">cb_cinterface.h</a>"</span>

<span class="comment">/* f(x)=x^TAx+b^Tx+c with A=[5 1;1 4], b=[-12;-10], c=3 */</span>  
<span class="keywordtype">int</span> eval_fun( <span class="keywordtype">void</span>* function_key, <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> relprec, <span class="keywordtype">int</span> max_new_subg,
              <span class="keywordtype">double</span> *objective_value,
              <span class="keywordtype">int</span>* new_subg,<span class="keywordtype">double</span> *subgval,<span class="keywordtype">double</span> *subgradient,<span class="keywordtype">double</span> *primal)
{
  <span class="comment">/* compute objective */</span>
  *objective_value= 5*x[0]*x[0]+2*x[0]*x[1]+4*x[1]*x[1]-12*x[0]-10*x[1]+3;
  <span class="comment">/* compute and store one subgradient(=gradient) with two coordinates */</span>
  *new_subg=1;
  subgval[0]=*objective_value;
  subgradient[0]=2*(5*x[0]+x[1])-12;
  subgradient[1]=2*(x[0]+4*x[1])-10;
  <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
  <a class="code" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291" title="pointer to a ConicBundle problem">cb_problemp</a> p;
  <span class="keywordtype">double</span> x[2];

  p=<a class="code" href="group__cinterface.html#g807cf763dcc577a01ac76814b9c8a2bc" title="Creates a a new problem object and returns a pointer to it.">cb_construct_problem</a>(0);   <span class="comment">/* generate new problem */</span>
  <a class="code" href="group__cinterface.html#g2b579e5fc1a75e5bc3b61ec02c45a527" title="Initializes the problem by setting the design space (the dimension and possible box...">cb_init_problem</a>(p,2,0,0);    <span class="comment">/* 2 variables, no bounds */</span>
  <a class="code" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function</a>(p,(<span class="keywordtype">void</span> *)eval_fun,eval_fun,0,2);    
  <a class="code" href="group__cinterface.html#gfb3888ddf0640bef9fc5e460fc81a32e" title="Specifies the output level (&amp;lt;0 no output at all, =0 errors and warnings, &amp;gt;0...">cb_set_print_level</a>(p,1);

  <span class="keywordflow">do</span> {
    <a class="code" href="group__cinterface.html#g390943acb8988f251704a2ec0c6c5a70" title="Does a descent step for the current center point.">cb_do_descent_step</a>(p);
  } <span class="keywordflow">while</span> (!<a class="code" href="group__cinterface.html#ga3b07ae3eeadb1e39f92cf054f41abd1" title="Returns the termination code of the bundle algorithm for the latest descent step...">cb_termination_code</a>(p));

  <a class="code" href="group__cinterface.html#gcb69b4a3769e26ce8e72fadb68cf0b6b" title="Outputs a text version of termination code, see cb_termination_code().">cb_print_termination_code</a>(p);

  <a class="code" href="group__cinterface.html#g14ae01f65c97695217a9144638970eb6" title="Returns the next center point that was produced by the last call to cb_do_descent_step...">cb_get_center</a>(p,x);
  printf(<span class="stringliteral">"x0=%lf, x1=%lf, objval=%lf\n"</span>,x[0],x[1],<a class="code" href="group__cinterface.html#g6c2bc6d66d23d5a335d5694727797a31" title="Returns the objective value resulting from last descent step (initially undefined)...">cb_get_objval</a>(p));

  <a class="code" href="group__cinterface.html#g70f97962511ee09f1456e032061d2e30" title="Destructs and frees the problem object.">cb_destruct_problem</a>(&amp;p);

  <span class="keywordflow">return</span> 0;
}
</pre></div> <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g18f2ccf1c7f9b7ffa48807da08ee7f84"></a><!-- doxytag: member="cb_cinterface.h::cb_functionp" ref="g18f2ccf1c7f9b7ffa48807da08ee7f84" args=")(void *function_key, double *arg, double relprec, int max_subg, double *objective_value, int *n_subgrads, double *subg_values, double *subgradients, double *primal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__cinterface.html#g18f2ccf1c7f9b7ffa48807da08ee7f84">cb_functionp</a>)(void *function_key,double *arg,double relprec,int max_subg,double *objective_value,int *n_subgrads,double *subg_values,double *subgradients,double *primal)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function oracle; describe your function as a function of this type to pass it to the solver 
<p>
The oracle interface is used to describe a convex function. The dimension of the argument vector of the function must be set in <a class="el" href="group__cinterface.html#g2b579e5fc1a75e5bc3b61ec02c45a527" title="Initializes the problem by setting the design space (the dimension and possible box...">cb_init_problem()</a>, let it be m in the following.<p>
If the sum of several such functions is to be minimized, it is the task of the user to guarantee that all dimensions match.<p>
In many applications, computing the function value is an iterative process that approaches the true function value from below. The code offers a bound for the function value, above which it is certain that the code will reject the current point. If in the iterative process a lower bound on the function value exceeds this bound, then it is sufficient to return, instead of the true function value and a subgradient, the current lower bound and a vector so that together they describe a supporting hyperplane (an epsilon subgradient, lying completely below the function) to the function at this point.<p>
If the function corresponds to Lagrangean relaxation of a primal maximization problem one may want to generate a primal approximate solution. In this case, set in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a> the desired primal dimension. Then the solver will provide memory in primal for returning in the function the generating primal vectos for each subgradient. If the primal dimension is set to zero, primal will be NULL and no aggregation takes place.<p>
If primal aggregation is used then it is possible to implement a primal cutting plane framework. This requires the introduction of new (dual) variables in the design space of the function. In this case a function of type <a class="el" href="group__cinterface.html#g5359ea8b2c26c3111a763cac6813c29d" title="This routine is not needed unless variabls (constraints in Lagrangean relaxation)...">cb_subgextp</a> (see below) should be provided for filling in the missing coordinates in existing subgradients. This function need not be specified even if constraints are added, but then the cutting model of the objective is lost at each addition of constraints.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function_key</em>&nbsp;</td><td>void pointer supplied by the user on entering the function. May be useful if multiple copies of the same function are used with parameters</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>(pointer to double array of length m) argument of the function (e.g. the Lagrange multipliers)</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>relprec</em>&nbsp;</td><td>relative precision requirement for objective values that may lead to descent steps (this precision is not required if it is already certain that the function value will be too poor)</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>max_subg</em>&nbsp;</td><td>at most <em>max_subg</em> epsilon-<em>subgradients</em> and <em>subg_values</em> may be returned, but at least one must be returned!</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>objective_value</em>&nbsp;</td><td>(pointer to a double of the caller)<ul>
<li>on input: value gives the threshold for a null step; you may stop, if a cutting plane yields at least this;</li><li>on output: return an upper bound on the true function value within <em>relprec</em> *(abs(objval)+1.), if there is no hyperplane cutting above the threshold specified in objective_value on input. Otherwise the return value should be the max of subg_values.</li></ul>
</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>n_subgrads</em>&nbsp;</td><td>(pointer to an int of the caller) give the number of epsilon-<em>subgradients</em> returned</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>subg_values</em>&nbsp;</td><td>(pointer to double array of length <em>max_subg</em>, memory already provided by caller) store for each epsilon subgradient the value at the argument</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>subgradients</em>&nbsp;</td><td>(pointer to double array of length <em>max_subg</em> * m, memory already provided by caller) Format: s1y1,...,s1ym,s2y1,...,s2ym,... (siyj = coefficient of subgradient i at y-coordinate j)</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>primal</em>&nbsp;</td><td>(pointer to double array, may be NULL or memory of length n*max_subgalready provided by caller) If the function arises from Lagrangean relaxation and a primal approximation is desired then set the primal dimension in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a> and return the primal solutions corresponding to the eps-subgradients in the array pointed to by primal. Format: p1x1,..,p1xn,p2x1,...,p2xn,...</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0, all correct</li><li>!=0, failure. This does not necessarily terminate the bundle method. Termination is forced only if no new subgradient is returned. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g5359ea8b2c26c3111a763cac6813c29d"></a><!-- doxytag: member="cb_cinterface.h::cb_subgextp" ref="g5359ea8b2c26c3111a763cac6813c29d" args=")(void *function_key, double *generating_primal, int n_indices, int *variable_indices, double *new_subgradient_values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__cinterface.html#g5359ea8b2c26c3111a763cac6813c29d">cb_subgextp</a>)(void *function_key,double *generating_primal,int n_indices, int *variable_indices,double *new_subgradient_values)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine is not needed unless variabls (constraints in Lagrangean relaxation) are added on the fly. 
<p>
The solver calls this routine whenever new variables have been added on the fly in order to extend old subgradients to the new coordinates. If primal data was supplied for the subgradients then <em>generating_primal</em> holds a pointer to this (possibly aggregated) data, otherwise it is NULL.<p>
In the presence of primal data, the new coordinates correspond to the violation of the new primal constraints. These have to be returned in the array <em>new_subgradient_values</em>; more precisely, for i=0 to <em>n_indices-1</em> the element <em>new_subgradient_values</em>[i] has to hold the subgradient information of constraint <em>variable_indices</em>[i];<p>
If generating_primal is NULL, then the routine can only successfully extend the subgradients, if the new coordinates have no influence on the function; then the new subgradient coordinates are all zero and the components of <em>new_subgradient_values</em> have to be initialized to zero.<p>
If you do indeed need this, you have to provide one such function with each evaluation function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function_key</em>&nbsp;</td><td>void pointer supplied by the user on entering the function. May be useful if multiple copies of the same function are used with parameters</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>generating_primal</em>&nbsp;</td><td>(NULL or pointer to double array of primal length n) if not Null it holds the (possibly aggregated) primal solution that generated the subgradient that needs to be extendend</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n_indices</em>&nbsp;</td><td>(int) gives the number of indices for which the subgradient value has to be computed</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>variable_indices</em>&nbsp;</td><td>(pointer to int array of length <em>n_indices</em>) for the <em>y</em> variables with indices <em>variable_indices</em>[i], i=0,..,@ n_indices-1 the subgradient coefficient has to be computed</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>new_subgradient_values</em>&nbsp;</td><td>(pointer to double array of length n_indices provided by caller) store the the subgradient coefficient of <em>y</em> variable with index <em>variable_indices</em>[i] at <em>new_subgradient_values</em>[i] for i=0,..,@ n_indices-1</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success,</li><li>1 if extension is impossible </li></ul>
</dd></dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g96316b3769d671690ffddf3c0d98e7cc"></a><!-- doxytag: member="cb_cinterface.h::cb_add_function" ref="g96316b3769d671690ffddf3c0d98e7cc" args="(cb_problemp p, void *function_key, cb_functionp f, cb_subgextp se, int primaldim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_add_function           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>function_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g18f2ccf1c7f9b7ffa48807da08ee7f84">cb_functionp</a>&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g5359ea8b2c26c3111a763cac6813c29d">cb_subgextp</a>&nbsp;</td>
          <td class="paramname"> <em>se</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>primaldim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the function, the sum of which should be minimized, to the problem description. 
<p>
Each function added must be given a unique <em>function_key</em> (this may be the address of the function [if unique], an index, or some parameter information), <em>f</em> supplies the evaluation function and must not be zero, <em>se</em> can be used to specify a routine for extending subgradients, but it may be NULL. <em>primaldim</em> can be used if an approximate primal solution should be aggregated (In this case storage will be supplied in the call to the evaluation function for storing for each subgradient the generating primal vector). It may be zero if this is not needed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem to which the function should be added</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function_key</em>&nbsp;</td><td>(void *) The value of the funciton_key must UNIQUELY identify the function, (it may be the address of the funciton [if unique], or give the address of a struct holding additional user parameters)</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>f</em>&nbsp;</td><td>(cb_functionp) The pointer to the function</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>se</em>&nbsp;</td><td>(cb_subgextp) This parameter my be NULL, otherwise the respective function will be called in order to compute coefficients for new subgradient coordinates resulting from added variables.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>primaldim</em>&nbsp;</td><td>(int) May be zero, otherwise in each call to  enough store will provide to store a primal generating vector for each subgradient returned. The primal solutions will be aggregated along with the subgradients. This allows to generate approximate primal optimal solutions, e.g., in Lagrangean relaxation.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="gfdba8de5a1ebd0c2dc678997f2845e8f"></a><!-- doxytag: member="cb_cinterface.h::cb_append_variables" ref="gfdba8de5a1ebd0c2dc678997f2845e8f" args="(cb_problemp p, int n_append, double *lowerb, double *upperb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_append_variables           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n_append</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>lowerb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>upperb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append new variables (always in last postions in this order). 
<p>
If 0 is feasible for the new coordinates then this is selected as starting value for the new coordinates; otherwise, the number closest to zero is used. If all new coordinates can be set to zero then it is assumed that for an existing center point the function values need not be recomputed (this is e.g. the case in Lagrangean relaxation; if this is not correct call <a class="el" href="group__cinterface.html#g987d2a140fe4660ae228b20bee8320d8" title="Clears cutting model, subgradients and stored function values for the function with...">cb_reinit_function_model()</a> below). Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a class="el" href="group__cinterface.html#g390943acb8988f251704a2ec0c6c5a70" title="Does a descent step for the current center point.">cb_do_descent_step()</a>.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>Be sure to update your objective functions so that they can handle the new variables before you call this and any further <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual...">ConicBundle</a> routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n_append</em>&nbsp;</td><td>(int) number of variables to append (always in last position in the same order)</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lower_bound</em>&nbsp;</td><td>(NULL or pointer to double array of size <em>n_append</em>) If NULL, all appended variables are considered unbounded below, otherwise lowerb[i] gives the minimum feasible value for variable y[i], use <a class="el" href="group__cinterface.html#g7969bf339ee57ce667278104ad9adcf7" title="Returns the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are...">cb_get_minus_infinity()</a> for unbounded below.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>upper_bound</em>&nbsp;</td><td>(NULL or pointer to double array of size <em>n_append</em>) If NULL, all appended variables are considered unbounded above, otherwise lowerb[i] gives the minimum feasible value for variable y[i], use <a class="el" href="group__cinterface.html#g7889cf44af8cc62fbffa30f0143e1fb9" title="Returns the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are...">cb_get_plus_infinity()</a> for unbounded below.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g8b839895c52febec613647f425ebb9fd"></a><!-- doxytag: member="cb_cinterface.h::cb_clear" ref="g8b839895c52febec613647f425ebb9fd" args="(cb_problemp p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_clear           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears all data structures and problem information but keeps ouptut settings and algorithmic parameter settings. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the cureent problem </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g6374cbb172eac48e21c1838a74f4da0b"></a><!-- doxytag: member="cb_cinterface.h::cb_clear_fail_counts" ref="g6374cbb172eac48e21c1838a74f4da0b" args="(cb_problemp p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_clear_fail_counts           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
clears all fail counts on numerical function oder model failures, may be useful if this caused premature termination. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g807cf763dcc577a01ac76814b9c8a2bc"></a><!-- doxytag: member="cb_cinterface.h::cb_construct_problem" ref="g807cf763dcc577a01ac76814b9c8a2bc" args="(int no_bundle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> cb_construct_problem           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>no_bundle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a a new problem object and returns a pointer to it. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>no_bundle</em>&nbsp;</td><td>if nonzero, then the minimal bundle consisting of just one new and one aggregate gradient is used so that there is no real bundle available and bundle size options are then meaningless.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>==0, construction of problem object failed</li><li>!=0, pointer to the problem object </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="ga6f318b3a93b7109393194cb9e2fa86d"></a><!-- doxytag: member="cb_cinterface.h::cb_delete_variables" ref="ga6f318b3a93b7109393194cb9e2fa86d" args="(cb_problemp p, int n_del, int *delete_indices, int *map_to_old)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_delete_variables           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n_del</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>delete_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>map_to_old</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes variables corresponding to the specified indices. 
<p>
The indices of the remaining variables are reassigned so that they are consecutive again, the routine returns in <em>map_to_old</em> a vector giving for each new index of these remaining variables the old coordinate. The memory for <em>map_to_old</em> has to be provided by the caller, who has also to guarantee that it is long enough!<p>
If all of the deleted variables are zero, function values are assumed to remain correct (if this is not so, call <a class="el" href="group__cinterface.html#g987d2a140fe4660ae228b20bee8320d8" title="Clears cutting model, subgradients and stored function values for the function with...">cb_reinit_function_model()</a> below) Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a class="el" href="group__cinterface.html#g390943acb8988f251704a2ec0c6c5a70" title="Does a descent step for the current center point.">cb_do_descent_step()</a>.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>Be sure to update your objective functions so that they can handle the new variables before you call any further <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual...">ConicBundle</a> routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n_del</em>&nbsp;</td><td>(int) number of variables to be deleted</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>delete_indices</em>&nbsp;</td><td>(pointer to int array of length n_del) the entries delete_indices[i] with i=0,...,n_del-1 specify the indices of the variables to be deleted</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>map_to_old</em>&nbsp;</td><td>(pointer to int array of length <a class="el" href="group__cinterface.html#gcf08ea1cf2327669c3f4dcf455800238" title="Returns the current dimension of the design space/argument or -1 if no dimension...">cb_get_dim()</a>-<em>n_del</em> provided by the caller) after the call element map_to_old[i] gives the old index (before the call) of the variable that now has index position i.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g70f97962511ee09f1456e032061d2e30"></a><!-- doxytag: member="cb_cinterface.h::cb_destruct_problem" ref="g70f97962511ee09f1456e032061d2e30" args="(cb_problemp *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_destruct_problem           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructs and frees the problem object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp*) address of the main pointer to the problem that should be destructed. the problem pointer will be set to zero upon successful destruction</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0, all correct</li><li>&gt;0, failure </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g390943acb8988f251704a2ec0c6c5a70"></a><!-- doxytag: member="cb_cinterface.h::cb_do_descent_step" ref="g390943acb8988f251704a2ec0c6c5a70" args="(cb_problemp p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_do_descent_step           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does a descent step for the current center point. 
<p>
A descent step may consist of several function evaluations (null steps), that lead to no immediate progress but serve for building a cutting model of the objective function close to the current center point. A minimizer to the model is accepted as descent step if the function value at this point satisfies a sufficient decrease criterion in comparison to the decrease predicted by the model. Having found a descent step, the next center is automatically shifted to this successful candidate. Termination criteria may stop the process of seeking for a descent step, in which case the current center is kept and the routine <a class="el" href="group__cinterface.html#ga3b07ae3eeadb1e39f92cf054f41abd1" title="Returns the termination code of the bundle algorithm for the latest descent step...">cb_termination_code()</a> returns the termination code.<p>
Restarting, after each descent step, the bundle method from scratch with the new center as starting point does not endanger convergence. Therefore, a descent step is the smallest unit, after which user interaction can take place.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g09541e032eac1a90fbbcceb25bd4c0da"></a><!-- doxytag: member="cb_cinterface.h::cb_do_maxsteps" ref="g09541e032eac1a90fbbcceb25bd4c0da" args="(cb_problemp p, int maxsteps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_do_maxsteps           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxsteps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does a descent step for the current center point but also returns after at most maxstep null steps. 
<p>
A descent step may consist of several function evaluations (null steps), that lead to no immediate progress but serve for building a cutting model of the objective function close to the current center point. A minimizer to the model is accepted as descent step if the function value at this point satisfies a sufficient decrease criterion in comparison to the decrease predicted by the model. Having found a descent step, the next center is automatically shifted to this successful candidate. Termination criteria may stop the process of seeking for a descent step, in which case the current center is kept and the routine <a class="el" href="group__cinterface.html#ga3b07ae3eeadb1e39f92cf054f41abd1" title="Returns the termination code of the bundle algorithm for the latest descent step...">cb_termination_code()</a> returns the termination code.<p>
Restarting, after each descent step, the bundle method from scratch with the new center as starting point does not endanger convergence. Therefore, a descent step is the smallest unit, after which user interaction can take place safely and this is the default choice when maxsteps is set to zero.<p>
If you know what your are doing, you may also use the input parameter maxsteps to force the algorithm to return after at most maxsteps null steps. Calling <a class="el" href="group__cinterface.html#g09541e032eac1a90fbbcceb25bd4c0da" title="Does a descent step for the current center point but also returns after at most maxstep...">cb_do_maxsteps()</a> again without any intermediate problem configurations will then simply continue the process where it stopped and convergence is save. During null steps one may not decrease the weight or delete nonzero variables of the center or the current candidate!<p>
In a Lagrangean relaxation cutting plane approach one may want to separate and enlarge the dimension after a certain number of null steps. In this case the code will try to preserve the model, given appropriate subgradient extension routines have been provided. If the model cannot be extended, it has to be discarded (if subgradient extension is not successful this is done automatically), and the algorithm will be restarted from the current center point.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>so far maxsteps is only implemented for the "NoBundle" version, otherwise it behaves like <a class="el" href="group__cinterface.html#g390943acb8988f251704a2ec0c6c5a70" title="Does a descent step for the current center point.">cb_do_descent_step()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxsteps</em>&nbsp;</td><td>(int) if maxsteps&gt;0 the code returns after at most so many null steps</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="ga90b115b43f88c12036f0a2852fc2204"></a><!-- doxytag: member="cb_cinterface.h::cb_get_active_bounds_indicator" ref="ga90b115b43f88c12036f0a2852fc2204" args="(cb_problemp p, int *indicator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_active_bounds_indicator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>indicator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the indicator vector of variables temporarily fixed to the center value due to significantly positive multipliers for the box constraints, see <a class="el" href="group__cinterface.html#g4a51b181c4a0488a950edb196e8984f8" title="If set to true (the default is false), some variables will be fixed automatically...">cb_set_active_bounds_fixing()</a>. 
<p>
Such a fixing indicates that the corresponding variables would like to stay at their bounds. If no variables were fixed, the dimension of the vector is zero.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>indicator</em>&nbsp;</td><td>(pointer to int array of length <a class="el" href="group__cinterface.html#gcf08ea1cf2327669c3f4dcf455800238" title="Returns the current dimension of the design space/argument or -1 if no dimension...">cb_get_dim()</a> @ provided by caller) indicator[i] will be 1 if the variable i was fixed to the bound and 0 otherwise</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g32cd4b02ba0eac656f5970f64daf68c3"></a><!-- doxytag: member="cb_cinterface.h::cb_get_approximate_primal" ref="g32cd4b02ba0eac656f5970f64daf68c3" args="(cb_problemp p, void *function_key, double *primal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_approximate_primal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>function_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>primal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current approximate primal solution for the function having this <em>function_key</em>. 
<p>
The <em>function_key</em> must match the one specified in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a>. Likewise, the routine is meaningful only if  was set in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a> and primal vectors were returned along with the subgradients in all calls to cb_functionp with this <em>function_key</em>. In this case it returns the current approximate primal solution aggregated alongside with the aggregate subgradient. A primal solution may not be available after addition of constraints, if extension of the aggregate subgradient to the new coordinates failed.<p>
If no primal dimension was set for this function, the routine does nothing.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function_key</em>&nbsp;</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>primal</em>&nbsp;</td><td>(pointer to double array of length @ primaldim provided by caller) primal[i] will be filled with the coordinate value i</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g3ef418836d555c0b55bd9f198109e61d"></a><!-- doxytag: member="cb_cinterface.h::cb_get_approximate_slacks" ref="g3ef418836d555c0b55bd9f198109e61d" args="(cb_problemp p, double *slacks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_approximate_slacks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>slacks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the multipliers for the bound constraints on the design variables; in Lagrangean relaxation they may be interpreted as primal slacks for inequality constraints. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>slacks</em>&nbsp;</td><td>(pointer to double array of length <a class="el" href="group__cinterface.html#gcf08ea1cf2327669c3f4dcf455800238" title="Returns the current dimension of the design space/argument or -1 if no dimension...">cb_get_dim()</a> provided by caller) slacks[i] will be filled with the coordinate value i</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g23d072bda788a0cd827cc506175bd740"></a><!-- doxytag: member="cb_cinterface.h::cb_get_bundle_parameters" ref="g23d072bda788a0cd827cc506175bd740" args="(cb_problemp p, void *function_key, int *max_bundlesize, int *max_new_subgradients)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_bundle_parameters           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>function_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>max_bundlesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>max_new_subgradients</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the two bundle parameters specified in the routines <a class="el" href="group__cinterface.html#gb9e6845864cff4362f0401658062461c" title="Sets the maximum number of subgradients used in forming the cutting model of the...">cb_set_max_bundlesize()</a> and <a class="el" href="group__cinterface.html#gaf987af753c04154797c76bdae54e595" title="Sets the maximum number of epsilon subgradients that can be returned in one call...">cb_set_max_new_subgradients()</a>. for the function having this <em>function_key</em>. 
<p>
The <em>function_key</em> must match the one specified in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function_key</em>&nbsp;</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>bundlesize</em>&nbsp;</td><td>(pointer to int) returns the maximum number of subgradients to be used in forming the cutting model</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>max_new_subg</em>&nbsp;</td><td>(pointer to int) returns maximum number of new epsilon subgradients to be returned in an evaluation call to the function</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g8f2f4da68fe1e00801754ed2b14de20e"></a><!-- doxytag: member="cb_cinterface.h::cb_get_bundle_values" ref="g8f2f4da68fe1e00801754ed2b14de20e" args="(cb_problemp p, void *function_key, int *bundlesize, int *new_subgradients)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_bundle_values           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>function_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>bundlesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>new_subgradients</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns, for the function having this <em>function_key</em>, the current number of subgradients in use in the cutting model and the number of epsilon subgradients returned in the latest evaluation call to the function. 
<p>
The <em>function_key</em> must match the one specified in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function_key</em>&nbsp;</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>bundlesize</em>&nbsp;</td><td>(pointer to int) returns the current number of subgradients used in forming the cutting model</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>max_new_subg</em>&nbsp;</td><td>(pointer to int) returns the current number of epsilon subgradients returned in the latest evaluation call to the function</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g61d22658a33503ff35b5972e10cf6651"></a><!-- doxytag: member="cb_cinterface.h::cb_get_candidate" ref="g61d22658a33503ff35b5972e10cf6651" args="(cb_problemp p, double *candidate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_candidate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>candidate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the last point, the "candidate", at which the function was evaluated in <a class="el" href="group__cinterface.html#g390943acb8988f251704a2ec0c6c5a70" title="Does a descent step for the current center point.">cb_do_descent_step()</a>. 
<p>
If this evaluation lead to a descent step, it is the same point as in <a class="el" href="group__cinterface.html#g14ae01f65c97695217a9144638970eb6" title="Returns the next center point that was produced by the last call to cb_do_descent_step...">cb_get_center()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>candidate</em>&nbsp;</td><td>(pointer to double array of length <a class="el" href="group__cinterface.html#gcf08ea1cf2327669c3f4dcf455800238" title="Returns the current dimension of the design space/argument or -1 if no dimension...">cb_get_dim()</a> provided by caller) center[i] will be the value of design variable y_i of the point</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g20b777b524d15f9e4efd6cc931766eee"></a><!-- doxytag: member="cb_cinterface.h::cb_get_candidate_primal" ref="g20b777b524d15f9e4efd6cc931766eee" args="(cb_problemp p, void *function_key, double *primal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_candidate_primal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>function_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>primal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the best primal solution returned by the last evaluation of the function having this <em>function_key</em> in the point <a class="el" href="group__cinterface.html#g61d22658a33503ff35b5972e10cf6651" title="Returns the last point, the &quot;candidate&quot;, at which the function was evaluated...">cb_get_candidate()</a>. 
<p>
The <em>function_key</em> must match the one specified in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a>. Likewise, the routine is meaningful only if  was set in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a> and primal vectors were returned along with the subgradients in calls to cb_functionp with this <em>function_key</em>. If no primal dimension was set for this function, the routine does nothing.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function_key</em>&nbsp;</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>primal</em>&nbsp;</td><td>(pointer to double array of length @ primaldim provided by caller) primal[i] will be filled with the coordinate value i</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g95296a6cd39a49c689bc6179653805a0"></a><!-- doxytag: member="cb_cinterface.h::cb_get_candidate_value" ref="g95296a6cd39a49c689bc6179653805a0" args="(cb_problemp p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cb_get_candidate_value           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the objective value computed in the last step of do_descent_step(), independent of whether this was a descent step or a null step (initially undefined). 
<p>
If no problem modification routines were called since then, it is the objective value at the point returned by <a class="el" href="group__cinterface.html#g61d22658a33503ff35b5972e10cf6651" title="Returns the last point, the &quot;candidate&quot;, at which the function was evaluated...">cb_get_candidate()</a>. If this last evaluation led to a descent step, then it is the same value as in get_objval(). 
</div>
</div><p>
<a class="anchor" name="g14ae01f65c97695217a9144638970eb6"></a><!-- doxytag: member="cb_cinterface.h::cb_get_center" ref="g14ae01f65c97695217a9144638970eb6" args="(cb_problemp p, double *center)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_center           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>center</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the next center point that was produced by the last call to cb_do_descent_step (in some problem modification routines the center point may be updated immediately, in others the center point will be corrected automatically directly before starting the next descent step and its values may be infeasible till then). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>center</em>&nbsp;</td><td>(pointer to double array of length <a class="el" href="group__cinterface.html#gcf08ea1cf2327669c3f4dcf455800238" title="Returns the current dimension of the design space/argument or -1 if no dimension...">cb_get_dim()</a> provided by caller) center[i] will be the value of design variable y_i in the next center point (mostly the result of the latest descent step)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g499088981d7a12f5f86c8cac6e8000c7"></a><!-- doxytag: member="cb_cinterface.h::cb_get_center_primal" ref="g499088981d7a12f5f86c8cac6e8000c7" args="(cb_problemp p, void *function_key, double *primal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_center_primal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>function_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>primal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the best primal solution obtained in the current center point in evaluating the function having this <em>function_key</em>. 
<p>
The <em>function_key</em> must match the one specified in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a>. Likewise, the routine is meaningful only if  was set in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a> and primal vectors were returned along with the subgradients in calls to cb_functionp with this <em>function_key</em>. If no primal dimension was set for this function, the routine does nothing.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function_key</em>&nbsp;</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>primal</em>&nbsp;</td><td>(pointer to double array of length @ primaldim provided by caller) primal[i] will be filled with the coordinate value i</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="ge5043cc3bcf11c4e5df41563da73d524"></a><!-- doxytag: member="cb_cinterface.h::cb_get_function_status" ref="ge5043cc3bcf11c4e5df41563da73d524" args="(cb_problemp p, void *function_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_function_status           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>function_key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the return value of the latest evaluation call to the function with this <em>function_key</em>. 
<p>
Remember, a unique <em>function_key</em> must be specified in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function_key</em>&nbsp;</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>return value of latest call to the function having this <em>function_key</em> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g42edf299547b8b9c232ea26ee3b3a923"></a><!-- doxytag: member="cb_cinterface.h::cb_get_last_weight" ref="g42edf299547b8b9c232ea26ee3b3a923" args="(cb_problemp p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cb_get_last_weight           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current weight for the quadratic term in the augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>double weight value </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6c2bc6d66d23d5a335d5694727797a31"></a><!-- doxytag: member="cb_cinterface.h::cb_get_objval" ref="g6c2bc6d66d23d5a335d5694727797a31" args="(cb_problemp p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cb_get_objval           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the objective value resulting from last descent step (initially undefined). 
<p>
If no problem modification routines were called since then, it is the objective value at the point returned by <a class="el" href="group__cinterface.html#g14ae01f65c97695217a9144638970eb6" title="Returns the next center point that was produced by the last call to cb_do_descent_step...">cb_get_center()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>double objective value </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6726b5f928d838ad359cbb69fdc5e0b0"></a><!-- doxytag: member="cb_cinterface.h::cb_get_sgnorm" ref="g6726b5f928d838ad359cbb69fdc5e0b0" args="(cb_problemp p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cb_get_sgnorm           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns Euclidean norm of the latest aggregate subgradient. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>norm of the latest aggregate subgradient </dd></dl>

</div>
</div><p>
<a class="anchor" name="g896e34b83c271271169057668f1c44c7"></a><!-- doxytag: member="cb_cinterface.h::cb_get_subgradient" ref="g896e34b83c271271169057668f1c44c7" args="(cb_problemp p, double *subgradient)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_get_subgradient           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>subgradient</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the latest aggregate subgradient. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>subgradient</em>&nbsp;</td><td>(pointer to double array of length <a class="el" href="group__cinterface.html#gcf08ea1cf2327669c3f4dcf455800238" title="Returns the current dimension of the design space/argument or -1 if no dimension...">cb_get_dim()</a> provided by caller) subgradient[i] will be filled with the coordinate value i</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g2b579e5fc1a75e5bc3b61ec02c45a527"></a><!-- doxytag: member="cb_cinterface.h::cb_init_problem" ref="g2b579e5fc1a75e5bc3b61ec02c45a527" args="(cb_problemp p, int m, double *lowerb, double *upperb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_init_problem           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>lowerb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>upperb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the problem by setting the design space (the dimension and possible box constraints of the variables). 
<p>
Clears all data structures and sets the dimension @ m for a new problem. for solving min_{y in R^m} f_0(y) + f_1(y) + ... Box constraints may be specified for y, the functions f_i must be added by <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a>.<p>
Lower and/or upper bounds must be speicified for all variables or for none of them. To specify no bounds at all, give Null pointers. Otherwise use <a class="el" href="group__cinterface.html#g7969bf339ee57ce667278104ad9adcf7" title="Returns the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are...">cb_get_minus_infinity()</a> for unbounded below and <a class="el" href="group__cinterface.html#g7889cf44af8cc62fbffa30f0143e1fb9" title="Returns the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are...">cb_get_plus_infinity()</a> for unbounded above. For NULL pointers, unbounded will be used as default for all variables. Specifying bounds selectively is also possible by <a class="el" href="group__cinterface.html#gfc6ea382c7f9352615238d8913f8fbee" title="set lower bound for variable i, use cb_get_minus_infinity() for unbounded from below...">cb_set_lower_bound()</a> or <a class="el" href="group__cinterface.html#g490345cc46c2a3cdd32741fe27234ee5" title="set upper bound for variable i, use cb_get_plus_infinity() for unbounded above.">cb_set_upper_bound()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the current problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>(int) the dimension of the argument/design space/the number of Lagrange multipliers</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lowerb</em>&nbsp;</td><td>(either pointer to double array of length  or NULL) If NULL, all variables are considered unbounded below, otherwise lowerb[i] gives the minimum feasible value for variable y[i], use <a class="el" href="group__cinterface.html#g7969bf339ee57ce667278104ad9adcf7" title="Returns the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are...">cb_get_minus_infinity()</a> for unbounded below.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>upperb</em>&nbsp;</td><td>(either pointer to double array of length  or NULL) If NULL, all variables are considered unbounded above, otherwise upperb[i] gives the maximum feasible value for variable y[i], use <a class="el" href="group__cinterface.html#g7889cf44af8cc62fbffa30f0143e1fb9" title="Returns the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are...">cb_get_plus_infinity()</a> for unbounded above.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="gcb69b4a3769e26ce8e72fadb68cf0b6b"></a><!-- doxytag: member="cb_cinterface.h::cb_print_termination_code" ref="gcb69b4a3769e26ce8e72fadb68cf0b6b" args="(cb_problemp p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_print_termination_code           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Outputs a text version of termination code, see <a class="el" href="group__cinterface.html#ga3b07ae3eeadb1e39f92cf054f41abd1" title="Returns the termination code of the bundle algorithm for the latest descent step...">cb_termination_code()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g175ef1a2e40596de40cb8e62d451d20e"></a><!-- doxytag: member="cb_cinterface.h::cb_reassign_variables" ref="g175ef1a2e40596de40cb8e62d451d20e" args="(cb_problemp p, int n_assign, int *assign_new_from_old)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_reassign_variables           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n_assign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>assign_new_from_old</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reassigns variables to new index positions by mapping to position <em>i</em> the variable that previously had index <em>assign_new_from_old</em>[i]. 
<p>
Old variables, that are not mapped to any position will be deleted. It is allowed to generate several copies of old variables.<p>
If all of the deleted variables as well as new multiple copies are zero, function values are assumed to remain correct (if this is not so, call <a class="el" href="group__cinterface.html#g987d2a140fe4660ae228b20bee8320d8" title="Clears cutting model, subgradients and stored function values for the function with...">cb_reinit_function_model()</a> below). Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a class="el" href="group__cinterface.html#g390943acb8988f251704a2ec0c6c5a70" title="Does a descent step for the current center point.">cb_do_descent_step()</a>.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>Be sure to update your objective functions so that they can handle the new variables before you call any further <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual...">ConicBundle</a> routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n_assign</em>&nbsp;</td><td>(int) number of variables after reassignment</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>assign_new_from_old</em>&nbsp;</td><td>(pointer to int array of length <em>n_assign</em>) entry assign_new_from_old[i] with i=0,...,<em>n_assign-1</em> specifies the old index of the variable, that has to be copied to index position i.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g987d2a140fe4660ae228b20bee8320d8"></a><!-- doxytag: member="cb_cinterface.h::cb_reinit_function_model" ref="g987d2a140fe4660ae228b20bee8320d8" args="(cb_problemp p, void *function_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_reinit_function_model           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>function_key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears cutting model, subgradients and stored function values for the function with this <em>function_key</em>. 
<p>
This has to be called whenever the specified function was modified so that the old subgradients and/or primal generators are no longer valid.<p>
The <em>function_key</em> must match the one specified in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function_key</em>&nbsp;</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g4a51b181c4a0488a950edb196e8984f8"></a><!-- doxytag: member="cb_cinterface.h::cb_set_active_bounds_fixing" ref="g4a51b181c4a0488a950edb196e8984f8" args="(cb_problemp p, int allow_fixing)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_set_active_bounds_fixing           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>allow_fixing</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If set to true (the default is false), some variables will be fixed automatically to the center value if their bounds are strongly active (i.e., the corresponding multipliers are big). 
<p>
The coordinates to be fixed are redetermined in each call following a descent step or a change of the function. An indicator vector of the variables fixed in the last call can be obtained via the routine <a class="el" href="group__cinterface.html#ga90b115b43f88c12036f0a2852fc2204" title="Returns the indicator vector of variables temporarily fixed to the center value due...">cb_get_active_bounds_indicator()</a>.<p>
Setting this value to true might improve the performance of the algorithm in some instances but there is no convergence theory. It might be particularly helpful within Lagrangian relaxation if a primal cutting plane approach is used and non-tight inequalities should be eliminated quickly (fixing then indicates large primal slack values).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>allow_fixing</em>&nbsp;</td><td>(0 or 1) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gd6c1f335e1b8ab61bb854665a03a45f0"></a><!-- doxytag: member="cb_cinterface.h::cb_set_defaults" ref="gd6c1f335e1b8ab61bb854665a03a45f0" args="(cb_problemp p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_set_defaults           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets default values for algorithmic parameters that are not function specific (e.g., relative precision, weight and weight bounds for the augmentedproblem, etc.). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the cureent problem </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g78da3da3e172d97d3ce16f151c91da8d"></a><!-- doxytag: member="cb_cinterface.h::cb_set_eval_limit" ref="g78da3da3e172d97d3ce16f151c91da8d" args="(cb_problemp p, int eval_limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_set_eval_limit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>eval_limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets an upper bound on the number of calls to the oracle (use negative numbers for no limit). 
<p>
If this number is reached, the algorithm will terminate independently of whether the last step was a descent or a null step. A negative number will be interepreted as no limit.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>eval_limit</em>&nbsp;</td><td>(int) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g875c9bcc1eb3028c633c0b31415dc01c"></a><!-- doxytag: member="cb_cinterface.h::cb_set_inner_update_limit" ref="g875c9bcc1eb3028c633c0b31415dc01c" args="(cb_problemp p, int update_limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_set_inner_update_limit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>update_limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set an upper bound on the number of inner updates for the cutting model with primal slacks within one null step (use negative numbers for no limit). 
<p>
A negative number will be interepreted as no limit, i.e., the updates will be done till a certain precision of the cutting model is achieved.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>update_limit</em>&nbsp;</td><td>(int) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gfc6ea382c7f9352615238d8913f8fbee"></a><!-- doxytag: member="cb_cinterface.h::cb_set_lower_bound" ref="gfc6ea382c7f9352615238d8913f8fbee" args="(cb_problemp p, int i, double lower_bound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_lower_bound           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>lower_bound</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set lower bound for variable i, use <a class="el" href="group__cinterface.html#g7969bf339ee57ce667278104ad9adcf7" title="Returns the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value are...">cb_get_minus_infinity()</a> for unbounded from below. 
<p>
The algorithm may have to adapt the center point aftwards. In this case the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a class="el" href="group__cinterface.html#g390943acb8988f251704a2ec0c6c5a70" title="Does a descent step for the current center point.">cb_do_descent_step()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i</em>&nbsp;</td><td>(int) index of the variable</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lower_bound</em>&nbsp;</td><td>(double) value of the lower bound on variable <em>i</em> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="gb9e6845864cff4362f0401658062461c"></a><!-- doxytag: member="cb_cinterface.h::cb_set_max_bundlesize" ref="gb9e6845864cff4362f0401658062461c" args="(cb_problemp p, void *function_key, int bundlesize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_max_bundlesize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>function_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bundlesize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the maximum number of subgradients used in forming the cutting model of the function having this <em>function_key</em>. 
<p>
The <em>function_key</em> must match the one specified in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a>.<p>
Quite often a very small model, e.g., 2, yields very fast iterations and good progress in time (sometimes at the cost of more evaluations). By limited numerical experience, a significant reduction in the number of evaluations can only be expected if the bundle is large enough to wrap the function rather tightly. Quite frequently, unfortunately, this entails that solving the quadratic subproblems is more expensive than function evaluation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function_key</em>&nbsp;</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bundlesize</em>&nbsp;</td><td>(int) maximum number of subgradients to be used in forming the cutting model</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="gaf987af753c04154797c76bdae54e595"></a><!-- doxytag: member="cb_cinterface.h::cb_set_max_new_subgradients" ref="gaf987af753c04154797c76bdae54e595" args="(cb_problemp p, void *function_key, int max_new_subg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_max_new_subgradients           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>function_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_new_subg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the maximum number of epsilon subgradients that can be returned in one call to the function having this <em>function_key</em>. 
<p>
The <em>function_key</em> must match the one specified in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a>.<p>
The parameter <em>max_new_subg</em> corresponds directly to the parameter <em>max_subg</em> in <a class="el" href="group__cinterface.html#g18f2ccf1c7f9b7ffa48807da08ee7f84" title="function oracle; describe your function as a function of this type to pass it to...">cb_functionp</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function_key</em>&nbsp;</td><td>(void *) unique identifier as set in <a class="el" href="group__cinterface.html#g96316b3769d671690ffddf3c0d98e7cc" title="Adds the function, the sum of which should be minimized, to the problem description...">cb_add_function()</a></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>max_new_subg</em>&nbsp;</td><td>(int) maximum number of new epsilon subgradients to be returned in an evaluation call to the function</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="gb7940fa588317bdd3837bb448871a66e"></a><!-- doxytag: member="cb_cinterface.h::cb_set_max_weight" ref="gb7940fa588317bdd3837bb448871a66e" args="(cb_problemp p, double max_weight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_max_weight           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>max_weight</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets an upper bound on the weight for the quadratic term of the augmented subproblem. 
<p>
Nonpositive values indicate no bound. The new value shows its effect only at first dynamic change of the weight.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>max_weight</em>&nbsp;</td><td>(double)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g2a68aaafcf76054d085266b009f4cd4c"></a><!-- doxytag: member="cb_cinterface.h::cb_set_min_weight" ref="g2a68aaafcf76054d085266b009f4cd4c" args="(cb_problemp p, double min_weight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_min_weight           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>min_weight</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a lower bound on the weight for the quadratic term of the augmented subproblem. 
<p>
Nonpositive values indicate no bound. The new value shows its effect only at first dynamic change of the weight.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_weight</em>&nbsp;</td><td>(double)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g45bdcc8c58aa94a1b8231bf38f1d8097"></a><!-- doxytag: member="cb_cinterface.h::cb_set_new_center_point" ref="g45bdcc8c58aa94a1b8231bf38f1d8097" args="(cb_problemp p, double *center)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_new_center_point           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>center</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the starting point/center that will be used in the next call to <a class="el" href="group__cinterface.html#g390943acb8988f251704a2ec0c6c5a70" title="Does a descent step for the current center point.">cb_do_descent_step()</a>. Each call to this routine causes an immediate evaluation of all oracles. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center</em>&nbsp;</td><td>(pointer to double array of length <a class="el" href="group__cinterface.html#gcf08ea1cf2327669c3f4dcf455800238" title="Returns the current dimension of the design space/argument or -1 if no dimension...">cb_get_dim()</a>) center[i] holds the value of design variable y_i</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g412e288c208f049f49024e51198d3e4b"></a><!-- doxytag: member="cb_cinterface.h::cb_set_next_weight" ref="g412e288c208f049f49024e51198d3e4b" args="(cb_problemp p, double weight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_next_weight           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>weight</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the weight (&gt;0) to be used in the quadratic term of the next augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius). 
<p>
Independent of whether the weight violates current min- and max-bounds set in <a class="el" href="group__cinterface.html#g2a68aaafcf76054d085266b009f4cd4c" title="Sets a lower bound on the weight for the quadratic term of the augmented subproblem...">cb_set_min_weight()</a> and <a class="el" href="group__cinterface.html#gb7940fa588317bdd3837bb448871a66e" title="Sets an upper bound on the weight for the quadratic term of the augmented subproblem...">cb_set_max_weight()</a>, the next model will be computed for this value. Thereafter, however, it will be updated as usual; in particular, it may be truncated by min and max bounds immediately after the first subproblem.<p>
In order to guarantee a constant weight (e.g. 1 is frequently a reasonable choice if the automatic default heuristic performs poorly), set the min and max bounds to the same value, too.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>weight</em>&nbsp;</td><td>(double)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="gfb3888ddf0640bef9fc5e460fc81a32e"></a><!-- doxytag: member="cb_cinterface.h::cb_set_print_level" ref="gfb3888ddf0640bef9fc5e460fc81a32e" args="(cb_problemp p, int pril)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_set_print_level           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pril</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specifies the output level (&lt;0 no output at all, =0 errors and warnings, &gt;0 increasingly detailed information). 
<p>
Output levels:<ul>
<li>&lt;0 ... no output, not even errors or warnings</li><li>0 ... no output except for errors and warnings</li><li>1 ... line summary after each descent step</li><li>&gt;1 ... undocumented and increasingly detailed log information. These higher levels should only be used if requested for debugging purposes.</li></ul>
<p>
Example for level 1:<p>
<div class="fragment"><pre class="fragment">
00:00:00.00 endit  1   1   1   563.    563.  39041.188  39043.162
00:00:00.00 endit  2   2   2   563.    559.  38488.165  38490.200
00:00:00.00 endit  3   3   3   56.3    555.  33014.533  33211.856
00:00:00.00 endit  4   4   4   5.63    517. -14306.459  2738.0343
00:00:00.00 endit  5   5   5   4.04    148. -2692.1131  2.2150883
00:00:00.00 endit  6   6   6   4.01    1.29  1.7908952  2.0000581
00:00:00.00 endit  7   7   7   3.95  0.0213  1.9999387  2.0000000
00:00:00.00 _endit  8   8   8   3.95 2.94e-05  2.0000000  2.0000000

Column 1      2     3   4   5    6       7       8          9
</pre></div><ul>
<li>Column 1: computation time in hh:mm:ss.dd,</li><li>Column 2: "endit" is convenient for grep and stands for "end of iteration". Iterations with <a class="el" href="group__cinterface.html#ga3b07ae3eeadb1e39f92cf054f41abd1" title="Returns the termination code of the bundle algorithm for the latest descent step...">cb_termination_code()</a>!=0 are marked with "_endit".</li><li>Column 3: number of descent steps (= calls to <a class="el" href="group__cinterface.html#g390943acb8988f251704a2ec0c6c5a70" title="Does a descent step for the current center point.">cb_do_descent_step()</a>)</li><li>Column 4: number of descent and null steps. Up to initialization calls and reevaluations, this is the number of evaluation calls to the function oracles from within the bundle method. In the example all calls led to descent steps.</li><li>Column 5: number of innermost iterations. It differs from column 5 only in the case of variables with bounds in which case it gives the number of updates of the multipliers for the bounds (or primal slacks in Lagrangean relaxation). Exceedingly high numbers in this column indicate that some variables are constantly at their bounds and it might be possible to improve convergence by deleting them (i.e. set them as constants to this bound and remove the variable).</li><li>Column 6: the weight of the quadratic term in the augmented problem.</li><li>Column 7: the norm of the aggregate subgradient. If it is small, say below 0.1, then mostly this is good indication that the objective value is close to optimal.</li><li>Column 8: the value of the cutting model in the last candidate point. It is always a lower bound on the true function value in this point</li><li>Column 9: the objective value in the latest point that led to a descent step, i.e., the point returend by <a class="el" href="group__cinterface.html#g14ae01f65c97695217a9144638970eb6" title="Returns the next center point that was produced by the last call to cb_do_descent_step...">cb_get_center()</a>. Whenever <a class="el" href="group__cinterface.html#ga3b07ae3eeadb1e39f92cf054f41abd1" title="Returns the termination code of the bundle algorithm for the latest descent step...">cb_termination_code()</a> returns 0 this is also the objective value of the latest evaluation call to the function oracles and the value in the center point of the next iteration.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pril</em>&nbsp;</td><td>(int) print level </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g65b10cf79c9523c122369a37ad4eee67"></a><!-- doxytag: member="cb_cinterface.h::cb_set_term_relprec" ref="g65b10cf79c9523c122369a37ad4eee67" args="(cb_problemp p, double term_relprec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_term_relprec           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>term_relprec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the relative precision requirements for successful termination (default 1e-5). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>term_relprec</em>&nbsp;</td><td>(double) The algorithm stops with termination code 1, if predicted progress for the next step is less than term_relprec times absolute function value plus one.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g490345cc46c2a3cdd32741fe27234ee5"></a><!-- doxytag: member="cb_cinterface.h::cb_set_upper_bound" ref="g490345cc46c2a3cdd32741fe27234ee5" args="(cb_problemp p, int i, double upper_bound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_set_upper_bound           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>upper_bound</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set upper bound for variable i, use <a class="el" href="group__cinterface.html#g7889cf44af8cc62fbffa30f0143e1fb9" title="Returns the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value are...">cb_get_plus_infinity()</a> for unbounded above. 
<p>
The algorithm may have to adapt the center point aftwards. In this case the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a class="el" href="group__cinterface.html#g390943acb8988f251704a2ec0c6c5a70" title="Does a descent step for the current center point.">cb_do_descent_step()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>(cb_problemp) pointer to the problem</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>i</em>&nbsp;</td><td>(int) index of the variable</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>upper_bound</em>&nbsp;</td><td>(double) value of the upper bound on variable <em>i</em> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="ga3b07ae3eeadb1e39f92cf054f41abd1"></a><!-- doxytag: member="cb_cinterface.h::cb_termination_code" ref="ga3b07ae3eeadb1e39f92cf054f41abd1" args="(cb_problemp p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cb_termination_code           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#g3db3fcd0373ad6168ac6a75f9f2f4291">cb_problemp</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the termination code of the bundle algorithm for the latest descent step. 
<p>
For resetting all counters relevant for termination see <a class="el" href="group__cinterface.html#g6374cbb172eac48e21c1838a74f4da0b" title="clears all fail counts on numerical function oder model failures, may be useful if...">cb_clear_fail_counts()</a> .<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 : Not terminated. (Continue with the next <a class="el" href="group__cinterface.html#g390943acb8988f251704a2ec0c6c5a70" title="Does a descent step for the current center point.">cb_do_descent_step()</a>)</li><li>1 : Relative precision criterion satisfied. (See <a class="el" href="group__cinterface.html#g65b10cf79c9523c122369a37ad4eee67" title="Sets the relative precision requirements for successful termination (default 1e-5)...">cb_set_term_relprec()</a>)</li><li>2 : Timelimit exceeded. (Currently the C interface does not offer a timelimit.)</li><li>4 : Maximum number of function reevaluations exceeded. (Indicates that there is a problem with one of the function oracles that seems to deliver no valid upper bounds on the true function value for descent steps)</li><li>8 : Maximum number of quadratic subproblem failures exceeded. (Indicates that the numerical limits of the inner quadratic programming solver are reached, no further progress expected)</li><li>16 : maximum number of model evaluation failures exceeded (Indicates that the numerical limits of the setup of the subproblem are reached, no further progress expected)</li><li>32 : maximum number of failures to increase the augmented model value exceeded (Indicates that the numerical limits of the interplay between subproblem and quadratic programming solver are reached, no further progress expected)</li><li>64 : maximum number of oracle calls (function evaluations) exceeded, see <a class="el" href="group__cinterface.html#g78da3da3e172d97d3ce16f151c91da8d" title="Sets an upper bound on the number of calls to the oracle (use negative numbers for...">cb_set_eval_limit()</a></li><li>128 : maximum number of oracle failures exceeded. This refers to function evaluations that terminate with insufficient precision but still provide a new approximate subgradient. A failure typically indicates numerical difficulties with the precision requirements. (Currently the interface does not allow to manipulate the limit, it is set to 10) </li></ul>
</dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue May 3 16:52:54 2011 for ConicBundle by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
