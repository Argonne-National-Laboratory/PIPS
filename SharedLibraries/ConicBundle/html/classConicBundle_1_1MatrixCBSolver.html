<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ConicBundle: ConicBundle::MatrixCBSolver Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceConicBundle.html">ConicBundle</a>::<a class="el" href="classConicBundle_1_1MatrixCBSolver.html">MatrixCBSolver</a>
  </div>
</div>
<div class="contents">
<h1>ConicBundle::MatrixCBSolver Class Reference<br>
<small>
[<a class="el" href="group__cxxmatrixinterface.html">Interface to ConicBundle for the Language C++ using Matrix Classes</a>]</small>
</h1><!-- doxytag: class="ConicBundle::MatrixCBSolver" -->Bundle method solver.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="MatCBSolver_8hxx-source.html">MatCBSolver.hxx</a>&gt;</code>
<p>

<p>
<a href="classConicBundle_1_1MatrixCBSolver-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4236b6ee3cb58fa3712f88b4bad317ed"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::MatrixCBSolver" ref="4236b6ee3cb58fa3712f88b4bad317ed" args="(bool no_bundle=false)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#4236b6ee3cb58fa3712f88b4bad317ed">MatrixCBSolver</a> (bool no_bundle=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">if the input parameter no_bundle is set to true then a minimal bundle variant is used consisting of just one aggregate and one new subgradient in each iteration (this is basically "no bundle", try it whenever fast iterations and/or low memory consumption seem advantageous) <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Initialization</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="072fcd8a7e415926d1ce6b0e54114dca"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::clear" ref="072fcd8a7e415926d1ce6b0e54114dca" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#072fcd8a7e415926d1ce6b0e54114dca">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears all data structures and problem information but keeps ouptut settings and algorithmic parameter settings. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="06984f1f190dd1f0db07d17bf5a89d54"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::set_defaults" ref="06984f1f190dd1f0db07d17bf5a89d54" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#06984f1f190dd1f0db07d17bf5a89d54">set_defaults</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets default values for algorithmic parameters that are not function specific (e.g., relative precision, weight and weight bounds for the augmentedproblem, etc.). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d595a3623c88f175aae7ce215df9712e">init_problem</a> (int dim, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *lbounds=0, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *ubounds=0, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *costs=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the problem by setting up the design space (the dimension and possible box constraints of the variables).  <a href="#d595a3623c88f175aae7ce215df9712e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#53b7500a47bd2f864092a73890c4db2c">add_function</a> (<a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a function, typically derived from <a class="el" href="classConicBundle_1_1FunctionOracle.html" title="oracle interface (abstract class). For each of your functions, provide a derived...">ConicBundle::FunctionOracle</a>; all functions added must have the same argument dimension set in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d595a3623c88f175aae7ce215df9712e" title="Initializes the problem by setting up the design space (the dimension and possible...">init_problem()</a>.  <a href="#53b7500a47bd2f864092a73890c4db2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#19c58b9c760b4efab9a59e9cca03f0a7">set_lower_bound</a> (int i, double lb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets lower bound for variable i, use <a class="el" href="group__cxxinterface.html#ge58492af3631a196b0edb8a8ebcda567" title="serves as the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value...">ConicBundle::CB_minus_infinity</a> for unbounded from below.  <a href="#19c58b9c760b4efab9a59e9cca03f0a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#10bd1df5d2d7114c96f7cae063385109">set_upper_bound</a> (int i, double ub)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets upper bound for variable i, use <a class="el" href="group__cxxinterface.html#g15948e7611155f822fc0331bcbb4a111" title="serves as the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value...">ConicBundle::CB_plus_infinity</a> for unbounded from below.  <a href="#10bd1df5d2d7114c96f7cae063385109"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#97b26d313821ba567be9f4aa14c289fb">append_variables</a> (int n_append, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *lbounds=0, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *ubounds=0, const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *costs=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append new variables (always in last postions in this order).  <a href="#97b26d313821ba567be9f4aa14c289fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#c1cdd25a701c8832e0ab7adabf482435">delete_variables</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> &amp;del_indices, <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> &amp;map_to_old)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes variables corresponding to the specified indices.  <a href="#c1cdd25a701c8832e0ab7adabf482435"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#f32b436c2f7a655fc0190684cf6a3daa">reassign_variables</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> &amp;assign_new_from_old)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reassigns variables to new index positions by mapping to position <em>i</em> the variable that previously had index <em>assign_new_from_old</em>[i].  <a href="#f32b436c2f7a655fc0190684cf6a3daa"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic algorithmic routines and parameters</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d2505f56a41772470feac50f99524fd2">do_descent_step</a> (int maxsteps=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does a descent step for the current center point.  <a href="#d2505f56a41772470feac50f99524fd2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#7d7589913e95675f4bee916eb3531270">termination_code</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the termination code of the bundle algorithm for the latest descent step.  <a href="#7d7589913e95675f4bee916eb3531270"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#3a2fd1cb66cdd565a81879de422e45db">print_termination_code</a> (std::ostream &amp;out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Outputs a text version of termination code, see <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#7d7589913e95675f4bee916eb3531270" title="Returns the termination code of the bundle algorithm for the latest descent step...">termination_code()</a>.  <a href="#3a2fd1cb66cdd565a81879de422e45db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ff2f74dee0784d36bca81c75026cca59"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_objval" ref="ff2f74dee0784d36bca81c75026cca59" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ff2f74dee0784d36bca81c75026cca59">get_objval</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the objective value resulting from last descent step (initially undefined). If no problem modification routines were called since then, it is the objective value at the point returned by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#db2eb21b8701e5d27e59c1500e3db198" title="Returns the next center point that was produced by the latest call to do_descent_step...">get_center()</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#db2eb21b8701e5d27e59c1500e3db198">get_center</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;center) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the next center point that was produced by the latest call to do_descent_step (in some problem modification routines the center point may be updated immediately, in others the center point will be corrected automatically directly before starting the next descent step and its values may be infeasible till then).  <a href="#db2eb21b8701e5d27e59c1500e3db198"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="54359cee2f5587d1ae3ccc90759ed19a"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_sgnorm" ref="54359cee2f5587d1ae3ccc90759ed19a" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#54359cee2f5587d1ae3ccc90759ed19a">get_sgnorm</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns Euclidean norm of the latest aggregate subgradient. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#590d9f1ddbccc19da97a5a764cff69a4">get_subgradient</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;subgradient) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the latest aggregate subgradient.  <a href="#590d9f1ddbccc19da97a5a764cff69a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="670181572d0dadb85cf73b865e3a1047"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_cutval" ref="670181572d0dadb85cf73b865e3a1047" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#670181572d0dadb85cf73b865e3a1047">get_cutval</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the cutting model value resulting from last call to <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d2505f56a41772470feac50f99524fd2" title="Does a descent step for the current center point.">do_descent_step()</a> (initially undefined). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#2c1e3af20ab203ac427da352afbd153c">get_candidate_value</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the objective value computed in the last step of <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d2505f56a41772470feac50f99524fd2" title="Does a descent step for the current center point.">do_descent_step()</a>, independent of whether this was a descent step or a null step (initially undefined).  <a href="#2c1e3af20ab203ac427da352afbd153c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#b82cd4c6ec60b2029dbdcd168dec8187">get_candidate</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;center) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the last point, the "candidate", at which the function was evaluated in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d2505f56a41772470feac50f99524fd2" title="Does a descent step for the current center point.">do_descent_step()</a>.  <a href="#b82cd4c6ec60b2029dbdcd168dec8187"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Advanced algorithmic routines and parameters</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#bede1e498b73162f2b7e74f958df5bc0">set_term_relprec</a> (const double term_relprec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the relative precision requirements for successful termination (default 1e-5).  <a href="#bede1e498b73162f2b7e74f958df5bc0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#c7f0864cfbc01e3f9c057234069423ba">set_new_center_point</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;center_point)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the starting point/center that will be used in the next call to <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d2505f56a41772470feac50f99524fd2" title="Does a descent step for the current center point.">do_descent_step()</a>. Each call to this routine causes an immediate evaluation of all oracles.  <a href="#c7f0864cfbc01e3f9c057234069423ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="352bb891eba07db3067a5cc039559337"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_function_status" ref="352bb891eba07db3067a5cc039559337" args="(const FunctionObject &amp;function) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#352bb891eba07db3067a5cc039559337">get_function_status</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the return value of the latest evaluation call to this <em>function</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#75386771ea08d4026d06640d79446dec">get_approximate_slacks</a> (<a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the multipliers for the box constraints on the design variables; in Lagrangean relaxation they may be interpreted as primal slacks for inequality constraints.  <a href="#75386771ea08d4026d06640d79446dec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#c34013129a601d786d0001c0b30dfa12">get_approximate_primal</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function, <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> &amp;primal) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the current approximate primal solution corresponding to the aggregate subgradient of the specified <em>function</em>.  <a href="#c34013129a601d786d0001c0b30dfa12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#e8606f1eae8aaea95b0ff26be6789460">get_center_primal</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function, <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> &amp;primal) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the primal solution corresponding to the best epsilon subgradient returned in the evaluation of the specified <em>function</em> at the current center point.  <a href="#e8606f1eae8aaea95b0ff26be6789460"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#888c954e664a5b4057b25e250c63db1b">get_candidate_primal</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function, <a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> &amp;primal) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the primal solution returned by the last evaluation of the specified <em>function</em> in the point <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#b82cd4c6ec60b2029dbdcd168dec8187" title="Returns the last point, the &quot;candidate&quot;, at which the function was evaluated...">get_candidate()</a>.  <a href="#888c954e664a5b4057b25e250c63db1b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d7ad59b50b4dab571f72943409e8edfd">set_max_bundlesize</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function, int max_bundlesize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum number of subgradients used in forming the cutting model of the specified <em>function</em>.  <a href="#d7ad59b50b4dab571f72943409e8edfd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#9ee0c6baa5f74904fcc90b9999de71b8">set_max_new_subgradients</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function, int max_new_subgradients)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum number of new subgradients to be used in the next bundle update of the cutting modle for the specified .  <a href="#9ee0c6baa5f74904fcc90b9999de71b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#f419e2bbf3e6a2b4968f00085e6fc1ff">set_bundle_parameters</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function, const <a class="el" href="classConicBundle_1_1BundleParameters.html">BundleParameters</a> &amp;params)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum bundlesize and the maximum number of new subgradients added in a bundle update of the cutting model for the specified <em>function</em>. The meaning of this routine may differ from standard for predefined special functions with special bundle types.  <a href="#f419e2bbf3e6a2b4968f00085e6fc1ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#5e617d8d034030b7540c3b4816f9cfb0">get_bundle_parameters</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function, <a class="el" href="classConicBundle_1_1BundleParameters.html">BundleParameters</a> &amp;params) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves current bundle parameters (not the actual size in use!) as set for the cutting model of the specified <em>function</em>.  <a href="#5e617d8d034030b7540c3b4816f9cfb0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#21bc5024ebba90979731b5221df33ed0">get_bundle_values</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function, <a class="el" href="classConicBundle_1_1BundleParameters.html">BundleParameters</a> &amp;params) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current bundle values: the current bundle_size and the number of subgradients added in the latest update of the cutting model of the specified <em>function</em>.  <a href="#21bc5024ebba90979731b5221df33ed0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#2aec82a3e11a2789caa085c6d99c1a4d">reinit_function_model</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears cutting model, subgradients and stored function values for the specified <em>function</em>.  <a href="#2aec82a3e11a2789caa085c6d99c1a4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#dfd6b0f8e30f498c3f4660bc3a3c5dad">clear_aggregates</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the aggregate parts of the cutting model of this <em>function</em>.  <a href="#dfd6b0f8e30f498c3f4660bc3a3c5dad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#6bd691c7cb860f7f52c39ea3a28b5b63">call_primal_extender</a> (const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;function, <a class="el" href="classConicBundle_1_1PrimalExtender.html">PrimalExtender</a> &amp;primal_extender)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asks <em>function</em> to call <em>primal_extender</em> for each of its primal objects (see also <a class="el" href="classConicBundle_1_1FunctionOracle.html#62bbdbf390aa0a1c4a9cc983c74c9bf8" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient...">FunctionOracle::evaluate()</a> ).  <a href="#6bd691c7cb860f7f52c39ea3a28b5b63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c664056be4da152253027bebe6501061"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_last_weight" ref="c664056be4da152253027bebe6501061" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#c664056be4da152253027bebe6501061">get_last_weight</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current weight for the quadratic term in the augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#caa42c46986ad62af21555340346dcf4">set_next_weight</a> (const double weight)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the weight (&gt;0) to be used in the quadratic term of the next augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius).  <a href="#caa42c46986ad62af21555340346dcf4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#6f10280eeddb360806951729b076e026">set_min_weight</a> (const double min_weight)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a lower bound on the weight for the quadratic term of the augmented subproblem.  <a href="#6f10280eeddb360806951729b076e026"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#bd2d01b507839451c91d6574c02113c2">set_max_weight</a> (const double max_weight)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an upper bound on the weight for the quadratic term of the augmented subproblem.  <a href="#bd2d01b507839451c91d6574c02113c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ba280fdc2eca4c836412118910ebd2c1">adjust_multiplier</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adjusts on all conic functions the penalty parameter for conic violations to twice the trace of the primal approximation.  <a href="#ba280fdc2eca4c836412118910ebd2c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#f08ac2b7bda5aa84bc83b4f094755752">set_scaling</a> (bool do_scaling)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use a scaling heuristic or switch off scaling alltogether.  <a href="#f08ac2b7bda5aa84bc83b4f094755752"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#a08c108e21ff536add76511dec346b60">set_scaling</a> (const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">user defined diagonal scaling, values greater than 1 allow more movement for this variable, values smaller than 1 allow less movement.  <a href="#a08c108e21ff536add76511dec346b60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#5229f01c537d914a60b896bf01e550d5">set_active_bounds_fixing</a> (bool allow_fixing)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If set to true (the default is false), some variables will be fixed automatically to the center value if their bounds are strongly active (i.e., the corresponding multipliers are big).  <a href="#5229f01c537d914a60b896bf01e550d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#9eeac5ece21d05a387eea9f755b15bff">clear_fail_counts</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">clears all fail counts on numerical function oder model failures, may be useful if this caused premature termination.  <a href="#9eeac5ece21d05a387eea9f755b15bff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#132338a9a8fd4c576156123cb37096a9">set_eval_limit</a> (int eval_limit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an upper bound on the number of calls to the oracle (use negative numbers for no limit).  <a href="#132338a9a8fd4c576156123cb37096a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#97c6dd9f9c172599bba633cd0a2a1417">set_inner_update_limit</a> (int update_limit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an upper bound on the number of inner updates for the cutting model with primal slacks within one null step (use negative numbers for no limit).  <a href="#97c6dd9f9c172599bba633cd0a2a1417"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Look up basic paramaters (dimension, number of functions, ...)</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b17d5627788490a60c8ef37e561de7d3"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_dim" ref="b17d5627788490a60c8ef37e561de7d3" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#b17d5627788490a60c8ef37e561de7d3">get_dim</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current dimension of the design space/argument or -1 if no dimension is set. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aa68e4da5f27591a025f232c6542957e"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_n_functions" ref="aa68e4da5f27591a025f232c6542957e" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#aa68e4da5f27591a025f232c6542957e">get_n_functions</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current number of functions in the problem. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2ddc70add43c04072b9ebe2db6f7a383"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_n_oracle_calls" ref="2ddc70add43c04072b9ebe2db6f7a383" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#2ddc70add43c04072b9ebe2db6f7a383">get_n_oracle_calls</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of function evaluations. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2c5865c5caff4d8a4697004cd499a17c"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_n_descent_steps" ref="2c5865c5caff4d8a4697004cd499a17c" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#2c5865c5caff4d8a4697004cd499a17c">get_n_descent_steps</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of function descent setps. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="15ca7eaa2a6513b4dc5f71b1350ee6a4"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_n_inner_iterations" ref="15ca7eaa2a6513b4dc5f71b1350ee6a4" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#15ca7eaa2a6513b4dc5f71b1350ee6a4">get_n_inner_iterations</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of inner iterations of the bundle method. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e4ff62fc68c7725f8ee7f99141abe697"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_n_inner_updates" ref="e4ff62fc68c7725f8ee7f99141abe697" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#e4ff62fc68c7725f8ee7f99141abe697">get_n_inner_updates</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of inner multiplier updates for the box constraints. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="946386101cfa492530a3bd0da10f414e"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_lbounds" ref="946386101cfa492530a3bd0da10f414e" args="() const " -->
const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#946386101cfa492530a3bd0da10f414e">get_lbounds</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the vector of lower bounds. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dbd778f9cc4a483610b1245f6be287df"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_ubounds" ref="dbd778f9cc4a483610b1245f6be287df" args="() const " -->
const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#dbd778f9cc4a483610b1245f6be287df">get_ubounds</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the vector of upper bounds. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <br>
<a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ae88fbaba489ce4e9c994c9f0f7a8ff0">get_active_bounds_indicator</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the indicator vector of variables temporarily fixed to the center value due to significantly positive multipliers for the box constraints.  <a href="#ae88fbaba489ce4e9c994c9f0f7a8ff0"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Output</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#370c6ee0dd593962cbb39927a56d6bce">set_out</a> (std::ostream *out=0, int print_level=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies the output level (out==NULL: no output at all, out!=NULL and level=0: errors and warnings, level&gt;0 increasingly detailed information).  <a href="#370c6ee0dd593962cbb39927a56d6bce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6799226102d0388369a4f0e9676778e1"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::print_line_summary" ref="6799226102d0388369a4f0e9676778e1" args="(std::ostream &amp;out) const " -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#6799226102d0388369a4f0e9676778e1">print_line_summary</a> (std::ostream &amp;out) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print a one line summary of important evaluation data <br></td></tr>
<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dd08c6ce7a217edc6d33b2bfcff95dbc"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::MatrixCBSolver" ref="dd08c6ce7a217edc6d33b2bfcff95dbc" args="(const CBSolver &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#dd08c6ce7a217edc6d33b2bfcff95dbc">MatrixCBSolver</a> (const <a class="el" href="classConicBundle_1_1CBSolver.html">CBSolver</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">not available, blocked deliberately <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d9295fa3f967fdaa621bf472778231ea"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::operator=" ref="d9295fa3f967fdaa621bf472778231ea" args="(const CBSolver &amp;)" -->
<a class="el" href="classConicBundle_1_1MatrixCBSolver.html">MatrixCBSolver</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d9295fa3f967fdaa621bf472778231ea">operator=</a> (const <a class="el" href="classConicBundle_1_1CBSolver.html">CBSolver</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">not available, blocked deliberately <br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="503ab9b9ab5432eb2a68a009ae1eb451"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::solver" ref="503ab9b9ab5432eb2a68a009ae1eb451" args="" -->
<a class="el" href="classConicBundle_1_1MatrixBSolver.html">MatrixBSolver</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConicBundle_1_1MatrixCBSolver.html#503ab9b9ab5432eb2a68a009ae1eb451">solver</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pointer to internal solver data <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Bundle method solver. 
<p>
Minimizes the sum of convex functions that are given via <a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html" title="Oracle interface (abstract class). For each of your functions, provide an instance...">ConicBundle::MatrixFunctionOracle</a> interfaces, see <a class="el" href="group__cxxmatrixinterface.html">the text explaining the C++ interface for Matrix Classes</a> for a quick overview.<p>
It provides special support for Lagrangean relaxation by generating primal approximate solutions if such information is provided in the function oracles.<p>
Based on these primal approximations it is also possible to implement cutting plane schemes. Routines for adding and deleting corresponding dual variables as well as a framework for extending subgradients in order not to loose the cutting model are available. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="d595a3623c88f175aae7ce215df9712e"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::init_problem" ref="d595a3623c88f175aae7ce215df9712e" args="(int dim, const CH_Matrix_Classes::Matrix *lbounds=0, const CH_Matrix_Classes::Matrix *ubounds=0, const CH_Matrix_Classes::Matrix *costs=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::init_problem           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&nbsp;</td>
          <td class="paramname"> <em>lbounds</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&nbsp;</td>
          <td class="paramname"> <em>ubounds</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&nbsp;</td>
          <td class="paramname"> <em>costs</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the problem by setting up the design space (the dimension and possible box constraints of the variables). 
<p>
Clears all data structures and sets the dimension @ m for a new problem. for solving min_{y in R^m} f_0(y) + f_1(y) + ... Box constraints may be specified for y. (The functions f_i must be added by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#53b7500a47bd2f864092a73890c4db2c" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions...">add_function()</a>).<p>
Lower and/or upper bounds must be speicified for all variables or for none of them. To specify no bounds at all, give Null pointers. Otherwise use <a class="el" href="group__cxxinterface.html#ge58492af3631a196b0edb8a8ebcda567" title="serves as the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value...">ConicBundle::CB_minus_infinity</a> for unbounded below and <a class="el" href="group__cxxinterface.html#g15948e7611155f822fc0331bcbb4a111" title="serves as the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value...">ConicBundle::CB_plus_infinity</a> for unbounded above. For NULL pointers, unbounded will be used as default for all variables. Specifying bounds selectively is also possible by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#19c58b9c760b4efab9a59e9cca03f0a7" title="Sets lower bound for variable i, use ConicBundle::CB_minus_infinity for unbounded...">set_lower_bound()</a> or <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#10bd1df5d2d7114c96f7cae063385109" title="Sets upper bound for variable i, use ConicBundle::CB_plus_infinity for unbounded...">set_upper_bound()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dimm</em>&nbsp;</td><td>(int) the dimension of the argument/design space/the number of Lagrange multipliers</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lbounds</em>&nbsp;</td><td>(const Matrix*) If NULL, all variables are considered unbounded below, otherwise lowerb[i] gives the minimum feasible value for variable y[i], use <a class="el" href="group__cxxinterface.html#ge58492af3631a196b0edb8a8ebcda567" title="serves as the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value...">ConicBundle::CB_minus_infinity</a> for unbounded below.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ubounds</em>&nbsp;</td><td>(const Matrix*) If NULL, all variables are considered unbounded above, otherwise upperb[i] gives the maximum feasible value for variable y[i], use <a class="el" href="group__cxxinterface.html#g15948e7611155f822fc0331bcbb4a111" title="serves as the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value...">ConicBundle::CB_plus_infinity</a> for unbounded above.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>costs</em>&nbsp;</td><td>(const Matrix*) Use this in order to specify linear costs on the variables in addition to the functions (may be convenient in Lagrangean relaxation for the right hand side of coupling contsraints); NULL is equivalent to costs zero.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="53b7500a47bd2f864092a73890c4db2c"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::add_function" ref="53b7500a47bd2f864092a73890c4db2c" args="(FunctionObject &amp;function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::add_function           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a function, typically derived from <a class="el" href="classConicBundle_1_1FunctionOracle.html" title="oracle interface (abstract class). For each of your functions, provide a derived...">ConicBundle::FunctionOracle</a>; all functions added must have the same argument dimension set in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d595a3623c88f175aae7ce215df9712e" title="Initializes the problem by setting up the design space (the dimension and possible...">init_problem()</a>. 
<p>
Besides the standard <a class="el" href="classConicBundle_1_1MatrixFunctionOracle.html" title="Oracle interface (abstract class). For each of your functions, provide an instance...">ConicBundle::MatrixFunctionOracle</a> the interface only accepts a few other prespecified derivations of the class <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on...">FunctionObject</a> that come along with the <a class="el" href="namespaceCH__Matrix__Classes.html" title="Matrix Classes and Linear Algebra. See Matrix Classes (namespace CH_Matrix_Classes)...">CH_Matrix_Classes</a> interface (e.g. for semidefinite and second order cones). Functions not derived from these will fail to be added and return a value !=0.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="19c58b9c760b4efab9a59e9cca03f0a7"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::set_lower_bound" ref="19c58b9c760b4efab9a59e9cca03f0a7" args="(int i, double lb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_lower_bound           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>lb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets lower bound for variable i, use <a class="el" href="group__cxxinterface.html#ge58492af3631a196b0edb8a8ebcda567" title="serves as the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value...">ConicBundle::CB_minus_infinity</a> for unbounded from below. 
<p>
The algorithm may have to adapt the center point aftwards. In this case the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d2505f56a41772470feac50f99524fd2" title="Does a descent step for the current center point.">do_descent_step()</a>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="10bd1df5d2d7114c96f7cae063385109"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::set_upper_bound" ref="10bd1df5d2d7114c96f7cae063385109" args="(int i, double ub)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_upper_bound           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ub</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets upper bound for variable i, use <a class="el" href="group__cxxinterface.html#g15948e7611155f822fc0331bcbb4a111" title="serves as the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value...">ConicBundle::CB_plus_infinity</a> for unbounded from below. 
<p>
The algorithm may have to adapt the center point aftwards. In this case the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d2505f56a41772470feac50f99524fd2" title="Does a descent step for the current center point.">do_descent_step()</a>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="97b26d313821ba567be9f4aa14c289fb"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::append_variables" ref="97b26d313821ba567be9f4aa14c289fb" args="(int n_append, const CH_Matrix_Classes::Matrix *lbounds=0, const CH_Matrix_Classes::Matrix *ubounds=0, const CH_Matrix_Classes::Matrix *costs=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::append_variables           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n_append</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&nbsp;</td>
          <td class="paramname"> <em>lbounds</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&nbsp;</td>
          <td class="paramname"> <em>ubounds</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> *&nbsp;</td>
          <td class="paramname"> <em>costs</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append new variables (always in last postions in this order). 
<p>
If 0 is feasible for the new coordinates then this is selected as starting value for the new coordinates; otherwise, the number closest to zero is used. If all new coordinates can be set to zero then it is assumed that for an existing center point the function values need not be recomputed (this is e.g. the case in Lagrangean relaxation; if this is not correct call <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#2aec82a3e11a2789caa085c6d99c1a4d" title="Clears cutting model, subgradients and stored function values for the specified function...">reinit_function_model()</a> below). Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d2505f56a41772470feac50f99524fd2" title="Does a descent step for the current center point.">do_descent_step()</a>.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>Be sure to update your objective functions so that they can handle the new variables before you call this and any further <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual...">ConicBundle</a> routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n_append</em>&nbsp;</td><td>(int) number of variables to append (always in last position in the same order)</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lbounds</em>&nbsp;</td><td>(const Matrix*) If NULL, all appended variables are considered unbounded below, otherwise lowerb[i] gives the minimum feasible value for variable y[i], use <a class="el" href="group__cxxinterface.html#ge58492af3631a196b0edb8a8ebcda567" title="serves as the value &quot;plus infinity&quot;, i.e., all bounds &gt;= this value...">ConicBundle::CB_minus_infinity</a> for unbounded below.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ubounds</em>&nbsp;</td><td>(const Matrix*) If NULL, all appended variables are considered unbounded above, otherwise upperb[i] gives the maximum feasible value for variable y[i], use <a class="el" href="group__cxxinterface.html#g15948e7611155f822fc0331bcbb4a111" title="serves as the value &quot;minus infinity&quot;, i.e., all bounds &lt;= this value...">ConicBundle::CB_plus_infinity</a> for unbounded above.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="c1cdd25a701c8832e0ab7adabf482435"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::delete_variables" ref="c1cdd25a701c8832e0ab7adabf482435" args="(const CH_Matrix_Classes::Indexmatrix &amp;del_indices, CH_Matrix_Classes::Indexmatrix &amp;map_to_old)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::delete_variables           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>del_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>map_to_old</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes variables corresponding to the specified indices. 
<p>
The indices of the remaining variables are reassigned so that they are consecutive again, the routine returns in <em>map_to_old</em> a vector giving for each new index of these remaining variables the old coordinate.<p>
If all of the deleted variables are zero, function values are assumed to remain correct (if this is not so, call <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#2aec82a3e11a2789caa085c6d99c1a4d" title="Clears cutting model, subgradients and stored function values for the specified function...">reinit_function_model()</a> below) Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d2505f56a41772470feac50f99524fd2" title="Does a descent step for the current center point.">do_descent_step()</a>.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>Be sure to update your objective functions so that they can handle the new variables before you call any further <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual...">ConicBundle</a> routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>delete_indices</em>&nbsp;</td><td>(const Indexmatrix&amp;) the entries delete_indices[i] specify the indices of the variables to be deleted</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>map_to_old</em>&nbsp;</td><td>(Indexmatrix&amp;) after the call, element map_to_old[i] gives the old index (before the call) of the variable that now has index position i.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="f32b436c2f7a655fc0190684cf6a3daa"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::reassign_variables" ref="f32b436c2f7a655fc0190684cf6a3daa" args="(const CH_Matrix_Classes::Indexmatrix &amp;assign_new_from_old)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::reassign_variables           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>assign_new_from_old</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reassigns variables to new index positions by mapping to position <em>i</em> the variable that previously had index <em>assign_new_from_old</em>[i]. 
<p>
Old variables, that are not mapped to any position will be deleted. It is allowed to generate several copies of old variables.<p>
If all of the deleted variables as well as new multiple copies are zero, function values are assumed to remain correct (if this is not so, call <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#2aec82a3e11a2789caa085c6d99c1a4d" title="Clears cutting model, subgradients and stored function values for the specified function...">reinit_function_model()</a> below). Otherwise the old function values will be marked as outdated and will be recomputed at the next call to e.g. <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d2505f56a41772470feac50f99524fd2" title="Does a descent step for the current center point.">do_descent_step()</a>.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>Be sure to update your objective functions so that they can handle the new variables before you call any further <a class="el" href="namespaceConicBundle.html" title="conic bundle method solver for sum of convex functions. See the ConicBundle_Manual...">ConicBundle</a> routines that require function evaluations. Also, these operations may lead to inavailability of certain other data such as subgradients and primal approximations.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>assign_new_from_old</em>&nbsp;</td><td>(const IVector&amp;) entry assign_new_from_old[i] specifies the old index of the variable, that has to be copied to index position i.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="d2505f56a41772470feac50f99524fd2"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::do_descent_step" ref="d2505f56a41772470feac50f99524fd2" args="(int maxsteps=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::do_descent_step           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxsteps</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does a descent step for the current center point. 
<p>
A descent step may consist of several function evaluations (null steps), that lead to no immediate progress but serve for building a cutting model of the objective function close to the current center point. A minimizer to the model is accepted as descent step if the function value at this point satisfies a sufficient decrease criterion in comparison to the decrease predicted by the model. Having found a descent step, the next center is automatically shifted to this successful candidate. Termination criteria may stop the process of seeking for a descent step, in which case the current center is kept and the routine <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#7d7589913e95675f4bee916eb3531270" title="Returns the termination code of the bundle algorithm for the latest descent step...">termination_code()</a> returns the termination code.<p>
Restarting, after each descent step, the bundle method from scratch with the new center as starting point does not endanger convergence. Therefore, a descent step is the smallest unit, after which user interaction can take place safely and this is the default choice.<p>
If you know what your are doing, you may also use the input parameter maxsteps to force the algorithm to return after at most maxsteps null steps. Calling do_descent_step again without any intermediate problem configurations will then simply continue the process where it stopped and convergence is save. During null steps one may not decrease the weight or delete nonzero variables of the center or the current candidate!<p>
In a Lagrangean relaxation cutting plane approach one may want to separate and enlarge the dimension after a certain number of null steps. In this case the code will try to preserve the model, given appropriate subgradient extension routines have been provided. If the model cannot be extended, it has to be discarded (if subgradient extension is not successful this is done automatically), and the algorithm will be restarted from the current center point.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxsteps</em>&nbsp;</td><td>(int) if maxsteps&gt;0 the code returns after at most so many null steps</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="7d7589913e95675f4bee916eb3531270"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::termination_code" ref="7d7589913e95675f4bee916eb3531270" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::termination_code           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the termination code of the bundle algorithm for the latest descent step. 
<p>
For resetting all counters relevant for termination see <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#9eeac5ece21d05a387eea9f755b15bff" title="clears all fail counts on numerical function oder model failures, may be useful if...">clear_fail_counts()</a> .<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 : Not terminated. (Continue with the next <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d2505f56a41772470feac50f99524fd2" title="Does a descent step for the current center point.">do_descent_step()</a>)</li><li>1 : Relative precision criterion satisfied. (See <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#bede1e498b73162f2b7e74f958df5bc0" title="Sets the relative precision requirements for successful termination (default 1e-5)...">set_term_relprec()</a>)</li><li>2 : Timelimit exceeded. (Currently the C interface does not offer a timelimit.)</li><li>4 : Maximum number of function reevaluations exceeded. (Indicates that there is a problem with one of the function oracles that seems to deliver no valid upper bounds on the true function value for descent steps)</li><li>8 : Maximum number of quadratic subproblem failures exceeded. (Indicates that the numerical limits of the inner quadratic programming solver are reached, no further progress expected)</li><li>16 : maximum number of model evaluation failures exceeded (Indicates that the numerical limits of the setup of the subproblem are reached, no further progress expected)</li><li>32 : maximum number of failures to increase the augmented model value exceeded (Indicates that the numerical limits of the interplay between subproblem and quadratic programming solver are reached, no further progress expected)<ul>
<li>64 : maximum number of oracle calls (function evaluations) exceeded, see <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#132338a9a8fd4c576156123cb37096a9" title="Sets an upper bound on the number of calls to the oracle (use negative numbers for...">set_eval_limit()</a></li><li>128 : maximum number of oracle failures exceeded. This refers to function evaluations that terminate with insufficient precision but still provide a new approximate subgradient. A failure typically indicates numerical difficulties with the precision requirements. (Currently the interface does not allow to manipulate the limit, it is set to 10) </li></ul>
</li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="3a2fd1cb66cdd565a81879de422e45db"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::print_termination_code" ref="3a2fd1cb66cdd565a81879de422e45db" args="(std::ostream &amp;out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; ConicBundle::MatrixCBSolver::print_termination_code           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Outputs a text version of termination code, see <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#7d7589913e95675f4bee916eb3531270" title="Returns the termination code of the bundle algorithm for the latest descent step...">termination_code()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="db2eb21b8701e5d27e59c1500e3db198"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_center" ref="db2eb21b8701e5d27e59c1500e3db198" args="(CH_Matrix_Classes::Matrix &amp;center) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::get_center           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the next center point that was produced by the latest call to do_descent_step (in some problem modification routines the center point may be updated immediately, in others the center point will be corrected automatically directly before starting the next descent step and its values may be infeasible till then). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="590d9f1ddbccc19da97a5a764cff69a4"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_subgradient" ref="590d9f1ddbccc19da97a5a764cff69a4" args="(CH_Matrix_Classes::Matrix &amp;subgradient) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::get_subgradient           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subgradient</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the latest aggregate subgradient. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="2c1e3af20ab203ac427da352afbd153c"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_candidate_value" ref="2c1e3af20ab203ac427da352afbd153c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ConicBundle::MatrixCBSolver::get_candidate_value           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the objective value computed in the last step of <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d2505f56a41772470feac50f99524fd2" title="Does a descent step for the current center point.">do_descent_step()</a>, independent of whether this was a descent step or a null step (initially undefined). 
<p>
If no problem modification routines were called since then, it is the objective value at the point returned by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#b82cd4c6ec60b2029dbdcd168dec8187" title="Returns the last point, the &quot;candidate&quot;, at which the function was evaluated...">get_candidate()</a>. If this last evaluation led to a descent step, then it is the same value as in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ff2f74dee0784d36bca81c75026cca59" title="Returns the objective value resulting from last descent step (initially undefined)...">get_objval()</a>. 
</div>
</div><p>
<a class="anchor" name="b82cd4c6ec60b2029dbdcd168dec8187"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_candidate" ref="b82cd4c6ec60b2029dbdcd168dec8187" args="(CH_Matrix_Classes::Matrix &amp;center) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::get_candidate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the last point, the "candidate", at which the function was evaluated in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d2505f56a41772470feac50f99524fd2" title="Does a descent step for the current center point.">do_descent_step()</a>. 
<p>
If this evaluation lead to a descent step, it is the same point as in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#db2eb21b8701e5d27e59c1500e3db198" title="Returns the next center point that was produced by the latest call to do_descent_step...">get_center()</a>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="bede1e498b73162f2b7e74f958df5bc0"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::set_term_relprec" ref="bede1e498b73162f2b7e74f958df5bc0" args="(const double term_relprec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_term_relprec           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>term_relprec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the relative precision requirements for successful termination (default 1e-5). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>term_relprec</em>&nbsp;</td><td>(double) The algorithm stops with termination code 1, if predicted progress for the next step is less than term_relprec times absolute function value plus one.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="c7f0864cfbc01e3f9c057234069423ba"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::set_new_center_point" ref="c7f0864cfbc01e3f9c057234069423ba" args="(const CH_Matrix_Classes::Matrix &amp;center_point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_new_center_point           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_point</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the starting point/center that will be used in the next call to <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d2505f56a41772470feac50f99524fd2" title="Does a descent step for the current center point.">do_descent_step()</a>. Each call to this routine causes an immediate evaluation of all oracles. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="75386771ea08d4026d06640d79446dec"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_approximate_slacks" ref="75386771ea08d4026d06640d79446dec" args="(CH_Matrix_Classes::Matrix &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::get_approximate_slacks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the multipliers for the box constraints on the design variables; in Lagrangean relaxation they may be interpreted as primal slacks for inequality constraints. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="c34013129a601d786d0001c0b30dfa12"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_approximate_primal" ref="c34013129a601d786d0001c0b30dfa12" args="(const FunctionObject &amp;function, PrimalData &amp;primal) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::get_approximate_primal           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>primal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns the current approximate primal solution corresponding to the aggregate subgradient of the specified <em>function</em>. 
<p>
<a class="el" href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying...">PrimalData</a> solutions must have been supplied in all previous calls to evaluate; In this case it returns the current approximate primal solution aggregated alongside with the aggregate subgradient. A primal solution may not be available after addition of constraints, if extension of the aggregate subgradient to the new coordinates failed.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="e8606f1eae8aaea95b0ff26be6789460"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_center_primal" ref="e8606f1eae8aaea95b0ff26be6789460" args="(const FunctionObject &amp;function, PrimalData &amp;primal) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::get_center_primal           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>primal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the primal solution corresponding to the best epsilon subgradient returned in the evaluation of the specified <em>function</em> at the current center point. 
<p>
<a class="el" href="classConicBundle_1_1PrimalData.html" title="In Lagrangean relaxation an approximate primal solution can be generated by supplying...">PrimalData</a> solutions must have been supplied in all previous calls to evaluate; It may not be available or may correspond to an aggregate primal after addition or deletion of design variables/primal constraints.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="888c954e664a5b4057b25e250c63db1b"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_candidate_primal" ref="888c954e664a5b4057b25e250c63db1b" args="(const FunctionObject &amp;function, PrimalData &amp;primal) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::get_candidate_primal           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1PrimalData.html">PrimalData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>primal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the primal solution returned by the last evaluation of the specified <em>function</em> in the point <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#b82cd4c6ec60b2029dbdcd168dec8187" title="Returns the last point, the &quot;candidate&quot;, at which the function was evaluated...">get_candidate()</a>. 
<p>
It will only be available if also supplied by the <em>function</em> <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="d7ad59b50b4dab571f72943409e8edfd"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::set_max_bundlesize" ref="d7ad59b50b4dab571f72943409e8edfd" args="(const FunctionObject &amp;function, int max_bundlesize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_max_bundlesize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_bundlesize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the maximum number of subgradients used in forming the cutting model of the specified <em>function</em>. 
<p>
Quite often a very small model, e.g., 2, yields very fast iterations and good progress in time (sometimes at the cost of more evaluations). By limited numerical experience, a significant reduction in the number of evaluations can only be expected if the bundle is large enough to wrap the function rather tightly. Quite frequently, unfortunately, this entails that solving the quadratic subproblems is more expensive than function evaluation.<p>
The meaning of this routine may differ from standard for predefined special functions with special bundle types.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function</em>&nbsp;</td><td>(const <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on...">FunctionObject</a>&amp;) the function added in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#53b7500a47bd2f864092a73890c4db2c" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions...">add_function()</a></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bundlesize</em>&nbsp;</td><td>(int) maximum number of subgradients to be used in forming the cutting model</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="9ee0c6baa5f74904fcc90b9999de71b8"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::set_max_new_subgradients" ref="9ee0c6baa5f74904fcc90b9999de71b8" args="(const FunctionObject &amp;function, int max_new_subgradients)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_max_new_subgradients           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_new_subgradients</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the maximum number of new subgradients to be used in the next bundle update of the cutting modle for the specified . 
<p>
The meaning of this routine may differ from standard for predefined special functions with special bundle types.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function</em>&nbsp;</td><td>(const <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on...">FunctionObject</a>&amp;) the function added in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#53b7500a47bd2f864092a73890c4db2c" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions...">add_function()</a></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>max_new_subgradients</em>&nbsp;</td><td>(int) maximum number of new epsilon subgradients to be used in bundle updates</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="f419e2bbf3e6a2b4968f00085e6fc1ff"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::set_bundle_parameters" ref="f419e2bbf3e6a2b4968f00085e6fc1ff" args="(const FunctionObject &amp;function, const BundleParameters &amp;params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_bundle_parameters           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1BundleParameters.html">BundleParameters</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the maximum bundlesize and the maximum number of new subgradients added in a bundle update of the cutting model for the specified <em>function</em>. The meaning of this routine may differ from standard for predefined special functions with special bundle types. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function</em>&nbsp;</td><td>(const <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on...">FunctionObject</a>&amp;) the function added in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#53b7500a47bd2f864092a73890c4db2c" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions...">add_function()</a></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>params</em>&nbsp;</td><td>(const <a class="el" href="classConicBundle_1_1BundleParameters.html" title="Serves for specifying parameters regarding the construction of the cutting model...">BundleParameters</a>&amp;) some update parameters for the cutting model, see e.g. <a class="el" href="classConicBundle_1_1BundleParameters.html" title="Serves for specifying parameters regarding the construction of the cutting model...">ConicBundle::BundleParameters</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="5e617d8d034030b7540c3b4816f9cfb0"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_bundle_parameters" ref="5e617d8d034030b7540c3b4816f9cfb0" args="(const FunctionObject &amp;function, BundleParameters &amp;params) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::get_bundle_parameters           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1BundleParameters.html">BundleParameters</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves current bundle parameters (not the actual size in use!) as set for the cutting model of the specified <em>function</em>. 
<p>
This may differ for predefined special functions with derived BundleParameter classes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function</em>&nbsp;</td><td>(const <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on...">FunctionObject</a>&amp;) the function added in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#53b7500a47bd2f864092a73890c4db2c" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions...">add_function()</a></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>params</em>&nbsp;</td><td>(<a class="el" href="classConicBundle_1_1BundleParameters.html" title="Serves for specifying parameters regarding the construction of the cutting model...">BundleParameters</a>&amp;)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="21bc5024ebba90979731b5221df33ed0"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_bundle_values" ref="21bc5024ebba90979731b5221df33ed0" args="(const FunctionObject &amp;function, BundleParameters &amp;params) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::get_bundle_values           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1BundleParameters.html">BundleParameters</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current bundle values: the current bundle_size and the number of subgradients added in the latest update of the cutting model of the specified <em>function</em>. 
<p>
This may differ for predefined special functions with derived BundleParameter classes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function</em>&nbsp;</td><td>(const <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on...">FunctionObject</a>&amp;) the function added in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#53b7500a47bd2f864092a73890c4db2c" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions...">add_function()</a></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>params</em>&nbsp;</td><td>(<a class="el" href="classConicBundle_1_1BundleParameters.html" title="Serves for specifying parameters regarding the construction of the cutting model...">BundleParameters</a>&amp;)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="2aec82a3e11a2789caa085c6d99c1a4d"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::reinit_function_model" ref="2aec82a3e11a2789caa085c6d99c1a4d" args="(const FunctionObject &amp;function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::reinit_function_model           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears cutting model, subgradients and stored function values for the specified <em>function</em>. 
<p>
This has to be called whenever the specified function was modified so that the old subgradients and/or primal generators are no longer valid.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function</em>&nbsp;</td><td>(const <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on...">FunctionObject</a>&amp;) the function added in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#53b7500a47bd2f864092a73890c4db2c" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions...">add_function()</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="dfd6b0f8e30f498c3f4660bc3a3c5dad"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::clear_aggregates" ref="dfd6b0f8e30f498c3f4660bc3a3c5dad" args="(const FunctionObject &amp;function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::clear_aggregates           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the aggregate parts of the cutting model of this <em>function</em>. 
<p>
This has to be called whenever the specified function was modified so that the old aggregate subgradients and/or primal generators are no longer valid.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function</em>&nbsp;</td><td>(const <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on...">FunctionObject</a>&amp;) the function added in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#53b7500a47bd2f864092a73890c4db2c" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions...">add_function()</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="6bd691c7cb860f7f52c39ea3a28b5b63"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::call_primal_extender" ref="6bd691c7cb860f7f52c39ea3a28b5b63" args="(const FunctionObject &amp;function, PrimalExtender &amp;primal_extender)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::call_primal_extender           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConicBundle_1_1FunctionObject.html">FunctionObject</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConicBundle_1_1PrimalExtender.html">PrimalExtender</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>primal_extender</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks <em>function</em> to call <em>primal_extender</em> for each of its primal objects (see also <a class="el" href="classConicBundle_1_1FunctionOracle.html#62bbdbf390aa0a1c4a9cc983c74c9bf8" title="Called by the solver. Has to Return function value and at least one (epsilon) subgradient...">FunctionOracle::evaluate()</a> ). 
<p>
If the function is the Lagrangian dual of a primal problem and primal_data returned previous calls to the oracle has now to be updated due to changes in the primal problem -- e.g., this may happen in column generation -- the call causes updates of all internally stored primal_data objects by calling <a class="el" href="classConicBundle_1_1PrimalExtender.html#13fc586276e23d575b935dbfe12495c0" title="called by ConicBundle to update internal PrimalData objects, has to return 0 on success...">PrimalExtender::extend</a> on each of these.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>function</em>&nbsp;</td><td>(const <a class="el" href="classConicBundle_1_1FunctionObject.html" title="basic function object (abstract class). It serves for using the same interface on...">FunctionObject</a>&amp;) the function added in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#53b7500a47bd2f864092a73890c4db2c" title="Adds a function, typically derived from ConicBundle::FunctionOracle; all functions...">add_function()</a></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>primal_extender</em>&nbsp;</td><td>(<a class="el" href="classConicBundle_1_1PrimalExtender.html" title="Interface for extending PrimalData, e.g., in column generation approaches.">PrimalExtender</a>&amp;) the object holding the extension function for primal_data</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>1 if for this function it is not possible to use a primal_extender</li><li>2 if the primal_extender would be applicable but there is no primal_data </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="caa42c46986ad62af21555340346dcf4"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::set_next_weight" ref="caa42c46986ad62af21555340346dcf4" args="(const double weight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_next_weight           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>weight</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the weight (&gt;0) to be used in the quadratic term of the next augmented subproblem (may be interpreted as 1./step_size or 1./trustregion-radius). 
<p>
Independent of whether the weight violates current min- and max-bounds set in <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#6f10280eeddb360806951729b076e026" title="Sets a lower bound on the weight for the quadratic term of the augmented subproblem...">set_min_weight()</a> and <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#bd2d01b507839451c91d6574c02113c2" title="Sets an upper bound on the weight for the quadratic term of the augmented subproblem...">set_max_weight()</a>, the next model will be computed for this value. Thereafter, however, it will be updated as usual; in particular, it may be truncated by min and max bounds immediately after the first subproblem.<p>
In order to guarantee a constant weight (e.g. 1 is frequently a reasonable choice if the automatic default heuristic performs poorly), set the min and max bounds to the same value, too.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>weight</em>&nbsp;</td><td>(double)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="6f10280eeddb360806951729b076e026"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::set_min_weight" ref="6f10280eeddb360806951729b076e026" args="(const double min_weight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_min_weight           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>min_weight</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a lower bound on the weight for the quadratic term of the augmented subproblem. 
<p>
Nonpositive values indicate no bound. The new value shows its effect only at first dynamic change of the weight.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_weight</em>&nbsp;</td><td>(double)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="bd2d01b507839451c91d6574c02113c2"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::set_max_weight" ref="bd2d01b507839451c91d6574c02113c2" args="(const double max_weight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_max_weight           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>max_weight</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets an upper bound on the weight for the quadratic term of the augmented subproblem. 
<p>
Nonpositive values indicate no bound. The new value shows its effect only at first dynamic change of the weight.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>max_weight</em>&nbsp;</td><td>(double)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="ba280fdc2eca4c836412118910ebd2c1"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::adjust_multiplier" ref="ba280fdc2eca4c836412118910ebd2c1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::adjust_multiplier           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adjusts on all conic functions the penalty parameter for conic violations to twice the trace of the primal approximation. 
<p>
This routine is only needed for conic function objects such as the nonnegative cone, the second order cone and the semidefinite cone if no good upper bound on the trace of feasible points is known and has to be determined automatically.<p>
If after some time, the trace values settle, the upper bounds on the trace may be way to high and can then be reset with this call.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="f08ac2b7bda5aa84bc83b4f094755752"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::set_scaling" ref="f08ac2b7bda5aa84bc83b4f094755752" args="(bool do_scaling)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_scaling           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_scaling</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Use a scaling heuristic or switch off scaling alltogether. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="a08c108e21ff536add76511dec346b60"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::set_scaling" ref="a08c108e21ff536add76511dec346b60" args="(const CH_Matrix_Classes::Matrix &amp;scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ConicBundle::MatrixCBSolver::set_scaling           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCH__Matrix__Classes_1_1Matrix.html">CH_Matrix_Classes::Matrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>scale</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
user defined diagonal scaling, values greater than 1 allow more movement for this variable, values smaller than 1 allow less movement. 
<p>
It is the users responsibility to guarantee that the scaling vector fits in dimension to the runnig problem data, in particular if routines such as <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#97b26d313821ba567be9f4aa14c289fb" title="Append new variables (always in last postions in this order).">append_variables()</a>, <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#c1cdd25a701c8832e0ab7adabf482435" title="Deletes variables corresponding to the specified indices.">delete_variables()</a>, and <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#f32b436c2f7a655fc0190684cf6a3daa" title="Reassigns variables to new index positions by mapping to position i the variable...">reassign_variables()</a> are used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scale</em>&nbsp;</td><td>(const Matrix&amp;)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="5229f01c537d914a60b896bf01e550d5"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::set_active_bounds_fixing" ref="5229f01c537d914a60b896bf01e550d5" args="(bool allow_fixing)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConicBundle::MatrixCBSolver::set_active_bounds_fixing           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allow_fixing</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If set to true (the default is false), some variables will be fixed automatically to the center value if their bounds are strongly active (i.e., the corresponding multipliers are big). 
<p>
The coordinates to be fixed are redetermined in each call following a descent step or a change of the function. An indicator vector of the variables fixed in the last call can be obtained via the routine <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#ae88fbaba489ce4e9c994c9f0f7a8ff0" title="Returns the indicator vector of variables temporarily fixed to the center value due...">get_active_bounds_indicator()</a>.<p>
Setting this value to true might improve the performance of the algorithm in some instances but there is no convergence theory. It might be particularly helpful within Lagrangian relaxation if a primal cutting plane approach is used and non-tight inequalities should be eliminated quickly (fixing then indicates large primal slack values).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>allow_fixing</em>&nbsp;</td><td>(bool)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="9eeac5ece21d05a387eea9f755b15bff"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::clear_fail_counts" ref="9eeac5ece21d05a387eea9f755b15bff" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConicBundle::MatrixCBSolver::clear_fail_counts           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
clears all fail counts on numerical function oder model failures, may be useful if this caused premature termination. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="132338a9a8fd4c576156123cb37096a9"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::set_eval_limit" ref="132338a9a8fd4c576156123cb37096a9" args="(int eval_limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConicBundle::MatrixCBSolver::set_eval_limit           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>eval_limit</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets an upper bound on the number of calls to the oracle (use negative numbers for no limit). 
<p>
If this number is reached, the algorithm will terminate independently of whether the last step was a descent or a null step. A negative number will be interepreted as no limit.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>eval_limit</em>&nbsp;</td><td>(Integer)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="97c6dd9f9c172599bba633cd0a2a1417"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::set_inner_update_limit" ref="97c6dd9f9c172599bba633cd0a2a1417" args="(int update_limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConicBundle::MatrixCBSolver::set_inner_update_limit           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>update_limit</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set an upper bound on the number of inner updates for the cutting model with primal slacks within one null step (use negative numbers for no limit). 
<p>
A negative number will be interepreted as no limit, i.e., the updates will be done till a certain precision of the cutting model is achieved.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>update_limit</em>&nbsp;</td><td>(Integer)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>0 on success</li><li>!= 0 otherwise </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="ae88fbaba489ce4e9c994c9f0f7a8ff0"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::get_active_bounds_indicator" ref="ae88fbaba489ce4e9c994c9f0f7a8ff0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCH__Matrix__Classes_1_1Indexmatrix.html">CH_Matrix_Classes::Indexmatrix</a>&amp; ConicBundle::MatrixCBSolver::get_active_bounds_indicator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the indicator vector of variables temporarily fixed to the center value due to significantly positive multipliers for the box constraints. 
<p>
Such a fixing indicates that the corresponding variables would like to stay at their bounds. If no variables were fixed, the dimension of the vector is zero. 
</div>
</div><p>
<a class="anchor" name="370c6ee0dd593962cbb39927a56d6bce"></a><!-- doxytag: member="ConicBundle::MatrixCBSolver::set_out" ref="370c6ee0dd593962cbb39927a56d6bce" args="(std::ostream *out=0, int print_level=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConicBundle::MatrixCBSolver::set_out           </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&nbsp;</td>
          <td class="paramname"> <em>out</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>print_level</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specifies the output level (out==NULL: no output at all, out!=NULL and level=0: errors and warnings, level&gt;0 increasingly detailed information). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>out</em>&nbsp;</td><td>(ostream*) direct all output to (*out). If out==NULL, there will be no output at all.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>print_level</em>&nbsp;</td><td>(int)</td></tr>
  </table>
</dl>
Output levels for print_level:<ul>
<li>0 ... no output except for errors and warnings</li><li>1 ... line summary after each descent step</li><li>&gt;1 ... undocumented and increasingly detailed log information. These higher levels should only be used if requested for debugging purposes.</li></ul>
<p>
Example for level 1:<p>
<div class="fragment"><pre class="fragment">
00:00:00.00 endit  1   1   1   563.    563.  39041.188  39043.162
00:00:00.00 endit  2   2   2   563.    559.  38488.165  38490.200
00:00:00.00 endit  3   3   3   56.3    555.  33014.533  33211.856
00:00:00.00 endit  4   4   4   5.63    517. -14306.459  2738.0343
00:00:00.00 endit  5   5   5   4.04    148. -2692.1131  2.2150883
00:00:00.00 endit  6   6   6   4.01    1.29  1.7908952  2.0000581
00:00:00.00 endit  7   7   7   3.95  0.0213  1.9999387  2.0000000
00:00:00.00 _endit  8   8   8   3.95 2.94e-05  2.0000000  2.0000000

Column 1      2     3   4   5    6       7       8          9
</pre></div><ul>
<li>Column 1: computation time in hh:mm:ss.dd,</li><li>Column 2: "endit" is convenient for grep and stands for "end of iteration". Iterations with <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#7d7589913e95675f4bee916eb3531270" title="Returns the termination code of the bundle algorithm for the latest descent step...">termination_code()</a>!=0 are marked with "_endit".</li><li>Column 3: number of descent steps (= calls to <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#d2505f56a41772470feac50f99524fd2" title="Does a descent step for the current center point.">do_descent_step()</a>)</li><li>Column 4: number of descent and null steps. Up to initialization calls and reevaluations, this is the number of evaluation calls to the function oracles from within the bundle method. In the example all calls led to descent steps.</li><li>Column 5: number of innermost iterations. It differs from column 5 only in the case of variables with bounds in which case it gives the number of updates of the multipliers for the bounds (or primal slacks in Lagrangean relaxation). Exceedingly high numbers in this column indicate that some variables are constantly at their bounds and it might be possible to improve convergence by deleting them (i.e. set them as constants to this bound and remove the variable).</li><li>Column 6: the weight of the quadratic term in the augmented problem.</li><li>Column 7: the norm of the aggregate subgradient. If it is small, say below 0.1, then mostly this is good indication that the objective value is close to optimal.</li><li>Column 8: the value of the cutting model in the last candidate point. It is always a lower bound on the true function value in this point</li><li>Column 9: the objective value in the latest point that led to a descent step, i.e., the point returend by <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#db2eb21b8701e5d27e59c1500e3db198" title="Returns the next center point that was produced by the latest call to do_descent_step...">get_center()</a>. Whenever <a class="el" href="classConicBundle_1_1MatrixCBSolver.html#7d7589913e95675f4bee916eb3531270" title="Returns the termination code of the bundle algorithm for the latest descent step...">termination_code()</a> returns 0 this is also the objective value of the latest evaluation call to the function oracles and the value in the center point of the next iteration. </li></ul>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="MatCBSolver_8hxx-source.html">MatCBSolver.hxx</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue May 3 16:52:55 2011 for ConicBundle by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
