# SCIP version 2.1.1

# branching score function ('s'um, 'p'roduct)
# [type: char, range: {sp}, default: p]
branching/scorefunc = p

# branching score factor to weigh downward and upward gain prediction in sum score function
# [type: real, range: [0,1], default: 0.167]
branching/scorefac = 0.167

# should branching on binary variables be preferred?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
branching/preferbinary = FALSE

# minimal relative distance of branching point to bounds when branching on a continuous variable
# [type: real, range: [0,0.5], default: 0.2]
branching/clamp = 0.2

# strategy for normalization of LP gain when updating pseudocosts of continuous variables (divide by movement of 'l'p value, reduction in 'd'omain width, or reduction in domain width of 's'ibling)
# [type: char, range: {dls}, default: s]
branching/lpgainnormalize = s

# should updating pseudo costs for continuous variables be delayed to the time after separation?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
branching/delaypscostupdate = TRUE

# should conflict analysis be enabled?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
conflict/enable = TRUE

# should propagation conflict analysis be used?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
conflict/useprop = TRUE

# should infeasible LP conflict analysis be used?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
conflict/useinflp = TRUE

# should bound exceeding LP conflict analysis be used?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
conflict/useboundlp = FALSE

# should infeasible/bound exceeding strong branching conflict analysis be used?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
conflict/usesb = FALSE

# should pseudo solution conflict analysis be used?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
conflict/usepseudo = TRUE

# maximal fraction of variables involved in a conflict constraint
# [type: real, range: [0,1.79769313486232e+308], default: 0.1]
conflict/maxvarsfac = 0.1

# minimal absolute maximum of variables involved in a conflict constraint
# [type: int, range: [0,2147483647], default: 30]
conflict/minmaxvars = 30

# maximal number of LP resolving loops during conflict analysis (-1: no limit)
# [type: int, range: [-1,2147483647], default: 2]
conflict/maxlploops = 2

# maximal number of LP iterations in each LP resolving loop (-1: no limit)
# [type: int, range: [-1,2147483647], default: 10]
conflict/lpiterations = 10

# number of depth levels up to which first UIP's are used in conflict analysis (-1: use All-FirstUIP rule)
# [type: int, range: [-1,2147483647], default: -1]
conflict/fuiplevels = -1

# maximal number of intermediate conflict constraints generated in conflict graph (-1: use every intermediate constraint)
# [type: int, range: [-1,2147483647], default: -1]
conflict/interconss = -1

# number of depth levels up to which UIP reconvergence constraints are generated (-1: generate reconvergence constraints in all depth levels)
# [type: int, range: [-1,2147483647], default: -1]
conflict/reconvlevels = -1

# maximal number of conflict constraints accepted at an infeasible node (-1: use all generated conflict constraints)
# [type: int, range: [-1,2147483647], default: 10]
conflict/maxconss = 10

# should binary conflicts be preferred?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
conflict/preferbinary = FALSE

# should conflict constraints be generated that are only valid locally?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
conflict/allowlocal = TRUE

# should conflict constraints be attached only to the local subtree where they can be useful?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
conflict/settlelocal = FALSE

# should earlier nodes be repropagated in order to replace branching decisions by deductions?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
conflict/repropagate = TRUE

# should constraints be kept for repropagation even if they are too long?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
conflict/keepreprop = TRUE

# should the conflict constraints be separated?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
conflict/separate = TRUE

# should the conflict constraints be subject to aging?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
conflict/dynamic = TRUE

# should the conflict's relaxations be subject to LP aging and cleanup?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
conflict/removable = TRUE

# score factor for depth level in bound relaxation heuristic of LP analysis
# [type: real, range: [-1.79769313486232e+308,1.79769313486232e+308], default: 1]
conflict/depthscorefac = 1

# factor to decrease importance of variables' earlier conflict scores
# [type: real, range: [1e-06,1], default: 0.98]
conflict/scorefac = 0.98

# number of successful conflict analysis calls that trigger a restart (0: disable conflict restarts)
# [type: int, range: [0,2147483647], default: 0]
conflict/restartnum = 0

# factor to increase restartnum with after each restart
# [type: real, range: [0,1.79769313486232e+308], default: 1.5]
conflict/restartfac = 1.5

# maximum age an unnecessary constraint can reach before it is deleted (0: dynamic, -1: keep all constraints)
# [type: int, range: [-1,2147483647], default: 0]
constraints/agelimit = 0

# age of a constraint after which it is marked obsolete (0: dynamic, -1 do not mark constraints obsolete)
# [type: int, range: [-1,2147483647], default: -1]
constraints/obsoleteage = -1

# should enforcement of pseudo solution be disabled?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/disableenfops = FALSE

# verbosity level of output
# [type: int, range: [0,5], default: 4]
display/verblevel = 4

# maximal number of characters in a node information line
# [type: int, range: [0,2147483647], default: 139]
display/width = 139

# frequency for displaying node information lines
# [type: int, range: [-1,2147483647], default: 100]
display/freq = 100

# frequency for displaying header lines (every n'th node information line)
# [type: int, range: [-1,2147483647], default: 15]
display/headerfreq = 15

# should the LP solver display status messages?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
display/lpinfo = FALSE

# maximal time in seconds to run
# [type: real, range: [0,1.79769313486232e+308], default: 1e+20]
limits/time = 1e+20

# maximal number of nodes to process (-1: no limit)
# [type: longint, range: [-1,9223372036854775807], default: -1]
limits/nodes = -1

# solving stops, if the given number of nodes was processed since the last improvement of the primal solution value (-1: no limit)
# [type: longint, range: [-1,9223372036854775807], default: -1]
limits/stallnodes = -1

# maximal memory usage in MB; reported memory usage is lower than real memory usage!
# [type: real, range: [0,1.79769313486232e+308], default: 1e+20]
limits/memory = 1e+20

# solving stops, if the relative gap = |primal - dual|/MIN(|dual|,|primal|) is below the given value
# [type: real, range: [0,1.79769313486232e+308], default: 0]
limits/gap = 0

# solving stops, if the absolute gap = |primalbound - dualbound| is below the given value
# [type: real, range: [0,1.79769313486232e+308], default: 0]
limits/absgap = 0

# solving stops, if the given number of solutions were found (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
limits/solutions = -1

# solving stops, if the given number of solution improvements were found (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
limits/bestsol = -1

# maximal number of solutions to store in the solution storage
# [type: int, range: [1,2147483647], default: 100]
limits/maxsol = 100

# maximal number of solutions candidates to store in the solution storage of the original problem
# [type: int, range: [0,2147483647], default: 10]
limits/maxorigsol = 10

# solving stops, if the given number of restarts was triggered (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
limits/restarts = -1

# frequency for solving LP at the nodes (-1: never; 0: only root LP)
# [type: int, range: [-1,2147483647], default: 1]
lp/solvefreq = 1

# maximal depth for solving LP at the nodes (-1: no depth limit)
# [type: int, range: [-1,2147483647], default: -1]
lp/solvedepth = -1

# LP algorithm for solving initial LP relaxations (automatic 's'implex, 'p'rimal simplex, 'd'ual simplex, 'b'arrier, barrier with 'c'rossover)
# [type: char, range: {spdbc}, default: s]
lp/initalgorithm = s

# LP algorithm for resolving LP relaxations if a starting basis exists (automatic 's'implex, 'p'rimal simplex, 'd'ual simplex, 'b'arrier, barrier with 'c'rossover)
# [type: char, range: {spdbc}, default: s]
lp/resolvealgorithm = s

# LP pricing strategy ('l'pi default, 'a'uto, 'f'ull pricing, 'p'artial, 's'teepest edge pricing, 'q'uickstart steepest edge pricing, 'd'evex pricing)
# [type: char, range: {lafpsqd}, default: l]
lp/pricing = l

# should lp state be cleared at the end of probing mode when lp was initially unsolved, e.g., when called right after presolving?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
lp/clearinitialprobinglp = TRUE

# should the LP be resolved to restore the state at start of diving (if FALSE we buffer the solution values)?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
lp/resolverestore = FALSE

# should the buffers for storing LP solution values during diving be freed at end of diving?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
lp/freesolvalbuffers = FALSE

# maximum age a dynamic column can reach before it is deleted from the LP (-1: don't delete columns due to aging)
# [type: int, range: [-1,2147483647], default: 10]
lp/colagelimit = 10

# maximum age a dynamic row can reach before it is deleted from the LP (-1: don't delete rows due to aging)
# [type: int, range: [-1,2147483647], default: 10]
lp/rowagelimit = 10

# should new non-basic columns be removed after LP solving?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
lp/cleanupcols = FALSE

# should new non-basic columns be removed after root LP solving?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
lp/cleanupcolsroot = FALSE

# should new basic rows be removed after LP solving?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
lp/cleanuprows = TRUE

# should new basic rows be removed after root LP solving?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
lp/cleanuprowsroot = TRUE

# should LP solver's return status be checked for stability?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
lp/checkstability = TRUE

# should LP solutions be checked, resolving LP when numerical troubles occur?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
lp/checkfeas = TRUE

# which FASTMIP setting of LP solver should be used? 0: off, 1: low
# [type: int, range: [0,1], default: 1]
lp/fastmip = 1

# should scaling of LP solver be used?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
lp/scaling = TRUE

# should presolving of LP solver be used?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
lp/presolving = TRUE

# should the lexicographic dual alogrithm be used?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
lp/lexdualalgo = FALSE

# should the lexicographic dual algorithm be applied only at the root node
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
lp/lexdualrootonly = TRUE

# maximum number of rounds in the  lexicographic dual algorithm (-1: unbounded)
# [type: int, range: [-1,2147483647], default: 2]
lp/lexdualmaxrounds = 2

# choose fractional basic variables in lexicographic dual algorithm?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
lp/lexdualbasic = FALSE

# turn on the lex dual algorithm only when stalling?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
lp/lexdualstalling = TRUE

# simplex algorithm shall use row representation of the basis if number of rows divided by number of columns exceeds this value
# [type: real, range: [0,1.79769313486232e+308], default: 1e+20]
lp/rowrepswitch = 1e+20

# number of threads used for solving the LP (0: automatic)
# [type: int, range: [0,64], default: 0]
lp/threads = 0

# factor of average LP iterations that is used as LP iteration limit for LP resolve (-1: unlimited)
# [type: real, range: [-1,1.79769313486232e+308], default: -1]
lp/resolveiterfac = -1

# minimum number of iterations that are allowed for LP resolve
# [type: int, range: [1,2147483647], default: 1000]
lp/resolveitermin = 1000

# solver to use for solving NLPs; leave empty to select NLPI with highest priority
# [type: string, default: ""]
nlp/solver = ""

# should the NLP be disabled?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
nlp/disable = FALSE

# fraction of maximal memory usage resulting in switch to memory saving mode
# [type: real, range: [0,1], default: 0.8]
memory/savefac = 0.8

# memory growing factor for dynamically allocated arrays
# [type: real, range: [1,10], default: 1.2]
memory/arraygrowfac = 1.2

# initial size of dynamically allocated arrays
# [type: int, range: [0,2147483647], default: 4]
memory/arraygrowinit = 4

# memory growing factor for tree array
# [type: real, range: [1,10], default: 2]
memory/treegrowfac = 2

# initial size of tree array
# [type: int, range: [0,2147483647], default: 65536]
memory/treegrowinit = 65536

# memory growing factor for path array
# [type: real, range: [1,10], default: 2]
memory/pathgrowfac = 2

# initial size of path array
# [type: int, range: [0,2147483647], default: 256]
memory/pathgrowinit = 256

# should the CTRL-C interrupt be caught by SCIP?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
misc/catchctrlc = TRUE

# should a hashtable be used to map from variable names to variables?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
misc/usevartable = TRUE

# should a hashtable be used to map from constraint names to constraints?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
misc/useconstable = TRUE

# should smaller hashtables be used? yields better performance for small problems with about 100 variables
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
misc/usesmalltables = FALSE

# seed value for permuting the problem after the problem was transformed (-1: no permutation)
# [type: int, range: [-1,2147483647], default: -1]
misc/permutationseed = -1

# should the statistics be reseted if the transformed problem is freed (in case of a benders decomposition this parameter should be set to FALSE)
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
misc/resetstat = TRUE

# should only solutions be checked which improve the primal bound
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
misc/improvingsols = FALSE

# should the reason be printed if a given start solution is infeasible
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
misc/printreason = TRUE

# child selection rule ('d'own, 'u'p, 'p'seudo costs, 'i'nference, 'l'p value, 'r'oot LP value difference, 'h'ybrid inference/root LP value difference)
# [type: char, range: {dupilrh}, default: h]
nodeselection/childsel = h

# values larger than this are considered infinity
# [type: real, range: [10000000000,1e+98], default: 1e+20]
numerics/infinity = 1e+20

# absolute values smaller than this are considered zero
# [type: real, range: [1e-20,0.001], default: 1e-09]
numerics/epsilon = 1e-09

# absolute values of sums smaller than this are considered zero
# [type: real, range: [1e-17,0.001], default: 1e-06]
numerics/sumepsilon = 1e-06

# feasibility tolerance for constraints
# [type: real, range: [1e-17,0.001], default: 1e-06]
numerics/feastol = 1e-06

# feasibility tolerance for reduced costs in LP solution
# [type: real, range: [1e-17,0.001], default: 1e-09]
numerics/dualfeastol = 1e-09

# LP convergence tolerance used in barrier algorithm
# [type: real, range: [1e-17,0.001], default: 1e-10]
numerics/barrierconvtol = 1e-10

# minimal relative improve for strengthening bounds
# [type: real, range: [1e-17,1e+98], default: 0.05]
numerics/boundstreps = 0.05

# minimal variable distance value to use for branching pseudo cost updates
# [type: real, range: [1e-17,1], default: 0.1]
numerics/pseudocosteps = 0.1

# minimal objective distance value to use for branching pseudo cost updates
# [type: real, range: [0,1.79769313486232e+308], default: 0.0001]
numerics/pseudocostdelta = 0.0001

# maximal number of presolving rounds (-1: unlimited, 0: off)
# [type: int, range: [-1,2147483647], default: -1]
presolving/maxrounds = -1

# abort presolve, if at most this fraction of the problem was changed in last presolve round
# [type: real, range: [0,1], default: 0.0001]
presolving/abortfac = 0.0001

# maximal number of restarts (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
presolving/maxrestarts = -1

# fraction of integer variables that were fixed in the root node triggering a restart with preprocessing after root node evaluation
# [type: real, range: [0,1], default: 0.05]
presolving/restartfac = 0.05

# fraction of integer variables that were fixed in the root node triggering an immediate restart with preprocessing
# [type: real, range: [0,1], default: 0.2]
presolving/immrestartfac = 0.2

# fraction of integer variables that were globally fixed during the solving process triggering a restart with preprocessing
# [type: real, range: [0,1], default: 1]
presolving/subrestartfac = 1

# minimal fraction of integer variables removed after restart to allow for an additional restart
# [type: real, range: [0,1], default: 0.1]
presolving/restartminred = 0.1

# should multi-aggregation of variables be forbidden?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
presolving/donotmultaggr = FALSE

# should aggregation of variables be forbidden?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
presolving/donotaggr = FALSE

# maximal number of variables priced in per pricing round
# [type: int, range: [1,2147483647], default: 100]
pricing/maxvars = 100

# maximal number of priced variables at the root node
# [type: int, range: [1,2147483647], default: 2000]
pricing/maxvarsroot = 2000

# pricing is aborted, if fac * pricing/maxvars pricing candidates were found
# [type: real, range: [1,1.79769313486232e+308], default: 2]
pricing/abortfac = 2

# should variables created at the current node be deleted when the node is solved in case they are not present in the LP anymore?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
pricing/delvars = FALSE

# should variables created at the root node be deleted when the root is solved in case they are not present in the LP anymore?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
pricing/delvarsroot = FALSE

# maximal number of propagation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 100]
propagating/maxrounds = 100

# maximal number of propagation rounds in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 1000]
propagating/maxroundsroot = 1000

# should propagation be aborted immediately? setting this to FALSE could help conflict analysis to produce more conflict constraints
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
propagating/abortoncutoff = TRUE

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separation (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 1]
separating/maxbounddist = 1

# minimal efficacy for a cut to enter the LP
# [type: real, range: [0,1e+98], default: 0.05]
separating/minefficacy = 0.05

# minimal efficacy for a cut to enter the LP in the root node
# [type: real, range: [0,1e+98], default: 0.01]
separating/minefficacyroot = 0.01

# minimal orthogonality for a cut to enter the LP
# [type: real, range: [0,1], default: 0.5]
separating/minortho = 0.5

# minimal orthogonality for a cut to enter the LP in the root node
# [type: real, range: [0,1], default: 0.5]
separating/minorthoroot = 0.5

# factor to scale objective parallelism of cut in separation score calculation
# [type: real, range: [0,1e+98], default: 0.0001]
separating/objparalfac = 0.0001

# factor to scale orthogonality of cut in separation score calculation (0.0 to disable orthogonality calculation)
# [type: real, range: [0,1e+98], default: 1]
separating/orthofac = 1

# function used for calc. scalar prod. in orthogonality test ('e'uclidean, 'd'iscrete)
# [type: char, range: {ed}, default: e]
separating/orthofunc = e

# row norm to use for efficacy calculation ('e'uclidean, 'm'aximum, 's'um, 'd'iscrete)
# [type: char, range: {emsd}, default: e]
separating/efficacynorm = e

# maximal number of runs for which separation is enabled (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
separating/maxruns = -1

# maximal number of separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
separating/maxrounds = 5

# maximal number of separation rounds in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
separating/maxroundsroot = -1

# maximal number of separation rounds in the root node of a subsequent run (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 1]
separating/maxroundsrootsubrun = 1

# maximal additional number of separation rounds in subsequent price-and-cut loops (-1: no additional restriction)
# [type: int, range: [-1,2147483647], default: 1]
separating/maxaddrounds = 1

# maximal number of consecutive separation rounds without objective or integrality improvement (-1: no additional restriction)
# [type: int, range: [-1,2147483647], default: 5]
separating/maxstallrounds = 5

# maximal number of cuts separated per separation round (0: disable local separation)
# [type: int, range: [0,2147483647], default: 100]
separating/maxcuts = 100

# maximal number of separated cuts at the root node (0: disable root node separation)
# [type: int, range: [0,2147483647], default: 2000]
separating/maxcutsroot = 2000

# maximum age a cut can reach before it is deleted from the global cut pool, or -1 to keep all cuts
# [type: int, range: [-1,2147483647], default: 100]
separating/cutagelimit = 100

# separation frequency for the global cut pool (-1: disable global cut pool, 0: only separate pool at the root)
# [type: int, range: [-1,2147483647], default: 0]
separating/poolfreq = 0

# default clock type (1: CPU user seconds, 2: wall clock time)
# [type: int, range: [1,2], default: 1]
timing/clocktype = 1

# is timing enabled?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
timing/enabled = TRUE

# belongs reading time to solving time?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
timing/reading = FALSE

# name of the VBC Tool output file, or - if no VBC Tool output should be created
# [type: string, default: "-"]
vbc/filename = "-"

# should the real solving time be used instead of a time step counter in VBC output?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
vbc/realtime = TRUE

# should the node where solutions are found be visualized?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
vbc/dispsols = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/nonlinear/sepafreq = 1

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/nonlinear/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/nonlinear/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/nonlinear/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/nonlinear/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/nonlinear/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/nonlinear/delaypresol = FALSE

# minimal efficacy for a cut to be added to the LP during separation; overwrites separating/efficacy
# [type: real, range: [0,1e+20], default: 0.0001]
constraints/nonlinear/minefficacysepa = 0.0001

# minimal target efficacy of a cut in order to add it to relaxation during enforcement as a factor of the feasibility tolerance (may be ignored)
# [type: real, range: [1,1e+20], default: 2]
constraints/nonlinear/minefficacyenfofac = 2

# maximal coef range of a cut (maximal coefficient divided by minimal coefficient) in order to be added to LP relaxation
# [type: real, range: [0,1e+20], default: 10000000]
constraints/nonlinear/cutmaxrange = 10000000

# whether to try to make solutions in check function feasible by shifting a linear variable (esp. useful if constraint was actually objective function)
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/nonlinear/linfeasshift = TRUE

# whether to assume that nonlinear functions in inequalities (<=) are convex (disables reformulation)
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/nonlinear/assumeconvex = FALSE

# limit on number of propagation rounds for a single constraint within one round of SCIP propagation
# [type: int, range: [0,2147483647], default: 1]
constraints/nonlinear/maxproprounds = 1

# whether to reformulate expression graph
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/nonlinear/reformulate = TRUE

# maximal exponent where still expanding non-monomial polynomials in expression simplification
# [type: int, range: [1,2147483647], default: 2]
constraints/nonlinear/maxexpansionexponent = 2

# minimal required fraction of continuous variables in problem to use solution of NLP relaxation in root for separation
# [type: real, range: [0,2], default: 1]
constraints/nonlinear/sepanlpmincont = 1

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/quadratic/sepafreq = 1

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/quadratic/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/quadratic/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/quadratic/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/quadratic/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/quadratic/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/quadratic/delaypresol = FALSE

# max. length of linear term which when multiplied with a binary variables is replaced by an auxiliary variable and a linear reformulation (0 to turn off)
# [type: int, range: [0,2147483647], default: 2147483647]
constraints/quadratic/replacebinaryprod = 2147483647

# empathy level for using the AND constraint handler: 0 always avoid using AND; 1 use AND sometimes; 2 use AND as often as possible
# [type: int, range: [0,2], default: 0]
constraints/quadratic/empathy4and = 0

# whether to make non-varbound linear constraints added due to replacing products with binary variables initial
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/quadratic/binreforminitial = FALSE

# minimal efficacy for a cut to be added to the LP during separation; overwrites separating/efficacy
# [type: real, range: [0,1e+20], default: 0.0001]
constraints/quadratic/minefficacysepa = 0.0001

# minimal target efficacy of a cut in order to add it to relaxation during enforcement as a factor of the feasibility tolerance (may be ignored)
# [type: real, range: [1,1e+20], default: 2]
constraints/quadratic/minefficacyenfofac = 2

# whether a quadratic constraint should be scaled w.r.t. the current gradient norm when checking for feasibility
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/quadratic/scaling = TRUE

# a default bound to impose on unbounded variables in quadratic terms (-defaultbound is used for missing lower bounds)
# [type: real, range: [0,1e+20], default: 1e+20]
constraints/quadratic/defaultbound = 1e+20

# maximal coef range of a cut (maximal coefficient divided by minimal coefficient) in order to be added to LP relaxation
# [type: real, range: [0,1e+20], default: 10000000]
constraints/quadratic/cutmaxrange = 10000000

# whether linearizations of convex quadratic constraints should be added to cutpool in a solution found by some heuristic
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/quadratic/linearizeheursol = TRUE

# whether multivariate quadratic functions should be checked for convexity/concavity
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/quadratic/checkcurvature = TRUE

# whether constraint functions should be checked to be factorable
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/quadratic/checkfactorable = TRUE

# whether to try to make solutions in check function feasible by shifting a linear variable (esp. useful if constraint was actually objective function)
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/quadratic/linfeasshift = TRUE

# whether to disaggregate quadratic parts that decompose into a sum of non-overlapping quadratic terms
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/quadratic/disaggregate = FALSE

# limit on number of propagation rounds for a single constraint within one round of SCIP propagation during solve
# [type: int, range: [0,2147483647], default: 1]
constraints/quadratic/maxproprounds = 1

# limit on number of propagation rounds for a single constraint within one round of SCIP presolve
# [type: int, range: [0,2147483647], default: 10]
constraints/quadratic/maxproproundspresolve = 10

# minimal required fraction of continuous variables in problem to use solution of NLP relaxation in root for separation
# [type: real, range: [0,2], default: 1]
constraints/quadratic/sepanlpmincont = 1

# enable nonlinear upgrading for constraint handler <quadratic>
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/nonlinear/upgrade/quadratic = TRUE

# priority of conflict handler <linear>
# [type: int, range: [-2147483648,2147483647], default: -1000000]
conflict/linear/priority = -1000000

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/linear/sepafreq = 0

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/linear/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/linear/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/linear/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/linear/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/linear/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/linear/delaypresol = FALSE

# enable quadratic upgrading for constraint handler <linear>
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/quadratic/upgrade/linear = TRUE

# enable nonlinear upgrading for constraint handler <linear>
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/nonlinear/upgrade/linear = TRUE

# multiplier on propagation frequency, how often the bounds are tightened (-1: never, 0: only at root)
# [type: int, range: [-1,2147483647], default: 1]
constraints/linear/tightenboundsfreq = 1

# maximal number of separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
constraints/linear/maxrounds = 5

# maximal number of separation rounds per node in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
constraints/linear/maxroundsroot = -1

# maximal number of cuts separated per separation round
# [type: int, range: [0,2147483647], default: 50]
constraints/linear/maxsepacuts = 50

# maximal number of cuts separated per separation round in the root node
# [type: int, range: [0,2147483647], default: 200]
constraints/linear/maxsepacutsroot = 200

# should pairwise constraint comparison be performed in presolving?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/linear/presolpairwise = TRUE

# should hash table be used for detecting redundant constraints in advance
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/linear/presolusehashing = TRUE

# number for minimal pairwise presolve comparisons
# [type: int, range: [1,2147483647], default: 200000]
constraints/linear/nmincomparisons = 200000

# minimal gain per minimal pairwise presolve comparisons to repeat pairwise comparison round
# [type: real, range: [0,1.79769313486232e+308], default: 1e-06]
constraints/linear/mingainpernmincomparisons = 1e-06

# maximal allowed relative gain in maximum norm for constraint aggregation (0.0: disable constraint aggregation)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
constraints/linear/maxaggrnormscale = 0

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for separating knapsack cardinality cuts
# [type: real, range: [0,1], default: 0]
constraints/linear/maxcardbounddist = 0

# should all constraints be subject to cardinality cut generation instead of only the ones with non-zero dual value?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/linear/separateall = FALSE

# should presolving search for aggregations in equations
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/linear/aggregatevariables = TRUE

# should presolving try to simplify inequalities
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/linear/simplifyinequalities = FALSE

# should dual presolving steps be performed?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/linear/dualpresolving = TRUE

# apply binaries sorting in decr. order of coeff abs value?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/linear/sortvars = TRUE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/abspower/sepafreq = 1

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/abspower/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/abspower/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/abspower/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/abspower/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/abspower/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/abspower/delaypresol = FALSE

# enable quadratic upgrading for constraint handler <abspower>
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/quadratic/upgrade/abspower = TRUE

# enable nonlinear upgrading for constraint handler <abspower>
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/nonlinear/upgrade/abspower = TRUE

# minimal efficacy for a cut to be added to the LP during separation; overwrites separating/efficacy
# [type: real, range: [0,1e+20], default: 0.0001]
constraints/abspower/minefficacysepa = 0.0001

# minimal target efficacy of a cut in order to add it to relaxation during enforcement as factor of feasibility tolerance (may be ignored)
# [type: real, range: [1,1e+20], default: 2]
constraints/abspower/minefficacyenfofac = 2

# maximal coef range of a cut (maximal coefficient divided by minimal coefficient) in order to be added to LP relaxation
# [type: real, range: [0,1e+20], default: 10000000]
constraints/abspower/cutmaxrange = 10000000

# whether to project the reference point when linearizing an absolute power constraint in a convex region
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/abspower/projectrefpoint = TRUE

# how much to prefer branching on 0.0 when sign of variable is not fixed yet: 0 no preference, 1 prefer if LP solution will be cutoff in both child nodes, 2 prefer always, 3 ensure always
# [type: int, range: [0,3], default: 1]
constraints/abspower/preferzerobranch = 1

# whether to compute branching point such that the convexification error is minimized (after branching on 0.0)
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/abspower/branchminconverror = FALSE

# should variable bounds be added to the cutpool?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/abspower/addvarbounds = TRUE

# whether to try to make solutions in check function feasible by shifting the linear variable z
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/abspower/linfeasshift = TRUE

# whether to separate linearization cuts only in the variable bounds (does not affect enforcement)
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/abspower/sepainboundsonly = FALSE

# minimal required fraction of continuous variables in problem to use solution of NLP relaxation in root for separation
# [type: real, range: [0,2], default: 1]
constraints/abspower/sepanlpmincont = 1

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/and/sepafreq = 1

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/and/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/and/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/and/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/and/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/and/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/and/delaypresol = FALSE

# should pairwise constraint comparison be performed in presolving?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/and/presolpairwise = TRUE

# should hash table be used for detecting redundant constraints in advance
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/and/presolusehashing = TRUE

# should the "and" constraint get linearized and removed (in presolving)?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/and/linearize = FALSE

# should cuts be separated during LP enforcing?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/and/enforcecuts = TRUE

# should an aggregated linearization be used?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/and/aggrlinearization = FALSE

# enable nonlinear upgrading for constraint handler <and>
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/nonlinear/upgrade/and = TRUE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/bivariate/sepafreq = 1

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/bivariate/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/bivariate/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/bivariate/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/bivariate/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/bivariate/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/bivariate/delaypresol = FALSE

# enable quadratic upgrading for constraint handler <bivariate>
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/quadratic/upgrade/bivariate = FALSE

# enable nonlinear upgrading for constraint handler <bivariate>
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/nonlinear/upgrade/bivariate = FALSE

# minimal efficacy for a cut to be added to the LP during separation; overwrites separating/efficacy
# [type: real, range: [0,1e+20], default: 0.0001]
constraints/bivariate/minefficacysepa = 0.0001

# minimal target efficacy of a cut in order to add it to relaxation during enforcement (may be ignored)
# [type: real, range: [0,1e+20], default: 2e-06]
constraints/bivariate/minefficacyenfo = 2e-06

# maximal coef range of a cut (maximal coefficient divided by minimal coefficient) in order to be added to LP relaxation
# [type: real, range: [0,1e+20], default: 10000000]
constraints/bivariate/cutmaxrange = 10000000

# whether to try to make solutions in check function feasible by shifting a linear variable (esp. useful if constraint was actually objective function)
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/bivariate/linfeasshift = TRUE

# limit on number of propagation rounds for a single constraint within one round of SCIP propagation
# [type: int, range: [0,2147483647], default: 1]
constraints/bivariate/maxproprounds = 1

# number of reference points in each direction where to compute linear support for envelope in LP initialization
# [type: int, range: [0,2147483647], default: 3]
constraints/bivariate/ninitlprefpoints = 3

# maximal percantage of continuous variables within a conflict
# [type: real, range: [0,1], default: 0.4]
conflict/bounddisjunction/continuousfrac = 0.4

# priority of conflict handler <bounddisjunction>
# [type: int, range: [-2147483648,2147483647], default: -3000000]
conflict/bounddisjunction/priority = -3000000

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
constraints/bounddisjunction/sepafreq = -1

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/bounddisjunction/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/bounddisjunction/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/bounddisjunction/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/bounddisjunction/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/bounddisjunction/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/bounddisjunction/delaypresol = FALSE

# enable quadratic upgrading for constraint handler <bounddisjunction>
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/quadratic/upgrade/bounddisjunction = TRUE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
constraints/conjunction/sepafreq = -1

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
constraints/conjunction/propfreq = -1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/conjunction/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/conjunction/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/conjunction/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/conjunction/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/conjunction/delaypresol = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
constraints/countsols/sepafreq = -1

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
constraints/countsols/propfreq = -1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/countsols/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: 0]
constraints/countsols/maxprerounds = 0

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/countsols/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/countsols/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/countsols/delaypresol = FALSE

# is the constraint handler active?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/countsols/active = FALSE

# should the sparse solution test be turned on?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/countsols/sparsetest = TRUE

# is it allowed to discard solutions?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/countsols/discardsols = TRUE

# should the solutions be collected?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/countsols/collect = FALSE

# counting stops, if the given number of solutions were found (-1: no limit)
# [type: longint, range: [-1,9223372036854775807], default: -1]
constraints/countsols/sollimit = -1

# display activation status of display column <sols> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 0]
display/sols/active = 0

# display activation status of display column <feasST> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 0]
display/feasST/active = 0

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/cumulative/sepafreq = 1

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/cumulative/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/cumulative/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/cumulative/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/cumulative/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/cumulative/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/cumulative/delaypresol = FALSE

# should the binary representation be used?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/cumulative/usebinvars = FALSE

# should coretimes be propagated?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/cumulative/usecoretimes = TRUE

# should coretimes be propagated to detect holes?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/cumulative/usecoretimesholes = FALSE

# should cuts be added only locally?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/cumulative/localcuts = FALSE

# should covering cuts be added every node?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/cumulative/usecovercuts = TRUE

# should edge finding be used?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/cumulative/useedgefinding = FALSE

# should energetic reasoning be used?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/cumulative/useenergeticreasoning = FALSE

# should the cumulative constraint create cuts as knapsack constraints?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/cumulative/cutsasconss = TRUE

# maximum nodes to solve an independent cumulative constraint (-1: no limit)
# [type: longint, range: [-1,9223372036854775807], default: 500]
constraints/cumulative/maxnodes = 500

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
constraints/disjunction/sepafreq = -1

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
constraints/disjunction/propfreq = -1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/disjunction/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/disjunction/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/disjunction/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/disjunction/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/disjunction/delaypresol = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 10]
constraints/indicator/sepafreq = 10

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/indicator/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/indicator/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/indicator/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/delaypresol = FALSE

# priority of conflict handler <indicatorconflict>
# [type: int, range: [-2147483648,2147483647], default: 200000]
conflict/indicatorconflict/priority = 200000

# Branch on indicator constraints in enforcing?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/branchindicators = FALSE

# Generate logicor constraints instead of cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/genlogicor = FALSE

# add initial coupling inequalities
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/indicator/addcoupling = TRUE

# add initial coupling inequalities as linear constraints, if 'addcoupling' is true
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/addcouplingcons = FALSE

# remove indicator constraint if corresponding variable bound constraint has been added?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/removeindicators = FALSE

# Update bounds of original variables for separation?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/updatebounds = FALSE

# Try to make solutions feasible by setting indicator variables?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/indicator/trysolutions = TRUE

# in enforcing try to generate cuts (only if sepaalternativelp is true)
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/enforcecuts = FALSE

# maximum coefficient for binary variable in coupling constraint
# [type: real, range: [0,1000000000], default: 10000]
constraints/indicator/maxcouplingvalue = 10000

# maximum estimated condition of the solution basis matrix of the alternative LP to be trustworthy (0.0 to disable check)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
constraints/indicator/maxconditionaltlp = 0

# do not generate indicator constraint, but a bilinear constraint instead
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/generatebilinear = FALSE

# Try to upgrade bounddisjunction conflicts by replacing slack variables?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/conflictsupgrade = FALSE

# fraction of binary variables that need to be fixed before restart occurs (in forcerestart)
# [type: real, range: [0,1], default: 0.9]
constraints/indicator/restartfrac = 0.9

# Separate using the alternative LP?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/sepaalternativelp = FALSE

# force restart if we have a max FS instance and gap is 1?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/forcerestart = FALSE

# decompose problem - do not generate linear constraint if all variables are continuous
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/nolinconscont = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
constraints/integral/sepafreq = -1

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
constraints/integral/propfreq = -1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: -1]
constraints/integral/eagerfreq = -1

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/integral/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/integral/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/integral/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/integral/delaypresol = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/knapsack/sepafreq = 0

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/knapsack/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/knapsack/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/knapsack/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/knapsack/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/knapsack/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/knapsack/delaypresol = FALSE

# enable linear upgrading for constraint handler <knapsack>
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/linear/upgrade/knapsack = TRUE

# multiplier on separation frequency, how often knapsack cuts are separated (-1: never, 0: only at root)
# [type: int, range: [-1,2147483647], default: 1]
constraints/knapsack/sepacardfreq = 1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for separating knapsack cuts
# [type: real, range: [0,1], default: 0]
constraints/knapsack/maxcardbounddist = 0

# maximal number of separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
constraints/knapsack/maxrounds = 5

# maximal number of separation rounds per node in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
constraints/knapsack/maxroundsroot = -1

# maximal number of cuts separated per separation round
# [type: int, range: [0,2147483647], default: 50]
constraints/knapsack/maxsepacuts = 50

# maximal number of cuts separated per separation round in the root node
# [type: int, range: [0,2147483647], default: 200]
constraints/knapsack/maxsepacutsroot = 200

# should disaggregation of knapsack constraints be allowed in preprocessing?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/knapsack/disaggregation = TRUE

# should presolving try to simplify knapsacks
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/knapsack/simplifyinequalities = FALSE

# should negated clique information be used in solving process
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/knapsack/negatedclique = TRUE

# should pairwise constraint comparison be performed in presolving?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/knapsack/presolpairwise = TRUE

# should hash table be used for detecting redundant constraints in advance
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/knapsack/presolusehashing = TRUE

# should dual presolving steps be performed?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/knapsack/dualpresolving = TRUE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/linking/sepafreq = 1

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/linking/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/linking/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/linking/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/linking/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/linking/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/linking/delaypresol = FALSE

# this constraint will not propagate or separate, linear and setppc are used?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/linking/linearize = FALSE

# priority of conflict handler <logicor>
# [type: int, range: [-2147483648,2147483647], default: 800000]
conflict/logicor/priority = 800000

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/logicor/sepafreq = 0

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/logicor/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/logicor/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/logicor/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/logicor/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/logicor/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/logicor/delaypresol = FALSE

# enable linear upgrading for constraint handler <logicor>
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/linear/upgrade/logicor = TRUE

# should pairwise constraint comparison be performed in presolving?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/logicor/presolpairwise = TRUE

# should hash table be used for detecting redundant constraints in advance
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/logicor/presolusehashing = TRUE

# should dual presolving steps be performed?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/logicor/dualpresolving = TRUE

# should negated clique information be used in presolving
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/logicor/negatedclique = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/or/sepafreq = 0

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/or/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/or/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/or/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/or/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/or/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/or/delaypresol = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 5]
constraints/orbitope/sepafreq = 5

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
constraints/orbitope/propfreq = -1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: -1]
constraints/orbitope/eagerfreq = -1

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/orbitope/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/orbitope/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/orbitope/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/orbitope/delaypresol = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
constraints/pseudoboolean/sepafreq = -1

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
constraints/pseudoboolean/propfreq = -1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/pseudoboolean/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/pseudoboolean/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/pseudoboolean/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/pseudoboolean/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/pseudoboolean/delaypresol = FALSE

# decompose the pseudo boolean constraint into a "linear" constraint "and" constraints
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/pseudoboolean/decompose = TRUE

# if decomposed, should the nonlinear constraints be separated during LP processing?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/pseudoboolean/nlcseparate = TRUE

# if decomposed, should the nonlinear constraints be propagated during node processing?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/pseudoboolean/nlcpropagate = TRUE

# if decomposed, should the nonlinear constraints be removable?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/pseudoboolean/nlcremovable = TRUE

# priority of conflict handler <setppc>
# [type: int, range: [-2147483648,2147483647], default: 700000]
conflict/setppc/priority = 700000

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/setppc/sepafreq = 0

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/setppc/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/setppc/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/setppc/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/setppc/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/setppc/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/setppc/delaypresol = FALSE

# enable linear upgrading for constraint handler <setppc>
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/linear/upgrade/setppc = TRUE

# number of children created in pseudo branching (0: disable pseudo branching)
# [type: int, range: [0,2147483647], default: 2]
constraints/setppc/npseudobranches = 2

# should pairwise constraint comparison be performed in presolving?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/setppc/presolpairwise = TRUE

# should hash table be used for detecting redundant constraints in advance
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/setppc/presolusehashing = TRUE

# should dual presolving steps be performed?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/setppc/dualpresolving = TRUE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/SOS1/sepafreq = 0

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/SOS1/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/SOS1/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/SOS1/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/SOS1/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/SOS1/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/SOS1/delaypresol = FALSE

# Use SOS1 branching in enforcing (otherwise leave decision to branching rules)?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/SOS1/branchsos = TRUE

# Branch on SOS constraint with most number of nonzeros?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/SOS1/branchnonzeros = FALSE

# Branch on SOS cons. with highest nonzero-variable weight for branching (needs branchnonzeros = false)?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/SOS1/branchweight = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/SOS2/sepafreq = 0

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/SOS2/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/SOS2/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/SOS2/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/SOS2/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/SOS2/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/SOS2/delaypresol = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/soc/sepafreq = 1

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/soc/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/soc/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/soc/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/soc/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/soc/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/soc/delaypresol = FALSE

# enable quadratic upgrading for constraint handler <soc>
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/quadratic/upgrade/soc = TRUE

# whether a constraint should be scaled w.r.t. the current gradient norm when checking for feasibility
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/soc/scaling = TRUE

# whether the reference point of a cut should be projected onto the feasible set of the SOC constraint
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/soc/projectpoint = FALSE

# number of auxiliary variables to use when creating a linear outer approx. of a SOC3 constraint; 0 to turn off
# [type: int, range: [0,2147483647], default: 0]
constraints/soc/nauxvars = 0

# whether the Glineur Outer Approximation should be used instead of Ben-Tal Nemirovski
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/soc/glineur = TRUE

# minimal efficacy of a cut to be added to LP in separation
# [type: real, range: [0,1e+20], default: 0.0001]
constraints/soc/minefficacy = 0.0001

# whether to sparsify cuts
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/soc/sparsify = FALSE

# maximal loss in cut efficacy by sparsification
# [type: real, range: [0,1], default: 0.2]
constraints/soc/sparsifymaxloss = 0.2

# growth rate of maximal allowed nonzeros in cuts in sparsification
# [type: real, range: [1.000001,1e+20], default: 1.3]
constraints/soc/sparsifynzgrowth = 1.3

# whether to try to make solutions feasible in check by shifting the variable on the right hand side
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/soc/linfeasshift = TRUE

# which formulation to use when adding a SOC constraint to the NLP (a: automatic, q: nonconvex quadratic form, s: convex sqrt form, e: convex exponential-sqrt form, d: convex division form)
# [type: char, range: {aqsed}, default: a]
constraints/soc/nlpform = a

# minimal required fraction of continuous variables in problem to use solution of NLP relaxation in root for separation
# [type: real, range: [0,2], default: 1]
constraints/soc/sepanlpmincont = 1

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/varbound/sepafreq = 0

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/varbound/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/varbound/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/varbound/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/varbound/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/varbound/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/varbound/delaypresol = FALSE

# enable linear upgrading for constraint handler <varbound>
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/linear/upgrade/varbound = TRUE

# should pairwise constraint comparison be performed in presolving?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/varbound/presolpairwise = TRUE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/xor/sepafreq = 0

# frequency for propagating domains (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/xor/propfreq = 1

# frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)
# [type: int, range: [-1,2147483647], default: 100]
constraints/xor/eagerfreq = 100

# maximal number of presolving rounds the constraint handler participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
constraints/xor/maxprerounds = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/xor/delaysepa = FALSE

# should propagation method be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/xor/delayprop = FALSE

# should presolving method be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/xor/delaypresol = FALSE

# should pairwise constraint comparison be performed in presolving?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/xor/presolpairwise = TRUE

# should hash table be used for detecting redundant constraints in advance
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
constraints/xor/presolusehashing = TRUE

# should model constraints be subject to aging?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
reading/cipreader/dynamicconss = TRUE

# should columns be added and removed dynamically to the LP?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
reading/cipreader/dynamiccols = FALSE

# should rows be added and removed dynamically to the LP?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
reading/cipreader/dynamicrows = FALSE

# should model constraints be subject to aging?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
reading/cnfreader/dynamicconss = TRUE

# should columns be added and removed dynamically to the LP?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
reading/cnfreader/dynamiccols = FALSE

# should rows be added and removed dynamically to the LP?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
reading/cnfreader/dynamicrows = FALSE

# have integer variables no upper bound by default (depending on GAMS version)?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
reading/gmsreader/freeints = FALSE

# shall characters '#', '*', '+', '/', and '-' in variable and constraint names be replaced by '_'?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
reading/gmsreader/replaceforbiddenchars = FALSE

# default M value for big-M reformulation of indicator constraints in case no bound on slack variable is given
# [type: real, range: [0,1.79769313486232e+308], default: 1000000]
reading/gmsreader/bigmdefault = 1000000

# which reformulation to use for indicator constraints: 'b'ig-M, 's'os1
# [type: char, range: {bs}, default: s]
reading/gmsreader/indicatorreform = s

# is it allowed to use the gams function signpower(x,a)?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
reading/gmsreader/signpower = FALSE

# should model constraints be subject to aging?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
reading/lpreader/dynamicconss = TRUE

# should columns be added and removed dynamically to the LP?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
reading/lpreader/dynamiccols = FALSE

# should rows be added and removed dynamically to the LP?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
reading/lpreader/dynamicrows = FALSE

# should model constraints be subject to aging?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
reading/mpsreader/dynamicconss = TRUE

# should columns be added and removed dynamically to the LP?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
reading/mpsreader/dynamiccols = FALSE

# should rows be added and removed dynamically to the LP?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
reading/mpsreader/dynamicrows = FALSE

# should model constraints be subject to aging?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
reading/opbreader/dynamicconss = TRUE

# should columns be added and removed dynamically to the LP?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
reading/opbreader/dynamiccols = FALSE

# should rows be added and removed dynamically to the LP?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
reading/opbreader/dynamicrows = FALSE

# use '*' between coefficients and variables by writing to problem?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
reading/opbreader/multisymbol = FALSE

# should model constraints be subject to aging?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
reading/pipreader/dynamicconss = TRUE

# should columns be added and removed dynamically to the PIP?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
reading/pipreader/dynamiccols = FALSE

# should rows be added and removed dynamically to the PIP?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
reading/pipreader/dynamicrows = FALSE

# should the coloring values be relativ or absolute
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
reading/ppmreader/rgbrelativ = TRUE

# should the output format be binary(P6) (otherwise plain(P3) format)
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
reading/ppmreader/rgbascii = TRUE

# splitting coefficients in this number of intervals
# [type: int, range: [3,16], default: 3]
reading/ppmreader/coefficientlimit = 3

# maximal color value
# [type: int, range: [0,255], default: 160]
reading/ppmreader/rgblimit = 160

# priority of presolver <boundshift>
# [type: int, range: [-536870912,536870911], default: 7900000]
presolving/boundshift/priority = 7900000

# maximal number of presolving rounds the presolver participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: 0]
presolving/boundshift/maxrounds = 0

# should presolver be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
presolving/boundshift/delay = FALSE

# absolute value of maximum shift
# [type: longint, range: [0,9223372036854775807], default: 9223372036854775807]
presolving/boundshift/maxshift = 9223372036854775807

# is flipping allowed (multiplying with -1)?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
presolving/boundshift/flipping = TRUE

# shift only integer ranges?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
presolving/boundshift/integer = TRUE

# priority of presolver <dualfix>
# [type: int, range: [-536870912,536870911], default: 8000000]
presolving/dualfix/priority = 8000000

# maximal number of presolving rounds the presolver participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
presolving/dualfix/maxrounds = -1

# should presolver be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
presolving/dualfix/delay = FALSE

# priority of presolver <implics>
# [type: int, range: [-536870912,536870911], default: -10000]
presolving/implics/priority = -10000

# maximal number of presolving rounds the presolver participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
presolving/implics/maxrounds = -1

# should presolver be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
presolving/implics/delay = FALSE

# priority of presolver <inttobinary>
# [type: int, range: [-536870912,536870911], default: 7000000]
presolving/inttobinary/priority = 7000000

# maximal number of presolving rounds the presolver participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
presolving/inttobinary/maxrounds = -1

# should presolver be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
presolving/inttobinary/delay = FALSE

# priority of presolver <trivial>
# [type: int, range: [-536870912,536870911], default: 9000000]
presolving/trivial/priority = 9000000

# maximal number of presolving rounds the presolver participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
presolving/trivial/maxrounds = -1

# should presolver be delayed, if other presolvers found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
presolving/trivial/delay = FALSE

# priority of node selection rule <bfs> in standard mode
# [type: int, range: [-536870912,536870911], default: 100000]
nodeselection/bfs/stdpriority = 100000

# priority of node selection rule <bfs> in memory saving mode
# [type: int, range: [-536870912,536870911], default: 0]
nodeselection/bfs/memsavepriority = 0

# minimal plunging depth, before new best node may be selected (-1 for dynamic setting)
# [type: int, range: [-1,2147483647], default: -1]
nodeselection/bfs/minplungedepth = -1

# maximal plunging depth, before new best node is forced to be selected (-1 for dynamic setting)
# [type: int, range: [-1,2147483647], default: -1]
nodeselection/bfs/maxplungedepth = -1

# maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where plunging is performed
# [type: real, range: [0,1.79769313486232e+308], default: 0.25]
nodeselection/bfs/maxplungequot = 0.25

# priority of node selection rule <dfs> in standard mode
# [type: int, range: [-536870912,536870911], default: 0]
nodeselection/dfs/stdpriority = 0

# priority of node selection rule <dfs> in memory saving mode
# [type: int, range: [-536870912,536870911], default: 100000]
nodeselection/dfs/memsavepriority = 100000

# priority of node selection rule <estimate> in standard mode
# [type: int, range: [-536870912,536870911], default: 200000]
nodeselection/estimate/stdpriority = 200000

# priority of node selection rule <estimate> in memory saving mode
# [type: int, range: [-536870912,536870911], default: 100]
nodeselection/estimate/memsavepriority = 100

# minimal plunging depth, before new best node may be selected (-1 for dynamic setting)
# [type: int, range: [-1,2147483647], default: -1]
nodeselection/estimate/minplungedepth = -1

# maximal plunging depth, before new best node is forced to be selected (-1 for dynamic setting)
# [type: int, range: [-1,2147483647], default: -1]
nodeselection/estimate/maxplungedepth = -1

# maximal quotient (estimate - lowerbound)/(cutoffbound - lowerbound) where plunging is performed
# [type: real, range: [0,1.79769313486232e+308], default: 0.25]
nodeselection/estimate/maxplungequot = 0.25

# frequency at which the best node instead of the best estimate is selected (0: never)
# [type: int, range: [0,2147483647], default: 10]
nodeselection/estimate/bestnodefreq = 10

# priority of node selection rule <hybridestim> in standard mode
# [type: int, range: [-536870912,536870911], default: 50000]
nodeselection/hybridestim/stdpriority = 50000

# priority of node selection rule <hybridestim> in memory saving mode
# [type: int, range: [-536870912,536870911], default: 50]
nodeselection/hybridestim/memsavepriority = 50

# minimal plunging depth, before new best node may be selected (-1 for dynamic setting)
# [type: int, range: [-1,2147483647], default: -1]
nodeselection/hybridestim/minplungedepth = -1

# maximal plunging depth, before new best node is forced to be selected (-1 for dynamic setting)
# [type: int, range: [-1,2147483647], default: -1]
nodeselection/hybridestim/maxplungedepth = -1

# maximal quotient (estimate - lowerbound)/(cutoffbound - lowerbound) where plunging is performed
# [type: real, range: [0,1.79769313486232e+308], default: 0.25]
nodeselection/hybridestim/maxplungequot = 0.25

# frequency at which the best node instead of the hybrid best estimate / best bound is selected (0: never)
# [type: int, range: [0,2147483647], default: 1000]
nodeselection/hybridestim/bestnodefreq = 1000

# weight of estimate value in node selection score (0: pure best bound search, 1: pure best estimate search)
# [type: real, range: [0,1], default: 0.1]
nodeselection/hybridestim/estimweight = 0.1

# priority of node selection rule <restartdfs> in standard mode
# [type: int, range: [-536870912,536870911], default: 10000]
nodeselection/restartdfs/stdpriority = 10000

# priority of node selection rule <restartdfs> in memory saving mode
# [type: int, range: [-536870912,536870911], default: 50000]
nodeselection/restartdfs/memsavepriority = 50000

# frequency for selecting the best node instead of the deepest one
# [type: int, range: [0,2147483647], default: 100]
nodeselection/restartdfs/selectbestfreq = 100

# count only leaf nodes (otherwise all nodes)?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
nodeselection/restartdfs/countonlyleaves = TRUE

# priority of branching rule <allfullstrong>
# [type: int, range: [-536870912,536870911], default: -1000]
branching/allfullstrong/priority = -1000

# maximal depth level, up to which branching rule <allfullstrong> should be used (-1 for no limit)
# [type: int, range: [-1,2147483647], default: -1]
branching/allfullstrong/maxdepth = -1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying branching rule (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 1]
branching/allfullstrong/maxbounddist = 1

# priority of branching rule <fullstrong>
# [type: int, range: [-536870912,536870911], default: 0]
branching/fullstrong/priority = 0

# maximal depth level, up to which branching rule <fullstrong> should be used (-1 for no limit)
# [type: int, range: [-1,2147483647], default: -1]
branching/fullstrong/maxdepth = -1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying branching rule (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 1]
branching/fullstrong/maxbounddist = 1

# number of intermediate LPs solved to trigger reevaluation of strong branching value for a variable that was already evaluated at the current node
# [type: int, range: [0,2147483647], default: 10]
branching/fullstrong/reevalage = 10

# priority of branching rule <inference>
# [type: int, range: [-536870912,536870911], default: 1000]
branching/inference/priority = 1000

# maximal depth level, up to which branching rule <inference> should be used (-1 for no limit)
# [type: int, range: [-1,2147483647], default: -1]
branching/inference/maxdepth = -1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying branching rule (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 1]
branching/inference/maxbounddist = 1

# weight in score calculations for conflict score
# [type: real, range: [0,1.79769313486232e+308], default: 1000]
branching/inference/conflictweight = 1000

# weight in score calculations for inference score
# [type: real, range: [-1.79769313486232e+308,1.79769313486232e+308], default: 1]
branching/inference/inferenceweight = 1

# weight in score calculations for cutoff score
# [type: real, range: [0,1.79769313486232e+308], default: 1]
branching/inference/cutoffweight = 1

# should branching on LP solution be restricted to the fractional variables?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
branching/inference/fractionals = TRUE

# should a weighted sum of inference, conflict and cutoff weights be used?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
branching/inference/useweightedsum = TRUE

# priority of branching rule <mostinf>
# [type: int, range: [-536870912,536870911], default: 100]
branching/mostinf/priority = 100

# maximal depth level, up to which branching rule <mostinf> should be used (-1 for no limit)
# [type: int, range: [-1,2147483647], default: -1]
branching/mostinf/maxdepth = -1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying branching rule (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 1]
branching/mostinf/maxbounddist = 1

# priority of branching rule <leastinf>
# [type: int, range: [-536870912,536870911], default: 50]
branching/leastinf/priority = 50

# maximal depth level, up to which branching rule <leastinf> should be used (-1 for no limit)
# [type: int, range: [-1,2147483647], default: -1]
branching/leastinf/maxdepth = -1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying branching rule (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 1]
branching/leastinf/maxbounddist = 1

# priority of branching rule <pscost>
# [type: int, range: [-536870912,536870911], default: 2000]
branching/pscost/priority = 2000

# maximal depth level, up to which branching rule <pscost> should be used (-1 for no limit)
# [type: int, range: [-1,2147483647], default: -1]
branching/pscost/maxdepth = -1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying branching rule (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 1]
branching/pscost/maxbounddist = 1

# strategy for utilizing pseudo-costs of external branching candidates (multiply as in pseudo costs 'u'pdate rule, or by 'd'omain reduction, or by domain reduction of 's'ibling, or by 'v'ariable score)
# [type: char, range: {cdsu}, default: u]
branching/pscost/strategy = u

# weight for minimum of scores of a branching candidate when building weighted sum of min/max/sum of scores
# [type: real, range: [-1e+20,1e+20], default: 0.8]
branching/pscost/minscoreweight = 0.8

# weight for maximum of scores of a branching candidate when building weighted sum of min/max/sum of scores
# [type: real, range: [-1e+20,1e+20], default: 1.3]
branching/pscost/maxscoreweight = 1.3

# weight for sum of scores of a branching candidate when building weighted sum of min/max/sum of scores
# [type: real, range: [-1e+20,1e+20], default: 0.1]
branching/pscost/sumscoreweight = 0.1

# number of children to create in n-ary branching
# [type: int, range: [2,2147483647], default: 2]
branching/pscost/nchildren = 2

# maximal depth where to do n-ary branching, -1 to turn off
# [type: int, range: [-1,2147483647], default: -1]
branching/pscost/narymaxdepth = -1

# minimal domain width in children when doing n-ary branching, relative to global bounds
# [type: real, range: [0,1], default: 0.001]
branching/pscost/naryminwidth = 0.001

# factor of domain width in n-ary branching when creating nodes with increasing distance from branching value
# [type: real, range: [1,1.79769313486232e+308], default: 2]
branching/pscost/narywidthfactor = 2

# priority of branching rule <random>
# [type: int, range: [-536870912,536870911], default: -100000]
branching/random/priority = -100000

# maximal depth level, up to which branching rule <random> should be used (-1 for no limit)
# [type: int, range: [-1,2147483647], default: -1]
branching/random/maxdepth = -1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying branching rule (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 1]
branching/random/maxbounddist = 1

# initial random seed value
# [type: int, range: [0,2147483647], default: 0]
branching/random/seed = 0

# priority of branching rule <relpscost>
# [type: int, range: [-536870912,536870911], default: 10000]
branching/relpscost/priority = 10000

# maximal depth level, up to which branching rule <relpscost> should be used (-1 for no limit)
# [type: int, range: [-1,2147483647], default: -1]
branching/relpscost/maxdepth = -1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying branching rule (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 1]
branching/relpscost/maxbounddist = 1

# weight in score calculations for conflict score
# [type: real, range: [-1.79769313486232e+308,1.79769313486232e+308], default: 0.01]
branching/relpscost/conflictweight = 0.01

# weight in score calculations for conflict length score
# [type: real, range: [-1.79769313486232e+308,1.79769313486232e+308], default: 0]
branching/relpscost/conflictlengthweight = 0

# weight in score calculations for inference score
# [type: real, range: [-1.79769313486232e+308,1.79769313486232e+308], default: 0.0001]
branching/relpscost/inferenceweight = 0.0001

# weight in score calculations for cutoff score
# [type: real, range: [-1.79769313486232e+308,1.79769313486232e+308], default: 0.0001]
branching/relpscost/cutoffweight = 0.0001

# weight in score calculations for pseudo cost score
# [type: real, range: [-1.79769313486232e+308,1.79769313486232e+308], default: 1]
branching/relpscost/pscostweight = 1

# minimal value for minimum pseudo cost size to regard pseudo cost value as reliable
# [type: real, range: [0,1.79769313486232e+308], default: 1]
branching/relpscost/minreliable = 1

# maximal value for minimum pseudo cost size to regard pseudo cost value as reliable
# [type: real, range: [0,1.79769313486232e+308], default: 8]
branching/relpscost/maxreliable = 8

# maximal fraction of strong branching LP iterations compared to node relaxation LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.5]
branching/relpscost/sbiterquot = 0.5

# additional number of allowed strong branching LP iterations
# [type: int, range: [0,2147483647], default: 100000]
branching/relpscost/sbiterofs = 100000

# maximal number of further variables evaluated without better score
# [type: int, range: [1,2147483647], default: 8]
branching/relpscost/maxlookahead = 8

# maximal number of candidates initialized with strong branching per node
# [type: int, range: [0,2147483647], default: 100]
branching/relpscost/initcand = 100

# iteration limit for strong branching initializations of pseudo cost entries (0: auto)
# [type: int, range: [0,2147483647], default: 0]
branching/relpscost/inititer = 0

# maximal number of bound tightenings before the node is reevaluated (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
branching/relpscost/maxbdchgs = 5

# priority of heuristic <actconsdiving>
# [type: int, range: [-536870912,536870911], default: -1003700]
heuristics/actconsdiving/priority = -1003700

# frequency for calling primal heuristic <actconsdiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/actconsdiving/freq = -1

# frequency offset for calling primal heuristic <actconsdiving>
# [type: int, range: [0,2147483647], default: 5]
heuristics/actconsdiving/freqofs = 5

# maximal depth level to call primal heuristic <actconsdiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/actconsdiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/actconsdiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/actconsdiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.05]
heuristics/actconsdiving/maxlpiterquot = 0.05

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/actconsdiving/maxlpiterofs = 1000

# maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1], default: 0.8]
heuristics/actconsdiving/maxdiveubquot = 0.8

# maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/actconsdiving/maxdiveavgquot = 0

# maximal UBQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1], default: 0.1]
heuristics/actconsdiving/maxdiveubquotnosol = 0.1

# maximal AVGQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/actconsdiving/maxdiveavgquotnosol = 0

# use one level of backtracking if infeasibility is encountered?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/actconsdiving/backtrack = TRUE

# priority of heuristic <clique>
# [type: int, range: [-536870912,536870911], default: -1000500]
heuristics/clique/priority = -1000500

# frequency for calling primal heuristic <clique> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/clique/freq = -1

# frequency offset for calling primal heuristic <clique>
# [type: int, range: [0,2147483647], default: 0]
heuristics/clique/freqofs = 0

# maximal depth level to call primal heuristic <clique> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/clique/maxdepth = -1

# value to increase nodenumber to determine the next run
# [type: real, range: [0,1.79769313486232e+308], default: 1.1]
heuristics/clique/multiplier = 1.1

# initial random seed value to permutate variables 
# [type: int, range: [0,2147483647], default: 0]
heuristics/clique/initseed = 0

# minimum percentage of integer variables that have to be fixable 
# [type: real, range: [0,1], default: 0.5]
heuristics/clique/minfixingrate = 0.5

# maximum number of nodes to regard in the subproblem
# [type: longint, range: [0,9223372036854775807], default: 5000]
heuristics/clique/maxnodes = 5000

# number of nodes added to the contingent of the total nodes
# [type: longint, range: [0,9223372036854775807], default: 500]
heuristics/clique/nodesofs = 500

# minimum number of nodes required to start the subproblem
# [type: longint, range: [0,9223372036854775807], default: 500]
heuristics/clique/minnodes = 500

# contingent of sub problem nodes in relation to the number of nodes of the original problem
# [type: real, range: [0,1], default: 0.1]
heuristics/clique/nodesquot = 0.1

# factor by which clique heuristic should at least improve the incumbent  
# [type: real, range: [0,1], default: 0.01]
heuristics/clique/minimprove = 0.01

# maximum number of propagation rounds during probing (-1 infinity)
# [type: int, range: [-1,536870911], default: 2]
heuristics/clique/maxproprounds = 2

# should all active cuts from cutpool be copied to constraints in subproblem?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/clique/copycuts = TRUE

# priority of heuristic <coefdiving>
# [type: int, range: [-536870912,536870911], default: -1001000]
heuristics/coefdiving/priority = -1001000

# frequency for calling primal heuristic <coefdiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/coefdiving/freq = 10

# frequency offset for calling primal heuristic <coefdiving>
# [type: int, range: [0,2147483647], default: 1]
heuristics/coefdiving/freqofs = 1

# maximal depth level to call primal heuristic <coefdiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/coefdiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/coefdiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/coefdiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.05]
heuristics/coefdiving/maxlpiterquot = 0.05

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/coefdiving/maxlpiterofs = 1000

# maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1], default: 0.8]
heuristics/coefdiving/maxdiveubquot = 0.8

# maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/coefdiving/maxdiveavgquot = 0

# maximal UBQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1], default: 0.1]
heuristics/coefdiving/maxdiveubquotnosol = 0.1

# maximal AVGQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/coefdiving/maxdiveavgquotnosol = 0

# use one level of backtracking if infeasibility is encountered?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/coefdiving/backtrack = TRUE

# priority of heuristic <crossover>
# [type: int, range: [-536870912,536870911], default: -1104000]
heuristics/crossover/priority = -1104000

# frequency for calling primal heuristic <crossover> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 30]
heuristics/crossover/freq = 30

# frequency offset for calling primal heuristic <crossover>
# [type: int, range: [0,2147483647], default: 0]
heuristics/crossover/freqofs = 0

# maximal depth level to call primal heuristic <crossover> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/crossover/maxdepth = -1

# number of nodes added to the contingent of the total nodes
# [type: longint, range: [0,9223372036854775807], default: 500]
heuristics/crossover/nodesofs = 500

# maximum number of nodes to regard in the subproblem
# [type: longint, range: [0,9223372036854775807], default: 5000]
heuristics/crossover/maxnodes = 5000

# minimum number of nodes required to start the subproblem
# [type: longint, range: [0,9223372036854775807], default: 500]
heuristics/crossover/minnodes = 500

# number of solutions to be taken into account
# [type: int, range: [2,2147483647], default: 3]
heuristics/crossover/nusedsols = 3

# number of nodes without incumbent change that heuristic should wait
# [type: longint, range: [0,9223372036854775807], default: 200]
heuristics/crossover/nwaitingnodes = 200

# contingent of sub problem nodes in relation to the number of nodes of the original problem
# [type: real, range: [0,1], default: 0.1]
heuristics/crossover/nodesquot = 0.1

# minimum percentage of integer variables that have to be fixed 
# [type: real, range: [0,1], default: 0.666]
heuristics/crossover/minfixingrate = 0.666

# factor by which Crossover should at least improve the incumbent
# [type: real, range: [0,1], default: 0.01]
heuristics/crossover/minimprove = 0.01

# should the choice which sols to take be randomized?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/crossover/randomization = TRUE

# should the nwaitingnodes parameter be ignored at the root node?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
heuristics/crossover/dontwaitatroot = FALSE

# should subproblem be created out of the rows in the LP rows?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
heuristics/crossover/uselprows = FALSE

# if uselprows == FALSE, should all active cuts from cutpool be copied to constraints in subproblem?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/crossover/copycuts = TRUE

# priority of heuristic <dins>
# [type: int, range: [-536870912,536870911], default: -1105000]
heuristics/dins/priority = -1105000

# frequency for calling primal heuristic <dins> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/dins/freq = -1

# frequency offset for calling primal heuristic <dins>
# [type: int, range: [0,2147483647], default: 0]
heuristics/dins/freqofs = 0

# maximal depth level to call primal heuristic <dins> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/dins/maxdepth = -1

# number of nodes added to the contingent of the total nodes
# [type: longint, range: [0,9223372036854775807], default: 5000]
heuristics/dins/nodesofs = 5000

# contingent of sub problem nodes in relation to the number of nodes of the original problem
# [type: real, range: [0,1], default: 0.05]
heuristics/dins/nodesquot = 0.05

# minimum number of nodes required to start the subproblem
# [type: longint, range: [0,9223372036854775807], default: 500]
heuristics/dins/minnodes = 500

# number of pool-solutions to be checked for flag array update (for hard fixing of binary variables)
# [type: int, range: [1,2147483647], default: 5]
heuristics/dins/solnum = 5

# radius (using Manhattan metric) of the incumbent's neighborhood to be searched
# [type: int, range: [1,2147483647], default: 18]
heuristics/dins/neighborhoodsize = 18

# maximum number of nodes to regard in the subproblem
# [type: longint, range: [0,9223372036854775807], default: 5000]
heuristics/dins/maxnodes = 5000

# factor by which dins should at least improve the incumbent  
# [type: real, range: [0,1], default: 0.01]
heuristics/dins/minimprove = 0.01

# number of nodes without incumbent change that heuristic should wait
# [type: longint, range: [0,9223372036854775807], default: 0]
heuristics/dins/nwaitingnodes = 0

# should subproblem be created out of the rows in the LP rows?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
heuristics/dins/uselprows = FALSE

# if uselprows == FALSE, should all active cuts from cutpool be copied to constraints in subproblem?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/dins/copycuts = TRUE

# priority of heuristic <feaspump>
# [type: int, range: [-536870912,536870911], default: -1000000]
heuristics/feaspump/priority = -1000000

# frequency for calling primal heuristic <feaspump> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 20]
heuristics/feaspump/freq = 20

# frequency offset for calling primal heuristic <feaspump>
# [type: int, range: [0,2147483647], default: 0]
heuristics/feaspump/freqofs = 0

# maximal depth level to call primal heuristic <feaspump> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/feaspump/maxdepth = -1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.01]
heuristics/feaspump/maxlpiterquot = 0.01

# factor by which the regard of the objective is decreased in each round, 1.0 for dynamic
# [type: real, range: [0,1], default: 1]
heuristics/feaspump/objfactor = 1

# threshold difference for the convex parameter to perform perturbation
# [type: real, range: [0,1], default: 1]
heuristics/feaspump/alphadiff = 1

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/feaspump/maxlpiterofs = 1000

# total number of feasible solutions found up to which heuristic is called (-1: no limit)
# [type: int, range: [-1,2147483647], default: 2]
heuristics/feaspump/maxsols = 2

# maximal number of pumping loops (-1: no limit)
# [type: int, range: [-1,2147483647], default: 10000]
heuristics/feaspump/maxloops = 10000

# maximal number of pumping rounds without fractionality improvement (-1: no limit)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/feaspump/maxstallloops = 10

# minimum number of random variables to flip, if a 1-cycle is encountered
# [type: int, range: [1,2147483647], default: 10]
heuristics/feaspump/minflips = 10

# maximum length of cycles to be checked explicitly in each round
# [type: int, range: [1,100], default: 3]
heuristics/feaspump/cyclelength = 3

# number of iterations until a random perturbation is forced
# [type: int, range: [1,2147483647], default: 100]
heuristics/feaspump/perturbfreq = 100

# radius (using Manhattan metric) of the neighborhood to be searched in stage 3
# [type: int, range: [1,2147483647], default: 18]
heuristics/feaspump/neighborhoodsize = 18

# should the feasibility pump be called at root node before cut separation?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/feaspump/beforecuts = TRUE

# should an iterative round-and-propagate scheme be used to find the integral points?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
heuristics/feaspump/usefp20 = FALSE

# should a random perturbation be performed if a feasible solution was found?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/feaspump/pertsolfound = TRUE

# should we solve a local branching sub-MIP if no solution could be found?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
heuristics/feaspump/stage3 = FALSE

# should all active cuts from cutpool be copied to constraints in subproblem?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/feaspump/copycuts = TRUE

# priority of heuristic <fixandinfer>
# [type: int, range: [-536870912,536870911], default: -500000]
heuristics/fixandinfer/priority = -500000

# frequency for calling primal heuristic <fixandinfer> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/fixandinfer/freq = -1

# frequency offset for calling primal heuristic <fixandinfer>
# [type: int, range: [0,2147483647], default: 0]
heuristics/fixandinfer/freqofs = 0

# maximal depth level to call primal heuristic <fixandinfer> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/fixandinfer/maxdepth = -1

# maximal number of propagation rounds in probing subproblems (-1: no limit, 0: auto)
# [type: int, range: [-1,2147483647], default: 0]
heuristics/fixandinfer/proprounds = 0

# minimal number of fixings to apply before dive may be aborted
# [type: int, range: [0,2147483647], default: 100]
heuristics/fixandinfer/minfixings = 100

# priority of heuristic <fracdiving>
# [type: int, range: [-536870912,536870911], default: -1003000]
heuristics/fracdiving/priority = -1003000

# frequency for calling primal heuristic <fracdiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/fracdiving/freq = 10

# frequency offset for calling primal heuristic <fracdiving>
# [type: int, range: [0,2147483647], default: 3]
heuristics/fracdiving/freqofs = 3

# maximal depth level to call primal heuristic <fracdiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/fracdiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/fracdiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/fracdiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.05]
heuristics/fracdiving/maxlpiterquot = 0.05

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/fracdiving/maxlpiterofs = 1000

# maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1], default: 0.8]
heuristics/fracdiving/maxdiveubquot = 0.8

# maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/fracdiving/maxdiveavgquot = 0

# maximal UBQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1], default: 0.1]
heuristics/fracdiving/maxdiveubquotnosol = 0.1

# maximal AVGQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/fracdiving/maxdiveavgquotnosol = 0

# use one level of backtracking if infeasibility is encountered?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/fracdiving/backtrack = TRUE

# priority of heuristic <guideddiving>
# [type: int, range: [-536870912,536870911], default: -1007000]
heuristics/guideddiving/priority = -1007000

# frequency for calling primal heuristic <guideddiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/guideddiving/freq = 10

# frequency offset for calling primal heuristic <guideddiving>
# [type: int, range: [0,2147483647], default: 7]
heuristics/guideddiving/freqofs = 7

# maximal depth level to call primal heuristic <guideddiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/guideddiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/guideddiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/guideddiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.05]
heuristics/guideddiving/maxlpiterquot = 0.05

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/guideddiving/maxlpiterofs = 1000

# maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1], default: 0.8]
heuristics/guideddiving/maxdiveubquot = 0.8

# maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/guideddiving/maxdiveavgquot = 0

# use one level of backtracking if infeasibility is encountered?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/guideddiving/backtrack = TRUE

# priority of heuristic <intdiving>
# [type: int, range: [-536870912,536870911], default: -1003500]
heuristics/intdiving/priority = -1003500

# frequency for calling primal heuristic <intdiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/intdiving/freq = -1

# frequency offset for calling primal heuristic <intdiving>
# [type: int, range: [0,2147483647], default: 9]
heuristics/intdiving/freqofs = 9

# maximal depth level to call primal heuristic <intdiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/intdiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/intdiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/intdiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.05]
heuristics/intdiving/maxlpiterquot = 0.05

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/intdiving/maxlpiterofs = 1000

# maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1], default: 0.8]
heuristics/intdiving/maxdiveubquot = 0.8

# maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/intdiving/maxdiveavgquot = 0

# maximal UBQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1], default: 0.1]
heuristics/intdiving/maxdiveubquotnosol = 0.1

# maximal AVGQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/intdiving/maxdiveavgquotnosol = 0

# use one level of backtracking if infeasibility is encountered?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/intdiving/backtrack = TRUE

# priority of heuristic <intshifting>
# [type: int, range: [-536870912,536870911], default: -10000]
heuristics/intshifting/priority = -10000

# frequency for calling primal heuristic <intshifting> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/intshifting/freq = 10

# frequency offset for calling primal heuristic <intshifting>
# [type: int, range: [0,2147483647], default: 0]
heuristics/intshifting/freqofs = 0

# maximal depth level to call primal heuristic <intshifting> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/intshifting/maxdepth = -1

# priority of heuristic <linesearchdiving>
# [type: int, range: [-536870912,536870911], default: -1006000]
heuristics/linesearchdiving/priority = -1006000

# frequency for calling primal heuristic <linesearchdiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/linesearchdiving/freq = 10

# frequency offset for calling primal heuristic <linesearchdiving>
# [type: int, range: [0,2147483647], default: 6]
heuristics/linesearchdiving/freqofs = 6

# maximal depth level to call primal heuristic <linesearchdiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/linesearchdiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/linesearchdiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/linesearchdiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.05]
heuristics/linesearchdiving/maxlpiterquot = 0.05

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/linesearchdiving/maxlpiterofs = 1000

# maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1], default: 0.8]
heuristics/linesearchdiving/maxdiveubquot = 0.8

# maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/linesearchdiving/maxdiveavgquot = 0

# maximal UBQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1], default: 0.1]
heuristics/linesearchdiving/maxdiveubquotnosol = 0.1

# maximal AVGQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/linesearchdiving/maxdiveavgquotnosol = 0

# use one level of backtracking if infeasibility is encountered?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/linesearchdiving/backtrack = TRUE

# priority of heuristic <localbranching>
# [type: int, range: [-536870912,536870911], default: -1102000]
heuristics/localbranching/priority = -1102000

# frequency for calling primal heuristic <localbranching> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/localbranching/freq = -1

# frequency offset for calling primal heuristic <localbranching>
# [type: int, range: [0,2147483647], default: 0]
heuristics/localbranching/freqofs = 0

# maximal depth level to call primal heuristic <localbranching> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/localbranching/maxdepth = -1

# number of nodes added to the contingent of the total nodes
# [type: int, range: [0,2147483647], default: 1000]
heuristics/localbranching/nodesofs = 1000

# radius (using Manhattan metric) of the incumbent's neighborhood to be searched
# [type: int, range: [1,2147483647], default: 18]
heuristics/localbranching/neighborhoodsize = 18

# contingent of sub problem nodes in relation to the number of nodes of the original problem
# [type: real, range: [0,1], default: 0.05]
heuristics/localbranching/nodesquot = 0.05

# minimum number of nodes required to start the subproblem
# [type: int, range: [0,2147483647], default: 1000]
heuristics/localbranching/minnodes = 1000

# maximum number of nodes to regard in the subproblem
# [type: int, range: [0,2147483647], default: 10000]
heuristics/localbranching/maxnodes = 10000

# number of nodes without incumbent change that heuristic should wait
# [type: int, range: [0,2147483647], default: 200]
heuristics/localbranching/nwaitingnodes = 200

# factor by which localbranching should at least improve the incumbent  
# [type: real, range: [0,1], default: 0.01]
heuristics/localbranching/minimprove = 0.01

# should subproblem be created out of the rows in the LP rows?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
heuristics/localbranching/uselprows = FALSE

# if uselprows == FALSE, should all active cuts from cutpool be copied to constraints in subproblem?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/localbranching/copycuts = TRUE

# priority of heuristic <mutation>
# [type: int, range: [-536870912,536870911], default: -1103000]
heuristics/mutation/priority = -1103000

# frequency for calling primal heuristic <mutation> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/mutation/freq = -1

# frequency offset for calling primal heuristic <mutation>
# [type: int, range: [0,2147483647], default: 8]
heuristics/mutation/freqofs = 8

# maximal depth level to call primal heuristic <mutation> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/mutation/maxdepth = -1

# number of nodes added to the contingent of the total nodes
# [type: int, range: [0,2147483647], default: 500]
heuristics/mutation/nodesofs = 500

# maximum number of nodes to regard in the subproblem
# [type: int, range: [0,2147483647], default: 5000]
heuristics/mutation/maxnodes = 5000

# minimum number of nodes required to start the subproblem
# [type: int, range: [0,2147483647], default: 500]
heuristics/mutation/minnodes = 500

# number of nodes without incumbent change that heuristic should wait
# [type: int, range: [0,2147483647], default: 200]
heuristics/mutation/nwaitingnodes = 200

# contingent of sub problem nodes in relation to the number of nodes of the original problem
# [type: real, range: [0,1], default: 0.1]
heuristics/mutation/nodesquot = 0.1

# percentage of integer variables that have to be fixed 
# [type: real, range: [1e-06,0.999999], default: 0.8]
heuristics/mutation/minfixingrate = 0.8

# factor by which mutation should at least improve the incumbent
# [type: real, range: [0,1], default: 0.01]
heuristics/mutation/minimprove = 0.01

# should subproblem be created out of the rows in the LP rows?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
heuristics/mutation/uselprows = FALSE

# if uselprows == FALSE, should all active cuts from cutpool be copied to constraints in subproblem?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/mutation/copycuts = TRUE

# priority of heuristic <objpscostdiving>
# [type: int, range: [-536870912,536870911], default: -1004000]
heuristics/objpscostdiving/priority = -1004000

# frequency for calling primal heuristic <objpscostdiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 20]
heuristics/objpscostdiving/freq = 20

# frequency offset for calling primal heuristic <objpscostdiving>
# [type: int, range: [0,2147483647], default: 4]
heuristics/objpscostdiving/freqofs = 4

# maximal depth level to call primal heuristic <objpscostdiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/objpscostdiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/objpscostdiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/objpscostdiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to total iteration number
# [type: real, range: [0,1], default: 0.01]
heuristics/objpscostdiving/maxlpiterquot = 0.01

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/objpscostdiving/maxlpiterofs = 1000

# total number of feasible solutions found up to which heuristic is called (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/objpscostdiving/maxsols = -1

# maximal diving depth: number of binary/integer variables times depthfac
# [type: real, range: [0,1.79769313486232e+308], default: 0.5]
heuristics/objpscostdiving/depthfac = 0.5

# maximal diving depth factor if no feasible solution was found yet
# [type: real, range: [0,1.79769313486232e+308], default: 2]
heuristics/objpscostdiving/depthfacnosol = 2

# priority of heuristic <octane>
# [type: int, range: [-536870912,536870911], default: -1008000]
heuristics/octane/priority = -1008000

# frequency for calling primal heuristic <octane> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/octane/freq = -1

# frequency offset for calling primal heuristic <octane>
# [type: int, range: [0,2147483647], default: 0]
heuristics/octane/freqofs = 0

# maximal depth level to call primal heuristic <octane> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/octane/maxdepth = -1

# number of 0-1-points to be tested as possible solutions by OCTANE
# [type: int, range: [1,2147483647], default: 100]
heuristics/octane/fmax = 100

# number of 0-1-points to be tested at first whether they violate a common row
# [type: int, range: [1,2147483647], default: 10]
heuristics/octane/ffirst = 10

# execute OCTANE only in the space of fractional variables (TRUE) or in the full space? 
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/octane/usefracspace = TRUE

# should the inner normal of the objective be used as one ray direction?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/octane/useobjray = TRUE

# should the average of the basic cone be used as one ray direction?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/octane/useavgray = TRUE

# should the difference between the root solution and the current LP solution be used as one ray direction?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
heuristics/octane/usediffray = FALSE

# should the weighted average of the basic cone be used as one ray direction?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/octane/useavgwgtray = TRUE

# should the weighted average of the nonbasic cone be used as one ray direction?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/octane/useavgnbray = TRUE

# priority of heuristic <oneopt>
# [type: int, range: [-536870912,536870911], default: -20000]
heuristics/oneopt/priority = -20000

# frequency for calling primal heuristic <oneopt> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 1]
heuristics/oneopt/freq = 1

# frequency offset for calling primal heuristic <oneopt>
# [type: int, range: [0,2147483647], default: 0]
heuristics/oneopt/freqofs = 0

# maximal depth level to call primal heuristic <oneopt> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/oneopt/maxdepth = -1

# should the objective be weighted with the potential shifting value when sorting the shifting candidates?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/oneopt/weightedobj = TRUE

# should the heuristic be called before and during the root node?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/oneopt/duringroot = TRUE

# priority of heuristic <pscostdiving>
# [type: int, range: [-536870912,536870911], default: -1002000]
heuristics/pscostdiving/priority = -1002000

# frequency for calling primal heuristic <pscostdiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/pscostdiving/freq = 10

# frequency offset for calling primal heuristic <pscostdiving>
# [type: int, range: [0,2147483647], default: 2]
heuristics/pscostdiving/freqofs = 2

# maximal depth level to call primal heuristic <pscostdiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/pscostdiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/pscostdiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/pscostdiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.05]
heuristics/pscostdiving/maxlpiterquot = 0.05

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/pscostdiving/maxlpiterofs = 1000

# maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1], default: 0.8]
heuristics/pscostdiving/maxdiveubquot = 0.8

# maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/pscostdiving/maxdiveavgquot = 0

# maximal UBQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1], default: 0.1]
heuristics/pscostdiving/maxdiveubquotnosol = 0.1

# maximal AVGQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/pscostdiving/maxdiveavgquotnosol = 0

# use one level of backtracking if infeasibility is encountered?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/pscostdiving/backtrack = TRUE

# priority of heuristic <rens>
# [type: int, range: [-536870912,536870911], default: -1100000]
heuristics/rens/priority = -1100000

# frequency for calling primal heuristic <rens> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 0]
heuristics/rens/freq = 0

# frequency offset for calling primal heuristic <rens>
# [type: int, range: [0,2147483647], default: 0]
heuristics/rens/freqofs = 0

# maximal depth level to call primal heuristic <rens> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/rens/maxdepth = -1

# minimum percentage of integer variables that have to be fixable 
# [type: real, range: [0,1], default: 0.5]
heuristics/rens/minfixingrate = 0.5

# maximum number of nodes to regard in the subproblem
# [type: longint, range: [0,9223372036854775807], default: 5000]
heuristics/rens/maxnodes = 5000

# number of nodes added to the contingent of the total nodes
# [type: longint, range: [0,9223372036854775807], default: 500]
heuristics/rens/nodesofs = 500

# minimum number of nodes required to start the subproblem
# [type: longint, range: [0,9223372036854775807], default: 500]
heuristics/rens/minnodes = 500

# contingent of sub problem nodes in relation to the number of nodes of the original problem
# [type: real, range: [0,1], default: 0.1]
heuristics/rens/nodesquot = 0.1

# factor by which RENS should at least improve the incumbent  
# [type: real, range: [0,1], default: 0.01]
heuristics/rens/minimprove = 0.01

# solution that is used for fixing values ('l'p relaxation, 'n'lp relaxation)
# [type: char, range: {nl}, default: l]
heuristics/rens/startsol = l

# should general integers get binary bounds [floor(.),ceil(.)] ?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/rens/binarybounds = TRUE

# should subproblem be created out of the rows in the LP rows?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
heuristics/rens/uselprows = FALSE

# if uselprows == FALSE, should all active cuts from cutpool be copied to constraints in subproblem?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/rens/copycuts = TRUE

# priority of heuristic <rins>
# [type: int, range: [-536870912,536870911], default: -1101000]
heuristics/rins/priority = -1101000

# frequency for calling primal heuristic <rins> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/rins/freq = -1

# frequency offset for calling primal heuristic <rins>
# [type: int, range: [0,2147483647], default: 5]
heuristics/rins/freqofs = 5

# maximal depth level to call primal heuristic <rins> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/rins/maxdepth = -1

# number of nodes added to the contingent of the total nodes
# [type: int, range: [0,2147483647], default: 500]
heuristics/rins/nodesofs = 500

# maximum number of nodes to regard in the subproblem
# [type: int, range: [0,2147483647], default: 5000]
heuristics/rins/maxnodes = 5000

# minimum number of nodes required to start the subproblem
# [type: int, range: [0,2147483647], default: 500]
heuristics/rins/minnodes = 500

# contingent of sub problem nodes in relation to the number of nodes of the original problem
# [type: real, range: [0,1], default: 0.1]
heuristics/rins/nodesquot = 0.1

# number of nodes without incumbent change that heuristic should wait
# [type: int, range: [0,2147483647], default: 200]
heuristics/rins/nwaitingnodes = 200

# factor by which rins should at least improve the incumbent
# [type: real, range: [0,1], default: 0.01]
heuristics/rins/minimprove = 0.01

# minimum percentage of integer variables that have to be fixed 
# [type: real, range: [0,1], default: 0]
heuristics/rins/minfixingrate = 0

# should subproblem be created out of the rows in the LP rows?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
heuristics/rins/uselprows = FALSE

# if uselprows == FALSE, should all active cuts from cutpool be copied to constraints in subproblem?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/rins/copycuts = TRUE

# priority of heuristic <rootsoldiving>
# [type: int, range: [-536870912,536870911], default: -1005000]
heuristics/rootsoldiving/priority = -1005000

# frequency for calling primal heuristic <rootsoldiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 20]
heuristics/rootsoldiving/freq = 20

# frequency offset for calling primal heuristic <rootsoldiving>
# [type: int, range: [0,2147483647], default: 5]
heuristics/rootsoldiving/freqofs = 5

# maximal depth level to call primal heuristic <rootsoldiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/rootsoldiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/rootsoldiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/rootsoldiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.01]
heuristics/rootsoldiving/maxlpiterquot = 0.01

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/rootsoldiving/maxlpiterofs = 1000

# total number of feasible solutions found up to which heuristic is called (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/rootsoldiving/maxsols = -1

# maximal diving depth: number of binary/integer variables times depthfac
# [type: real, range: [0,1.79769313486232e+308], default: 0.5]
heuristics/rootsoldiving/depthfac = 0.5

# maximal diving depth factor if no feasible solution was found yet
# [type: real, range: [0,1.79769313486232e+308], default: 2]
heuristics/rootsoldiving/depthfacnosol = 2

# soft rounding factor to fade out objective coefficients
# [type: real, range: [0,1], default: 0.9]
heuristics/rootsoldiving/alpha = 0.9

# priority of heuristic <rounding>
# [type: int, range: [-536870912,536870911], default: -1000]
heuristics/rounding/priority = -1000

# frequency for calling primal heuristic <rounding> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 1]
heuristics/rounding/freq = 1

# frequency offset for calling primal heuristic <rounding>
# [type: int, range: [0,2147483647], default: 0]
heuristics/rounding/freqofs = 0

# maximal depth level to call primal heuristic <rounding> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/rounding/maxdepth = -1

# number of calls per found solution that are considered as standard success, a higher factor causes the heuristic to be called more often
# [type: int, range: [-1,2147483647], default: 100]
heuristics/rounding/successfactor = 100

# priority of heuristic <shiftandpropagate>
# [type: int, range: [-536870912,536870911], default: 1000]
heuristics/shiftandpropagate/priority = 1000

# frequency for calling primal heuristic <shiftandpropagate> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 0]
heuristics/shiftandpropagate/freq = 0

# frequency offset for calling primal heuristic <shiftandpropagate>
# [type: int, range: [0,2147483647], default: 0]
heuristics/shiftandpropagate/freqofs = 0

# maximal depth level to call primal heuristic <shiftandpropagate> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/shiftandpropagate/maxdepth = -1

# The number of propagation rounds used for each propagation
# [type: int, range: [-1,1000], default: 10]
heuristics/shiftandpropagate/nproprounds = 10

# Should continuous variables be relaxed?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/shiftandpropagate/relax = TRUE

# Should domains be reduced by probing?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/shiftandpropagate/probing = TRUE

# Should heuristic only be executed if no primal solution was found, yet?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/shiftandpropagate/onlywithoutsol = TRUE

# The number of cutoffs before heuristic stops
# [type: int, range: [-1,1000000], default: 15]
heuristics/shiftandpropagate/cutoffbreaker = 15

# the key for variable sorting: (n)orms or (r)andom
# [type: char, range: {nru}, default: u]
heuristics/shiftandpropagate/sortkey = u

# Should variables be sorted for the heuristic?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/shiftandpropagate/sortvars = TRUE

# priority of heuristic <shifting>
# [type: int, range: [-536870912,536870911], default: -5000]
heuristics/shifting/priority = -5000

# frequency for calling primal heuristic <shifting> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/shifting/freq = 10

# frequency offset for calling primal heuristic <shifting>
# [type: int, range: [0,2147483647], default: 0]
heuristics/shifting/freqofs = 0

# maximal depth level to call primal heuristic <shifting> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/shifting/maxdepth = -1

# priority of heuristic <simplerounding>
# [type: int, range: [-536870912,536870911], default: 0]
heuristics/simplerounding/priority = 0

# frequency for calling primal heuristic <simplerounding> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 1]
heuristics/simplerounding/freq = 1

# frequency offset for calling primal heuristic <simplerounding>
# [type: int, range: [0,2147483647], default: 0]
heuristics/simplerounding/freqofs = 0

# maximal depth level to call primal heuristic <simplerounding> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/simplerounding/maxdepth = -1

# priority of heuristic <subnlp>
# [type: int, range: [-536870912,536870911], default: -2000000]
heuristics/subnlp/priority = -2000000

# frequency for calling primal heuristic <subnlp> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 1]
heuristics/subnlp/freq = 1

# frequency offset for calling primal heuristic <subnlp>
# [type: int, range: [0,2147483647], default: 0]
heuristics/subnlp/freqofs = 0

# maximal depth level to call primal heuristic <subnlp> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/subnlp/maxdepth = -1

# verbosity level of NLP solver
# [type: int, range: [0,2147483647], default: 0]
heuristics/subnlp/nlpverblevel = 0

# iteration limit of NLP solver; 0 to use solver default
# [type: int, range: [0,2147483647], default: 0]
heuristics/subnlp/nlpiterlimit = 0

# time limit of NLP solver; 0 to use solver default
# [type: real, range: [0,1e+20], default: 0]
heuristics/subnlp/nlptimelimit = 0

# name of an NLP solver specific options file
# [type: string, default: ""]
heuristics/subnlp/nlpoptfile = ""

# if SCIP does not accept a NLP feasible solution, resolve NLP with feas. tolerance reduced by this factor (set to 1.0 to turn off resolve)
# [type: real, range: [0,1], default: 0.001]
heuristics/subnlp/resolvetolfactor = 0.001

# should the NLP resolve be started from the original starting point or the infeasible solution?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/subnlp/resolvefromscratch = TRUE

# number of iterations added to the contingent of the total number of iterations
# [type: int, range: [0,2147483647], default: 500]
heuristics/subnlp/iteroffset = 500

# contingent of NLP iterations in relation to the number of nodes in SCIP
# [type: real, range: [0,1e+20], default: 0.1]
heuristics/subnlp/iterquotient = 0.1

# contingent of NLP iterations in relation to the number of nodes in SCIP
# [type: int, range: [0,2147483647], default: 300]
heuristics/subnlp/itermin = 300

# whether to run NLP heuristic always if starting point available (does not use iteroffset,iterquot,itermin)
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
heuristics/subnlp/runalways = FALSE

# factor by which NLP heuristic should at least improve the incumbent
# [type: real, range: [0,1], default: 0.01]
heuristics/subnlp/minimprove = 0.01

# limit on number of presolve rounds in sub-SCIP (-1 for unlimited, 0 for no presolve)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/subnlp/maxpresolverounds = -1

# whether to add constraints that forbid specific fixings that turned out to be infeasible
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/subnlp/forbidfixings = TRUE

# whether to keep SCIP copy or to create new copy each time heuristic is applied
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/subnlp/keepcopy = TRUE

# priority of heuristic <trivial>
# [type: int, range: [-536870912,536870911], default: 10000]
heuristics/trivial/priority = 10000

# frequency for calling primal heuristic <trivial> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 0]
heuristics/trivial/freq = 0

# frequency offset for calling primal heuristic <trivial>
# [type: int, range: [0,2147483647], default: 0]
heuristics/trivial/freqofs = 0

# maximal depth level to call primal heuristic <trivial> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/trivial/maxdepth = -1

# priority of heuristic <trysol>
# [type: int, range: [-536870912,536870911], default: -3000000]
heuristics/trysol/priority = -3000000

# frequency for calling primal heuristic <trysol> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 1]
heuristics/trysol/freq = 1

# frequency offset for calling primal heuristic <trysol>
# [type: int, range: [0,2147483647], default: 0]
heuristics/trysol/freqofs = 0

# maximal depth level to call primal heuristic <trysol> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/trysol/maxdepth = -1

# priority of heuristic <twoopt>
# [type: int, range: [-536870912,536870911], default: -20100]
heuristics/twoopt/priority = -20100

# frequency for calling primal heuristic <twoopt> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/twoopt/freq = -1

# frequency offset for calling primal heuristic <twoopt>
# [type: int, range: [0,2147483647], default: 0]
heuristics/twoopt/freqofs = 0

# maximal depth level to call primal heuristic <twoopt> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/twoopt/maxdepth = -1

#  Should Integer-2-Optimization be applied or not?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
heuristics/twoopt/intopt = FALSE

# user parameter to determine number of nodes to wait after last best solution before calling heuristic
# [type: int, range: [0,10000], default: 0]
heuristics/twoopt/waitingnodes = 0

# maximum number of slaves for one master variable
# [type: int, range: [-1,1000000], default: 199]
heuristics/twoopt/maxnslaves = 199

# parameter to determine the percentage of rows two variables have to share before they are considered equal
# [type: real, range: [0,1], default: 0.5]
heuristics/twoopt/matchingrate = 0.5

# priority of heuristic <undercover>
# [type: int, range: [-536870912,536870911], default: -1110000]
heuristics/undercover/priority = -1110000

# frequency for calling primal heuristic <undercover> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 0]
heuristics/undercover/freq = 0

# frequency offset for calling primal heuristic <undercover>
# [type: int, range: [0,2147483647], default: 0]
heuristics/undercover/freqofs = 0

# maximal depth level to call primal heuristic <undercover> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/undercover/maxdepth = -1

# prioritized sequence of fixing values used ('l'p relaxation, 'n'lp relaxation, 'i'ncumbent solution)
# [type: string, default: "li"]
heuristics/undercover/fixingalts = "li"

# maximum number of nodes to regard in the subproblem
# [type: longint, range: [0,9223372036854775807], default: 500]
heuristics/undercover/maxnodes = 500

# minimum number of nodes required to start the subproblem
# [type: longint, range: [0,9223372036854775807], default: 500]
heuristics/undercover/minnodes = 500

# number of nodes added to the contingent of the total nodes
# [type: longint, range: [0,9223372036854775807], default: 500]
heuristics/undercover/nodesofs = 500

# weight for conflict score in fixing order
# [type: real, range: [-1.79769313486232e+308,1.79769313486232e+308], default: 1000]
heuristics/undercover/conflictweight = 1000

# weight for cutoff score in fixing order
# [type: real, range: [0,1.79769313486232e+308], default: 1]
heuristics/undercover/cutoffweight = 1

# weight for inference score in fixing order
# [type: real, range: [-1.79769313486232e+308,1.79769313486232e+308], default: 1]
heuristics/undercover/inferenceweight = 1

# maximum coversize (as fraction of total number of variables)
# [type: real, range: [0,1], default: 1]
heuristics/undercover/maxcoversize = 1

# factor by which the heuristic should at least improve the incumbent
# [type: real, range: [-1,1], default: 0]
heuristics/undercover/minimprove = 0

# contingent of sub problem nodes in relation to the number of nodes of the original problem
# [type: real, range: [0,1], default: 0.1]
heuristics/undercover/nodesquot = 0.1

# fraction of covering variables in the last cover which need to change their value when recovering
# [type: real, range: [0,1], default: 0.9]
heuristics/undercover/recoverdiv = 0.9

# should the heuristic be called at root node before cut separation?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/undercover/beforecuts = TRUE

# should integer variables in the cover be fixed first?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
heuristics/undercover/fixintfirst = FALSE

# shall LP values for integer vars be rounded according to locks?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/undercover/locksrounding = TRUE

# should we only fix variables in order to obtain a convex problem?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
heuristics/undercover/onlyconvexify = FALSE

# should the nlp heuristic be called to polish a feasible solution?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/undercover/postnlp = TRUE

# maximum number of backtracks in fix-and-propagate
# [type: int, range: [0,2147483647], default: 6]
heuristics/undercover/maxbacktracks = 6

# maximum number of recoverings
# [type: int, range: [0,2147483647], default: 0]
heuristics/undercover/maxrecovers = 0

# maximum number of reorderings of the fixing order
# [type: int, range: [0,2147483647], default: 1]
heuristics/undercover/maxreorders = 1

# objective function of the covering problem ('b'ranching status, influenced nonlinear 'c'onstraints/'t'erms, 'd'omain size, 'l'ocks, 'm'in of up/down locks, 'u'nit penalties, constraint 'v'iolation)
# [type: char, range: {cdlmtu}, default: u]
heuristics/undercover/coveringobj = u

# order in which variables should be fixed (increasing 'C'onflict score, decreasing 'c'onflict score, increasing 'V'ariable index, decreasing 'v'ariable index
# [type: char, range: {CcVv}, default: v]
heuristics/undercover/fixingorder = v

# should all active cuts from cutpool be copied to constraints in subproblem?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/undercover/copycuts = TRUE

# priority of heuristic <vbounds>
# [type: int, range: [-536870912,536870911], default: -1106000]
heuristics/vbounds/priority = -1106000

# frequency for calling primal heuristic <vbounds> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/vbounds/freq = -1

# frequency offset for calling primal heuristic <vbounds>
# [type: int, range: [0,2147483647], default: 0]
heuristics/vbounds/freqofs = 0

# maximal depth level to call primal heuristic <vbounds> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/vbounds/maxdepth = -1

# minimum percentage of integer variables that have to be fixable 
# [type: real, range: [0,1], default: 0.5]
heuristics/vbounds/minfixingrate = 0.5

# maximum number of nodes to regard in the subproblem
# [type: longint, range: [0,9223372036854775807], default: 5000]
heuristics/vbounds/maxnodes = 5000

# number of nodes added to the contingent of the total nodes
# [type: longint, range: [0,9223372036854775807], default: 500]
heuristics/vbounds/nodesofs = 500

# minimum number of nodes required to start the subproblem
# [type: longint, range: [0,9223372036854775807], default: 500]
heuristics/vbounds/minnodes = 500

# contingent of sub problem nodes in relation to the number of nodes of the original problem
# [type: real, range: [0,1], default: 0.1]
heuristics/vbounds/nodesquot = 0.1

# factor by which vbounds heuristic should at least improve the incumbent  
# [type: real, range: [0,1], default: 0.01]
heuristics/vbounds/minimprove = 0.01

# maximum number of propagation rounds during probing (-1 infinity)
# [type: int, range: [-1,536870911], default: 2]
heuristics/vbounds/maxproprounds = 2

# should all active cuts from cutpool be copied to constraints in subproblem?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/vbounds/copycuts = TRUE

# priority of heuristic <veclendiving>
# [type: int, range: [-536870912,536870911], default: -1003100]
heuristics/veclendiving/priority = -1003100

# frequency for calling primal heuristic <veclendiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/veclendiving/freq = 10

# frequency offset for calling primal heuristic <veclendiving>
# [type: int, range: [0,2147483647], default: 4]
heuristics/veclendiving/freqofs = 4

# maximal depth level to call primal heuristic <veclendiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/veclendiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/veclendiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/veclendiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.05]
heuristics/veclendiving/maxlpiterquot = 0.05

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/veclendiving/maxlpiterofs = 1000

# maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1], default: 0.8]
heuristics/veclendiving/maxdiveubquot = 0.8

# maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/veclendiving/maxdiveavgquot = 0

# maximal UBQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1], default: 0.1]
heuristics/veclendiving/maxdiveubquotnosol = 0.1

# maximal AVGQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/veclendiving/maxdiveavgquotnosol = 0

# use one level of backtracking if infeasibility is encountered?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/veclendiving/backtrack = TRUE

# priority of heuristic <zirounding>
# [type: int, range: [-536870912,536870911], default: -500]
heuristics/zirounding/priority = -500

# frequency for calling primal heuristic <zirounding> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 1]
heuristics/zirounding/freq = 1

# frequency offset for calling primal heuristic <zirounding>
# [type: int, range: [0,2147483647], default: 0]
heuristics/zirounding/freqofs = 0

# maximal depth level to call primal heuristic <zirounding> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/zirounding/maxdepth = -1

# determines maximum number of rounding loops
# [type: int, range: [-1,2147483647], default: 2]
heuristics/zirounding/maxroundingloops = 2

# flag to determine if Zirounding is deactivated after a certain percentage of unsuccessful calls
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/zirounding/stopziround = TRUE

# if percentage of found solutions falls below this parameter, Zirounding will be deactivated
# [type: real, range: [0,1], default: 0.02]
heuristics/zirounding/stoppercentage = 0.02

# determines the minimum number of calls before percentage-based deactivation of Zirounding is applied
# [type: int, range: [1,2147483647], default: 1000]
heuristics/zirounding/minstopncalls = 1000

# priority of propagator <probing>
# [type: int, range: [-536870912,536870911], default: -100000]
propagating/probing/priority = -100000

# frequency for calling propagator <probing> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
propagating/probing/freq = -1

# should propagator be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
propagating/probing/delay = TRUE

# presolving priority of propagator <probing>
# [type: int, range: [-536870912,536870911], default: -100000]
propagating/probing/presolpriority = -100000

# maximal number of presolving rounds the propagator participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
propagating/probing/maxprerounds = -1

# should presolver be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
propagating/probing/presoldelay = TRUE

# maximal number of runs, probing participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: 1]
propagating/probing/maxruns = 1

# maximal number of propagation rounds in probing subproblems (-1: no limit, 0: auto)
# [type: int, range: [-1,2147483647], default: -1]
propagating/probing/proprounds = -1

# maximal number of fixings found, until probing is interrupted (0: don't iterrupt)
# [type: int, range: [0,2147483647], default: 25]
propagating/probing/maxfixings = 25

# maximal number of successive probings without fixings, until probing is aborted (0: don't abort)
# [type: int, range: [0,2147483647], default: 1000]
propagating/probing/maxuseless = 1000

# maximal number of successive probings without fixings, bound changes, and implications, until probing is aborted (0: don't abort)
# [type: int, range: [0,2147483647], default: 50]
propagating/probing/maxtotaluseless = 50

# maximal number of probings without fixings, until probing is aborted (0: don't abort)
# [type: int, range: [0,2147483647], default: 0]
propagating/probing/maxsumuseless = 0

# priority of propagator <pseudoobj>
# [type: int, range: [-536870912,536870911], default: 100000]
propagating/pseudoobj/priority = 100000

# frequency for calling propagator <pseudoobj> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
propagating/pseudoobj/freq = 1

# should propagator be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
propagating/pseudoobj/delay = FALSE

# presolving priority of propagator <pseudoobj>
# [type: int, range: [-536870912,536870911], default: 6000000]
propagating/pseudoobj/presolpriority = 6000000

# maximal number of presolving rounds the propagator participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
propagating/pseudoobj/maxprerounds = -1

# should presolver be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
propagating/pseudoobj/presoldelay = TRUE

# minimal number of successive none binary variable propagator whithout a bound reduction before aborted
# [type: int, range: [0,2147483647], default: 100]
propagating/pseudoobj/minuseless = 100

# maximal fraction of none binary variables with non-zero objective without a bound reduction before aborted
# [type: real, range: [0,1], default: 0.1]
propagating/pseudoobj/maxvarsfrac = 0.1

# do we want to propagate full if we are propagating the root node, despite the number of maxcand
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
propagating/pseudoobj/propfullinroot = TRUE

# propagate new cutoff bound directly globally
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
propagating/pseudoobj/propcutoffbound = TRUE

# should the propagator be forced even active pricer are present?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
propagating/pseudoobj/force = FALSE

# number of variable added after the propgatore is reinitialized?
# [type: int, range: [0,2147483647], default: 1000]
propagating/pseudoobj/maxnewvars = 1000

# priority of propagator <redcost>
# [type: int, range: [-536870912,536870911], default: 10000000]
propagating/redcost/priority = 10000000

# frequency for calling propagator <redcost> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
propagating/redcost/freq = 1

# should propagator be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
propagating/redcost/delay = FALSE

# presolving priority of propagator <redcost>
# [type: int, range: [-536870912,536870911], default: 0]
propagating/redcost/presolpriority = 0

# maximal number of presolving rounds the propagator participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: 0]
propagating/redcost/maxprerounds = 0

# should presolver be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
propagating/redcost/presoldelay = TRUE

# should reduced cost fixing be also applied to continuous variables?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
propagating/redcost/continuous = FALSE

# priority of propagator <rootredcost>
# [type: int, range: [-536870912,536870911], default: 1000000]
propagating/rootredcost/priority = 1000000

# frequency for calling propagator <rootredcost> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
propagating/rootredcost/freq = 1

# should propagator be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
propagating/rootredcost/delay = FALSE

# presolving priority of propagator <rootredcost>
# [type: int, range: [-536870912,536870911], default: 0]
propagating/rootredcost/presolpriority = 0

# maximal number of presolving rounds the propagator participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: 0]
propagating/rootredcost/maxprerounds = 0

# should presolver be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
propagating/rootredcost/presoldelay = TRUE

# priority of propagator <vbounds>
# [type: int, range: [-536870912,536870911], default: 2000000]
propagating/vbounds/priority = 2000000

# frequency for calling propagator <vbounds> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
propagating/vbounds/freq = 1

# should propagator be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
propagating/vbounds/delay = FALSE

# presolving priority of propagator <vbounds>
# [type: int, range: [-536870912,536870911], default: 0]
propagating/vbounds/presolpriority = 0

# maximal number of presolving rounds the propagator participates in (-1: no limit)
# [type: int, range: [-1,2147483647], default: 0]
propagating/vbounds/maxprerounds = 0

# should presolver be delayed, if other propagators found reductions?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
propagating/vbounds/presoldelay = TRUE

# should bound widening be used to initialize conflict analysis?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
propagating/vbounds/usebdwidening = TRUE

# priority of separator <clique>
# [type: int, range: [-536870912,536870911], default: -5000]
separating/clique/priority = -5000

# frequency for calling separator <clique> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
separating/clique/freq = 0

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <clique> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/clique/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/clique/delay = FALSE

# factor for scaling weights
# [type: real, range: [1,1.79769313486232e+308], default: 1000]
separating/clique/scaleval = 1000

# maximal number of nodes in branch and bound tree (-1: no limit)
# [type: int, range: [-1,2147483647], default: 10000]
separating/clique/maxtreenodes = 10000

# frequency for premature backtracking up to tree level 1 (0: no backtracking)
# [type: int, range: [0,2147483647], default: 1000]
separating/clique/backtrackfreq = 1000

# maximal number of clique cuts separated per separation round (-1: no limit)
# [type: int, range: [-1,2147483647], default: 10]
separating/clique/maxsepacuts = 10

# maximal number of zero-valued variables extending the clique (-1: no limit)
# [type: int, range: [-1,2147483647], default: 1000]
separating/clique/maxzeroextensions = 1000

# maximal memory size of dense clique table (in kb)
# [type: real, range: [0,2097151.99902344], default: 20000]
separating/clique/cliquetablemem = 20000

# minimal density of cliques to use a dense clique table
# [type: real, range: [0,1], default: 0.05]
separating/clique/cliquedensity = 0.05

# priority of separator <closecuts>
# [type: int, range: [-536870912,536870911], default: 1000000]
separating/closecuts/priority = 1000000

# frequency for calling separator <closecuts> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
separating/closecuts/freq = -1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <closecuts> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 1]
separating/closecuts/maxbounddist = 1

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/closecuts/delay = FALSE

# generate close cuts w.r.t. relative interior point (best solution otherwise)?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/closecuts/separelint = TRUE

# convex combination value for close cuts
# [type: real, range: [0,1], default: 0.3]
separating/closecuts/sepacombvalue = 0.3

# generate close cuts in the root only?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/closecuts/separootonly = TRUE

# threshold on number of generated cuts below which the ordinary separation is started
# [type: int, range: [-1,2147483647], default: 50]
separating/closecuts/closethres = 50

# include an objective cutoff when computing the relative interior?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/closecuts/inclobjcutoff = FALSE

# recompute relative interior point in each separation call?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/closecuts/recomputerelint = FALSE

# type of norm to use when computing relative interior: 'o'ne norm, 's'upremum norm
# [type: char, range: {os}, default: o]
separating/closecuts/relintnormtype = o

# turn off separation in current node after unsuccessful calls (-1 never turn off)
# [type: int, range: [-1,2147483647], default: 0]
separating/closecuts/maxunsuccessful = 0

# priority of separator <cgmip>
# [type: int, range: [-536870912,536870911], default: -1000]
separating/cgmip/priority = -1000

# frequency for calling separator <cgmip> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
separating/cgmip/freq = -1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <cgmip> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/cgmip/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/cgmip/delay = FALSE

# maximal number of cgmip separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
separating/cgmip/maxrounds = 5

# maximal number of cgmip separation rounds in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 50]
separating/cgmip/maxroundsroot = 50

# maximal depth at which the separator is applied (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
separating/cgmip/maxdepth = -1

# should generated cuts be removed from the LP if they are no longer tight?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/cgmip/dynamiccuts = TRUE

# time limit for sub-MIP
# [type: real, range: [0,1.79769313486232e+308], default: 1e+20]
separating/cgmip/timelimit = 1e+20

# memory limit for sub-MIP
# [type: real, range: [0,1.79769313486232e+308], default: 1e+20]
separating/cgmip/memorylimit = 1e+20

# node limit for sub-MIP (-1: unlimited)
# [type: longint, range: [-1,9223372036854775807], default: 10000]
separating/cgmip/nodelimit = 10000

# weight used for the row combination coefficient in the sub-MIP objective
# [type: real, range: [0,1.79769313486232e+308], default: 0.001]
separating/cgmip/objweight = 0.001

# use CMIR-generator (otherwise add cut directly)?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/cgmip/usecmir = TRUE

# tell CMIR-generator which bounds to used in rounding?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/cgmip/cmirownbounds = FALSE

# allow to generate local cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/cgmip/allowlocal = FALSE

# generate cuts for problems with only integer variables?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/cgmip/onlyintvars = FALSE

# use only active rows to generate cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/cgmip/onlyactiverows = FALSE

# maximal age of rows to consider if onlyactiverows is false
# [type: int, range: [-1,2147483647], default: -1]
separating/cgmip/maxrowage = -1

# use cutpool to store CG-cuts even if the are not efficient?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/cgmip/usecutpool = TRUE

# only separate cuts that are tight for the best feasible solution?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/cgmip/primalseparation = TRUE

# whether only rank 1 inequalities should be separated
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/cgmip/onlyrankone = FALSE

# terminate separation if a violated (but possibly sub-optimal) cut has been found?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/cgmip/earlyterm = TRUE

# add constraint to subscip that only allows violated cuts?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/cgmip/addviolationcons = TRUE

# add constraint handler to filter out violated cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/cgmip/addviolconshdlr = FALSE

# should the violation constraint handler use the norm of a cut to check for feasibility?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/cgmip/conshdlrusenorm = TRUE

# should the objective of the sub-MIP minimize the l1-norm of the multipliers?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/cgmip/objlone = FALSE

# convert some integral variables to be continuous to reduce the size of the sub-MIP?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/cgmip/contconvert = TRUE

# fraction of integral variables converted to be continuous (if contconvert)
# [type: real, range: [0,1], default: 0.5]
separating/cgmip/contconvfrac = 0.5

# minimum number of integral variables before some are converted to be continuous
# [type: int, range: [-1,2147483647], default: 100]
separating/cgmip/contconvmin = 100

# priority of separator <cmir>
# [type: int, range: [-536870912,536870911], default: -3000]
separating/cmir/priority = -3000

# frequency for calling separator <cmir> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
separating/cmir/freq = 0

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <cmir> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/cmir/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/cmir/delay = FALSE

# maximal number of cmir separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 3]
separating/cmir/maxrounds = 3

# maximal number of cmir separation rounds in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 10]
separating/cmir/maxroundsroot = 10

# maximal number of rows to start aggregation with per separation round (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 100]
separating/cmir/maxtries = 100

# maximal number of rows to start aggregation with per separation round in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
separating/cmir/maxtriesroot = -1

# maximal number of consecutive unsuccessful aggregation tries (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 20]
separating/cmir/maxfails = 20

# maximal number of consecutive unsuccessful aggregation tries in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 100]
separating/cmir/maxfailsroot = 100

# maximal number of aggregations for each row per separation round
# [type: int, range: [0,2147483647], default: 3]
separating/cmir/maxaggrs = 3

# maximal number of aggregations for each row per separation round in the root node
# [type: int, range: [0,2147483647], default: 6]
separating/cmir/maxaggrsroot = 6

# maximal number of cmir cuts separated per separation round
# [type: int, range: [0,2147483647], default: 100]
separating/cmir/maxsepacuts = 100

# maximal number of cmir cuts separated per separation round in the root node
# [type: int, range: [0,2147483647], default: 500]
separating/cmir/maxsepacutsroot = 500

# maximal slack of rows to be used in aggregation
# [type: real, range: [0,1.79769313486232e+308], default: 0]
separating/cmir/maxslack = 0

# maximal slack of rows to be used in aggregation in the root node
# [type: real, range: [0,1.79769313486232e+308], default: 0.1]
separating/cmir/maxslackroot = 0.1

# weight of row density in the aggregation scoring of the rows
# [type: real, range: [0,1.79769313486232e+308], default: 0.0001]
separating/cmir/densityscore = 0.0001

# weight of slack in the aggregation scoring of the rows
# [type: real, range: [0,1.79769313486232e+308], default: 0.001]
separating/cmir/slackscore = 0.001

# maximal density of aggregated row
# [type: real, range: [0,1], default: 0.2]
separating/cmir/maxaggdensity = 0.2

# maximal density of row to be used in aggregation
# [type: real, range: [0,1], default: 0.05]
separating/cmir/maxrowdensity = 0.05

# additional number of variables allowed in row on top of density
# [type: int, range: [0,2147483647], default: 100]
separating/cmir/densityoffset = 100

# maximal row aggregation factor
# [type: real, range: [0,1.79769313486232e+308], default: 10000]
separating/cmir/maxrowfac = 10000

# maximal number of different deltas to try (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
separating/cmir/maxtestdelta = -1

# maximal number of active continuous variables in aggregated row
# [type: int, range: [0,2147483647], default: 10]
separating/cmir/maxconts = 10

# maximal number of active continuous variables in aggregated row in the root node
# [type: int, range: [0,2147483647], default: 10]
separating/cmir/maxcontsroot = 10

# tolerance for bound distances used to select continuous variable in current aggregated constraint to be eliminated
# [type: real, range: [0,1.79769313486232e+308], default: 0.1]
separating/cmir/aggrtol = 0.1

# should negative values also be tested in scaling?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/cmir/trynegscaling = TRUE

# should an additional variable be complemented if f0 = 0?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/cmir/fixintegralrhs = TRUE

# should generated cuts be removed from the LP if they are no longer tight?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/cmir/dynamiccuts = TRUE

# priority of separator <flowcover>
# [type: int, range: [-536870912,536870911], default: -4000]
separating/flowcover/priority = -4000

# frequency for calling separator <flowcover> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
separating/flowcover/freq = 0

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <flowcover> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/flowcover/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/flowcover/delay = FALSE

# maximal number of separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
separating/flowcover/maxrounds = 5

# maximal number of separation rounds in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 10]
separating/flowcover/maxroundsroot = 10

# maximal number of rows to separate flow cover cuts for per separation round (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 100]
separating/flowcover/maxtries = 100

# maximal number of rows to separate flow cover cuts for per separation round in the root (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
separating/flowcover/maxtriesroot = -1

# maximal number of consecutive fails to generate a cut per separation round (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 50]
separating/flowcover/maxfails = 50

# maximal number of consecutive fails to generate a cut per separation round in the root (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 100]
separating/flowcover/maxfailsroot = 100

# maximal number of flow cover cuts separated per separation round
# [type: int, range: [0,2147483647], default: 100]
separating/flowcover/maxsepacuts = 100

# maximal number of flow cover cuts separated per separation round in the root
# [type: int, range: [0,2147483647], default: 200]
separating/flowcover/maxsepacutsroot = 200

# maximal slack of rows to separate flow cover cuts for
# [type: real, range: [0,1.79769313486232e+308], default: 1.79769313486232e+308]
separating/flowcover/maxslack = 1.79769313486232e+308

# maximal slack of rows to separate flow cover cuts for in the root
# [type: real, range: [0,1.79769313486232e+308], default: 1.79769313486232e+308]
separating/flowcover/maxslackroot = 1.79769313486232e+308

# weight of slack in the scoring of the rows
# [type: real, range: [0,1.79769313486232e+308], default: 0.001]
separating/flowcover/slackscore = 0.001

# maximal density of row to separate flow cover cuts for
# [type: real, range: [0,1], default: 1]
separating/flowcover/maxrowdensity = 1

# should generated cuts be removed from the LP if they are no longer tight?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/flowcover/dynamiccuts = TRUE

# should flow cover cuts be separated for 0-1 single node flow set with reversed arcs in addition?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/flowcover/multbyminusone = TRUE

# cut generation heuristic: maximal number of different deltas to try
# [type: int, range: [0,2147483647], default: 10]
separating/flowcover/maxtestdelta = 10

# priority of separator <gomory>
# [type: int, range: [-536870912,536870911], default: -1000]
separating/gomory/priority = -1000

# frequency for calling separator <gomory> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
separating/gomory/freq = 0

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <gomory> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/gomory/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/gomory/delay = FALSE

# maximal number of gomory separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
separating/gomory/maxrounds = 5

# maximal number of gomory separation rounds in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 10]
separating/gomory/maxroundsroot = 10

# maximal number of gomory cuts separated per separation round
# [type: int, range: [0,2147483647], default: 50]
separating/gomory/maxsepacuts = 50

# maximal number of gomory cuts separated per separation round in the root node
# [type: int, range: [0,2147483647], default: 50]
separating/gomory/maxsepacutsroot = 50

# maximal valid range max(|weights|)/min(|weights|) of row weights
# [type: real, range: [1,1.79769313486232e+308], default: 10000]
separating/gomory/maxweightrange = 10000

# should generated cuts be removed from the LP if they are no longer tight?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/gomory/dynamiccuts = TRUE

# priority of separator <impliedbounds>
# [type: int, range: [-536870912,536870911], default: -50]
separating/impliedbounds/priority = -50

# frequency for calling separator <impliedbounds> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
separating/impliedbounds/freq = 0

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <impliedbounds> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/impliedbounds/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/impliedbounds/delay = FALSE

# priority of separator <intobj>
# [type: int, range: [-536870912,536870911], default: -100]
separating/intobj/priority = -100

# frequency for calling separator <intobj> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
separating/intobj/freq = -1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <intobj> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/intobj/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/intobj/delay = FALSE

# priority of separator <mcf>
# [type: int, range: [-536870912,536870911], default: -10000]
separating/mcf/priority = -10000

# frequency for calling separator <mcf> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
separating/mcf/freq = 0

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <mcf> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/mcf/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/mcf/delay = FALSE

# number of clusters to generate in the shrunken network -- default separation
# [type: int, range: [2,32], default: 5]
separating/mcf/nclusters = 5

# maximal valid range max(|weights|)/min(|weights|) of row weights
# [type: real, range: [1,1.79769313486232e+308], default: 1000000]
separating/mcf/maxweightrange = 1000000

# maximal number of different deltas to try (-1: unlimited)  -- default separation
# [type: int, range: [-1,2147483647], default: 20]
separating/mcf/maxtestdelta = 20

# should negative values also be tested in scaling?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/mcf/trynegscaling = FALSE

# should an additional variable be complemented if f0 = 0?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/mcf/fixintegralrhs = TRUE

# should generated cuts be removed from the LP if they are no longer tight?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/mcf/dynamiccuts = TRUE

# model type of network (0: auto, 1:directed, 2:undirected)
# [type: int, range: [0,2], default: 0]
separating/mcf/modeltype = 0

# maximal number of mcf cuts separated per separation round
# [type: int, range: [-1,2147483647], default: 100]
separating/mcf/maxsepacuts = 100

# maximal number of mcf cuts separated per separation round in the root node  -- default separation
# [type: int, range: [-1,2147483647], default: 200]
separating/mcf/maxsepacutsroot = 200

# maximum inconsistency ratio for separation at all
# [type: real, range: [0,1.79769313486232e+308], default: 0.02]
separating/mcf/maxinconsistencyratio = 0.02

# maximum inconsistency ratio of arcs not to be deleted
# [type: real, range: [0,1.79769313486232e+308], default: 0.5]
separating/mcf/maxarcinconsistencyratio = 0.5

# should we separate only if the cuts shores are connected?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/mcf/checkcutshoreconnectivity = TRUE

# should we separate inequalities based on single-node cuts?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/mcf/separatesinglenodecuts = TRUE

# should we separate flowcutset inequalities on the network cuts?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/mcf/separateflowcutset = TRUE

# should we separate knapsack cover inequalities on the network cuts?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/mcf/separateknapsack = TRUE

# priority of separator <oddcycle>
# [type: int, range: [-536870912,536870911], default: -15000]
separating/oddcycle/priority = -15000

# frequency for calling separator <oddcycle> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
separating/oddcycle/freq = -1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <oddcycle> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 1]
separating/oddcycle/maxbounddist = 1

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/oddcycle/delay = FALSE

# should classical search method by Groetschel, Lovasz, Schrijver be used? Otherwise use levelgraph method by Hoffman, Padberg.
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/oddcycle/useclassical = TRUE

# should odd cycle cuts be lifted?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/oddcycle/liftoddcycles = FALSE

# maximal number of oddcycle cuts separated per separation round
# [type: int, range: [0,2147483647], default: 5000]
separating/oddcycle/maxsepacuts = 5000

# maximal number of oddcycle cuts separated per separation round in the root node
# [type: int, range: [0,2147483647], default: 5000]
separating/oddcycle/maxsepacutsroot = 5000

# maximal number of oddcycle separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 10]
separating/oddcycle/maxrounds = 10

# maximal number of oddcycle separation rounds in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 10]
separating/oddcycle/maxroundsroot = 10

# factor for scaling of the arc-weights
# [type: int, range: [1,2147483647], default: 1000]
separating/oddcycle/scalingfactor = 1000

# add links between a variable and its negated
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/oddcycle/addselfarcs = TRUE

# try to repair violated cycles with double appearance of a variable
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/oddcycle/repaircycles = TRUE

# separate triangles found as 3-cycles or repaired larger cycles
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/oddcycle/includetriangles = TRUE

# even if a variable is already covered by a cut, still try it as start node for a cycle search
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/oddcycle/multiplecuts = FALSE

# even if a variable is already covered by a cut, still allow another cut to cover it too
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/oddcycle/allowmultiplecuts = TRUE

# choose lifting candidate by coef*lpvalue or only by coef
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/oddcycle/lpliftcoef = FALSE

# calculate lifting coefficient of every candidate in every step (or only if its chosen)
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/oddcycle/recalcliftcoef = TRUE

# use sorted variable array (unsorted(0),maxlp(1),minlp(2),maxfrac(3),minfrac(4))
# [type: int, range: [0,4], default: 3]
separating/oddcycle/sortswitch = 3

# sort level of the root neighbors by fractionality (maxfrac)
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/oddcycle/sortrootneighbors = TRUE

# percentage of variables to try the chosen method on [0-100]
# [type: int, range: [0,100], default: 0]
separating/oddcycle/percenttestvars = 0

# offset of variables to try the chosen method on (additional to the percentage of testvars)
# [type: int, range: [0,2147483647], default: 100]
separating/oddcycle/offsettestvars = 100

# percentage of nodes allowed in the same level of the level graph [0-100]
# [type: int, range: [0,100], default: 100]
separating/oddcycle/maxpernodeslevel = 100

# offset of nodes allowed in the same level of the level graph (additional to the percentage of levelnodes)
# [type: int, range: [0,2147483647], default: 10]
separating/oddcycle/offsetnodeslevel = 10

# maximal number of levels in level graph
# [type: int, range: [0,2147483647], default: 20]
separating/oddcycle/maxnlevels = 20

# maximal number of oddcycle cuts generated per chosen variable as root of the level graph
# [type: int, range: [0,2147483647], default: 1]
separating/oddcycle/maxcutsroot = 1

# maximal number of oddcycle cuts generated in every level of the level graph
# [type: int, range: [0,2147483647], default: 50]
separating/oddcycle/maxcutslevel = 50

# minimal weight on an edge (in level graph or bipartite graph)
# [type: int, range: [0,2147483647], default: 0]
separating/oddcycle/maxreference = 0

# priority of separator <rapidlearning>
# [type: int, range: [-536870912,536870911], default: -1200000]
separating/rapidlearning/priority = -1200000

# frequency for calling separator <rapidlearning> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
separating/rapidlearning/freq = -1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <rapidlearning> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 1]
separating/rapidlearning/maxbounddist = 1

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/rapidlearning/delay = FALSE

# should the found conflicts be applied in the original SCIP?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/rapidlearning/applyconflicts = TRUE

# should the found global bound deductions be applied in the original SCIP?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/rapidlearning/applybdchgs = TRUE

# should the inference values be used as initialization in the original SCIP?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/rapidlearning/applyinfervals = TRUE

# should the inference values only be used when rapidlearning found other reductions?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/rapidlearning/reducedinfer = FALSE

# should the incumbent solution be copied to the original SCIP?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/rapidlearning/applyprimalsol = TRUE

# should a solved status be copied to the original SCIP?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/rapidlearning/applysolved = TRUE

# should rapid learning be applied when there are continuous variables?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/rapidlearning/contvars = FALSE

# maximal portion of continuous variables to apply rapid learning
# [type: real, range: [0,1], default: 0.3]
separating/rapidlearning/contvarsquot = 0.3

# maximal fraction of LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.2]
separating/rapidlearning/lpiterquot = 0.2

# maximum problem size (variables) for which rapid learning will be called
# [type: int, range: [0,2147483647], default: 10000]
separating/rapidlearning/maxnvars = 10000

# maximum problem size (constraints) for which rapid learning will be called
# [type: int, range: [0,2147483647], default: 10000]
separating/rapidlearning/maxnconss = 10000

# maximum number of nodes considered in rapid learning run
# [type: int, range: [0,2147483647], default: 5000]
separating/rapidlearning/maxnodes = 5000

# minimum number of nodes considered in rapid learning run
# [type: int, range: [0,2147483647], default: 500]
separating/rapidlearning/minnodes = 500

# should all active cuts from cutpool be copied to constraints in subproblem?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/rapidlearning/copycuts = TRUE

# priority of separator <strongcg>
# [type: int, range: [-536870912,536870911], default: -2000]
separating/strongcg/priority = -2000

# frequency for calling separator <strongcg> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
separating/strongcg/freq = 0

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <strongcg> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/strongcg/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/strongcg/delay = FALSE

# maximal number of strong CG separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
separating/strongcg/maxrounds = 5

# maximal number of strong CG separation rounds in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 20]
separating/strongcg/maxroundsroot = 20

# maximal number of strong CG cuts separated per separation round
# [type: int, range: [0,2147483647], default: 50]
separating/strongcg/maxsepacuts = 50

# maximal number of strong CG cuts separated per separation round in the root node
# [type: int, range: [0,2147483647], default: 500]
separating/strongcg/maxsepacutsroot = 500

# maximal valid range max(|weights|)/min(|weights|) of row weights
# [type: real, range: [1,1.79769313486232e+308], default: 10000]
separating/strongcg/maxweightrange = 10000

# should generated cuts be removed from the LP if they are no longer tight?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/strongcg/dynamiccuts = TRUE

# priority of separator <zerohalf>
# [type: int, range: [-536870912,536870911], default: -6000]
separating/zerohalf/priority = -6000

# frequency for calling separator <zerohalf> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
separating/zerohalf/freq = -1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <zerohalf> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/zerohalf/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/zerohalf/delay = FALSE

# maximal number of zerohalf separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
separating/zerohalf/maxrounds = 5

# maximal number of zerohalf separation rounds in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 10]
separating/zerohalf/maxroundsroot = 10

# maximal number of {0,1/2}-cuts separated per separation round
# [type: int, range: [0,2147483647], default: 50]
separating/zerohalf/maxsepacuts = 50

# maximal number of {0,1/2}-cuts separated per separation round in the root node
# [type: int, range: [0,2147483647], default: 500]
separating/zerohalf/maxsepacutsroot = 500

# should generated cuts be removed from the LP if they are no longer tight?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/zerohalf/dynamiccuts = TRUE

# maximal number of {0,1/2}-cuts determined per separation round 
   #                      (this includes separated but inefficacious cuts)
# [type: int, range: [0,2147483647], default: 100]
separating/zerohalf/maxcutsfound = 100

# maximal number of {0,1/2}-cuts determined per separation round in the root node
   #                      (this includes separated but inefficacious cuts)
# [type: int, range: [0,2147483647], default: 1000]
separating/zerohalf/maxcutsfoundroot = 1000

# separating cuts only if depth <= maxdepth (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
separating/zerohalf/maxdepth = -1

# maximal number of calls (-1: unlimited)
# [type: longint, range: [-1,9223372036854775807], default: -1]
separating/zerohalf/maxncalls = -1

# should continuous variables be relaxed by adding variable bounds?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/zerohalf/relaxcontvars = FALSE

# should rows be scaled to make fractional coefficients integer?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/zerohalf/scalefraccoeffs = TRUE

# should zerohalf cuts found in previous callbacks ignored?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/zerohalf/ignoreprevzhcuts = FALSE

# should only original LP rows be considered (i.e. ignore previously added LP rows)?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/zerohalf/onlyorigrows = FALSE

# should zerohalf cuts be filtered using a cutpool?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/zerohalf/usezhcutpool = TRUE

# maximal number of different deltas to try for cmir (-1: unlimited, 0: delta=1)
# [type: int, range: [-1,2147483647], default: 10]
separating/zerohalf/maxtestdelta = 10

# should negative values also be tested in scaling for cmir?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/zerohalf/trynegscaling = TRUE

# should problem be decomposed into subproblems (if possible) before applying preprocessing?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/zerohalf/preprocessing/decomposeproblem = FALSE

# value of delta parameter used in preprocessing method 'd'
# [type: real, range: [0,1], default: 0.5]
separating/zerohalf/preprocessing/delta = 0.5

# preprocessing methods and ordering:
   #                      'd' columns with small LP solution,
    #                      'G' modified Gaussian elimination,
     #                      'i' identical columns,
   #                      'I' identical rows,
   #                      'L' large slack rows,
   #                      'M' large slack rows (minslack),
   #                      's' column singletons,
   #                      'X' add trivial zerohalf cuts,
   #                      'z' zero columns,
   #                      'Z' zero rows,
   #                      'C' fast {'z','s'},
   #                      'R' fast {'Z','L','I'}
   #                      
                         #                      '-' no preprocessing
     #                     
# [type: string, default: "CXGXIM"]
separating/zerohalf/preprocessing/ppmethods = "CXGXIM"

# should the cuts be forced to enter the LP?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/zerohalf/separating/forcecutstolp = FALSE

# should the cuts be forced to enter SCIP's sepastore?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/zerohalf/separating/forcecutstosepastore = FALSE

# minimal violation of a {0,1/2}-cut to be separated
# [type: real, range: [0.001,0.5], default: 0.3]
separating/zerohalf/separating/minviolation = 0.3

# separating methods and ordering:
   #                      '!' stop further processing if a cut was found,
   #                      '2' exact polynomial time algorithm (only if matrix has max 2 odd entries per row),
   #                      'e' enumeration heuristics (k=1: try all preprocessed rows),
   #                      'E' enumeration heuristics (k=2: try all combinations of up to two preprocessed rows),
   #                      'g' Extended Gaussian elimination heuristics,
   #                      's' auxiliary IP heuristics (i.e. number of solved nodes is limited)
   #                      'S' auxiliary IP exact      (i.e. unlimited number of nodes)
   #                      
   #                      '-' no processing
   #                     
# [type: string, default: "2g"]
separating/zerohalf/separating/sepamethods = "2g"

# optional settings file of the auxiliary IP (-: none)
# [type: string, default: "-"]
separating/zerohalf/separating/auxip/settingsfile = "-"

# limits/solutions setting of the auxiliary IP
# [type: int, range: [-1,2147483647], default: -1]
separating/zerohalf/separating/auxip/sollimit = -1

# penalty factor used with objective function 'p' of auxiliary IP
# [type: real, range: [0,1], default: 0.001]
separating/zerohalf/separating/auxip/penaltyfactor = 0.001

# should all (proper) solutions of the auxiliary IP be used to generate cuts instead of using only the best?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/zerohalf/separating/auxip/useallsols = TRUE

# auxiliary IP objective:
   #                      'v' maximize cut violation,
   #                      'u' minimize number of aggregated rows in cut,
   #                      'w' minimize number of aggregated rows in cut
   #                          weighted by the number of rows in the aggregation,
   #                      'p' maximize cut violation and penalize a high number
   #                          of aggregated rows in the cut weighted by the number
   #                          of rows in the aggregation and the penalty factor p
   #                     
# [type: char, range: {uvwp}, default: v]
separating/zerohalf/separating/auxip/objective = v

# display activation status of display column <solfound> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/solfound/active = 1

# display activation status of display column <time> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/time/active = 1

# display activation status of display column <nnodes> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/nnodes/active = 1

# display activation status of display column <nodesleft> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/nodesleft/active = 1

# display activation status of display column <lpiterations> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/lpiterations/active = 1

# display activation status of display column <lpavgiterations> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/lpavgiterations/active = 1

# display activation status of display column <lpcond> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/lpcond/active = 1

# display activation status of display column <memused> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/memused/active = 1

# display activation status of display column <depth> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/depth/active = 1

# display activation status of display column <maxdepth> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/maxdepth/active = 1

# display activation status of display column <plungedepth> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/plungedepth/active = 1

# display activation status of display column <nfrac> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/nfrac/active = 1

# display activation status of display column <nexternbranchcands> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/nexternbranchcands/active = 1

# display activation status of display column <vars> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/vars/active = 1

# display activation status of display column <conss> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/conss/active = 1

# display activation status of display column <curconss> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/curconss/active = 1

# display activation status of display column <curcols> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/curcols/active = 1

# display activation status of display column <currows> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/currows/active = 1

# display activation status of display column <cuts> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/cuts/active = 1

# display activation status of display column <separounds> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/separounds/active = 1

# display activation status of display column <poolsize> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/poolsize/active = 1

# display activation status of display column <conflicts> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/conflicts/active = 1

# display activation status of display column <strongbranchs> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/strongbranchs/active = 1

# display activation status of display column <lpobj> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/lpobj/active = 1

# display activation status of display column <curdualbound> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/curdualbound/active = 1

# display activation status of display column <estimate> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/estimate/active = 1

# display activation status of display column <avgdualbound> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/avgdualbound/active = 1

# display activation status of display column <dualbound> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/dualbound/active = 1

# display activation status of display column <primalbound> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/primalbound/active = 1

# display activation status of display column <cutoffbound> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/cutoffbound/active = 1

# display activation status of display column <gap> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/gap/active = 1

# display activation status of display column <primalgap> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 0]
display/primalgap/active = 0

# display activation status of display column <nsols> (0: off, 1: auto, 2:on)
# [type: int, range: [0,2], default: 1]
display/nsols/active = 1

